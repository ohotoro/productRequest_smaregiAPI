
<script>

// ===== localStorage 안전 초기화 (가장 먼저 실행) =====
(function() {
  try {
    // 버전 관리
    const APP_VERSION = '1.0.1'; // 버전 변경 시 캐시 자동 클리어
    const savedVersion = localStorage.getItem('app_version');
    
    if (savedVersion !== APP_VERSION) {
      localStorage.clear();
      sessionStorage.clear();
      localStorage.setItem('app_version', APP_VERSION);
      console.log('캐시 클리어 완료 - 새 버전:', APP_VERSION);
    }
    
    // 오래된 데이터 정리 (30일 이상)
    const maxAge = 30 * 24 * 60 * 60 * 1000;
    const now = Date.now();
    
    Object.keys(localStorage).forEach(key => {
      try {
        const item = localStorage.getItem(key);
        if (item && key !== 'app_version') {
          const parsed = JSON.parse(item);
          if (parsed.timestamp && (now - parsed.timestamp) > maxAge) {
            localStorage.removeItem(key);
          }
        }
      } catch (e) {
        // JSON 파싱 실패 시 제거
        if (key !== 'app_version') {
          localStorage.removeItem(key);
        }
      }
    });
    
  } catch (error) {
    console.error('초기화 오류:', error);
    // 심각한 오류 시 전체 클리어
    try {
      localStorage.clear();
      sessionStorage.clear();
    } catch (e) {
      // localStorage 접근 불가 시
    }
  }
})();

// ===== 1. 전역 상수 및 설정 =====
const CONFIG = {
  CACHE_TTL: 300000,
  SESSION_TTL: 1800000,
  AUTO_SAVE_DELAY: 30000,
  SEARCH_DEBOUNCE: 1000,
  MAX_CACHE_SIZE: 100,
  MAX_SESSION_ITEMS: 100
};

// ===== 2. 전역 상태 관리 (최소화) =====
const AppState = {
  products: [],
  orderItems: [],
  currentOrderInfo: null,
  currentFilter: 'all',
  settings: {},
  isSearching: false,
  hasUnsavedChanges: false,
  currentLang: 'ko',
  translations: {},
  categoryRules: {},
  productIssues: {},
  safetyStockCache: [],
  smaregiData: {},
  smaregiUploadTime: null,
  smaregiDataLoaded: false,
  uploadedCSVContent: null,
  uploadedSmaregiContent: null,
  currentStockEditItem: null,
  timers: {
    autoSave: null,
    search: null,
    safetySearch: null,
    retry: null,
    issue: null
  },
  voiceSettings: {
    volume: 0.8,
    rate: 1.2,
    pitch: 1.0,
    language: 'ko-KR'
  },
  timers: {
    autoSave: null,
    search: null,
    safetySearch: null,
    retry: null,
    issue: null
  }
};

// 1. 자동 동기화 설정
let syncInterval = null;
let currentVersion = 0;
let currentSortField = 'default';
let currentSortOrder = 'asc';

function startAutoSync() {
  if (!AppState.currentOrderInfo) return;
  
  // 30초마다 업데이트 체크
  syncInterval = setInterval(() => {
    checkForOrderUpdates();
  }, 30000);
}

function stopAutoSync() {
  if (syncInterval) {
    clearInterval(syncInterval);
    syncInterval = null;
  }
}

// 2. 업데이트 체크
function checkForOrderUpdates() {
  if (!AppState.currentOrderInfo || AppState.hasUnsavedChanges) return;
  
  google.script.run
    .withSuccessHandler((result) => {
      if (result.hasUpdate) {
        showUpdateNotification(result);
      }
    })
    .withFailureHandler((error) => {
      console.warn('동기화 체크 실패:', error);
    })
    .checkForUpdates(AppState.currentOrderInfo.orderId, currentVersion);
}

// 3. 업데이트 알림
function showUpdateNotification(updateInfo) {
  const notification = document.createElement('div');
  notification.className = 'sync-notification';
  notification.innerHTML = `
    <div class="sync-notification-content">
      <div class="sync-icon">🔄</div>
      <div class="sync-message">
        <strong>${updateInfo.modifiedBy}님이 발주서를 수정했습니다.</strong>
        <p>변경사항을 불러오시겠습니까?</p>
      </div>
      <div class="sync-actions">
        <button class="btn btn-primary btn-sm" onclick="reloadOrderItems()">
          새로고침
        </button>
        <button class="btn btn-secondary btn-sm" onclick="dismissSyncNotification(this)">
          나중에
        </button>
      </div>
    </div>
  `;
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    notification.classList.add('show');
  }, 100);
}

// 4. 발주 항목 새로고침
function reloadOrderItems() {
  showLoading('최신 데이터 로드 중...');
  
  loadOrderItemsFromSheetAsync()
    .then(() => {
      hideLoading();
      showQuickSuccess('최신 데이터로 업데이트되었습니다.');
      dismissAllSyncNotifications();
    })
    .catch((error) => {
      hideLoading();
      showError('업데이트 실패: ' + error);
    });
}

// 5. 충돌 방지를 위한 저장 전 체크
function saveToOrderSheet(orderItems) {
  // 저장 전 최신 버전 확인
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler((updateCheck) => {
        if (updateCheck.hasUpdate) {
          // 충돌 감지
          if (confirm(`${updateCheck.modifiedBy}님이 발주서를 수정했습니다.\n계속 저장하시겠습니까?`)) {
            proceedWithSave(orderItems, resolve, reject);
          } else {
            reject('저장 취소됨');
          }
        } else {
          proceedWithSave(orderItems, resolve, reject);
        }
      })
      .withFailureHandler(reject)
      .checkForUpdates(AppState.currentOrderInfo.orderId, currentVersion);
  });
}

function proceedWithSave(orderItems, resolve, reject) {
  google.script.run
    .withSuccessHandler((result) => {
      if (result.success) {
        currentVersion = result.version;
        resolve(result);
      } else {
        reject(result.message);
      }
    })
    .withFailureHandler(reject)
    .saveToOrderSheetWithVersion(orderItems);
}

// ===== localStorage 안전 관리 함수들 =====
// 안전한 localStorage 저장
function safeSetItem(key, value) {
  try {
    const data = {
      value: value,
      timestamp: Date.now()
    };
    localStorage.setItem(key, JSON.stringify(data));
    return true;
  } catch (e) {
    console.error('localStorage 저장 실패:', e);
    // 용량 초과 시 오래된 항목 삭제
    if (e.name === 'QuotaExceededError') {
      clearOldestItems();
      try {
        localStorage.setItem(key, JSON.stringify(data));
      } catch (e2) {
        return false;
      }
    }
    return false;
  }
}

// 안전한 localStorage 읽기
function safeGetItem(key) {
  try {
    const item = localStorage.getItem(key);
    if (!item) return null;
    
    const parsed = JSON.parse(item);
    return parsed.value;
  } catch (e) {
    console.error('localStorage 읽기 실패:', e);
    localStorage.removeItem(key);
    return null;
  }
}

// 가장 오래된 항목 삭제
function clearOldestItems() {
  const items = [];
  
  Object.keys(localStorage).forEach(key => {
    if (key === 'app_version') return;
    
    try {
      const item = JSON.parse(localStorage.getItem(key));
      if (item.timestamp) {
        items.push({ key, timestamp: item.timestamp });
      }
    } catch (e) {
      localStorage.removeItem(key);
    }
  });
  
  // 오래된 순으로 정렬
  items.sort((a, b) => a.timestamp - b.timestamp);
  
  // 절반 삭제
  const removeCount = Math.floor(items.length / 2);
  for (let i = 0; i < removeCount; i++) {
    localStorage.removeItem(items[i].key);
  }
}

// ===== 3. 컬러 매핑 테이블 =====
const colorMap = {
  'black': '#000000',
  'ivory': '#FFFFF0',
  'white': '#FFFFFF',
  'cream': '#FFFDD0',
  'beige': '#F5F5DC',
  'light beige': '#F8F4E6',
  'light yellow': '#FFFDD0',
  'oatmeal': '#D4C5B0',
  'light gray': '#D3D3D3',
  'melange': '#CCCAC9',
  'light mint': '#e2f4eb',
  'denim': '#1b306b',
  'lemon': '#fffac8',
  'gray beige': '#d8cfc4',
  'purple': '#4f284b',
  'gray melange': '#87827d',
  'olive': '#6b822e',
  'white melange': 'eae9e8',
  'gray': '#808080',
  'deep gray': '#4B4B4B',
  'dark gray': '#3A3A3A',
  'charcoal': '#36454F',
  'charcoal gray': '#36454F',
  'charcoal brown': '#6e6565',
  'melange gray': '#B8B8B8',
  'mixed gray': '#666',
  'silver': '#C0C0C0',
  'stone': '#999999',
  'brown': '#8B4513',
  'dark brown': '#654321',
  'deep brown': '#5C4033',
  'light khaki': '#F0E68C',
  'khaki': '#C3B091',
  'camel': '#C19A6B',
  'mocha': '#967969',
  'mocca': '#967969',
  'pale blue': '#B0E0E6',
  'light blue': '#ADD8E6',
  'sky blue': '#87CEEB',
  'blue': '#0066CC',
  'cobalt blue': '#0047AB',
  'sora': '#87CEEB',
  'sora blue': '#87CEEB',
  'navy': '#000080',
  'deep navy': '#000054',
  'dark navy': '#00004C',
  'charcoal navy': '#1C2841',
  'red': '#DC143C',
  'wine': '#722F37',
  'pink': '#FFC0CB',
  'light pink': '#FFB6C1',
  'baby pink': '#FFE4E1',
  'dusty pink': '#D39999',
  'indie pink': '#FF69B4',
  'neon pink': '#FF10F0',
  'rose': '#FF007F',
  'green': '#008000',
  'light green': '#90EE90',
  'deep green': '#013220',
  'mint': '#3EB489',
  'sage': '#87A96B',
  'moss green': '#8A9A5B',
  'yellow': '#FFFF00',
  'mustard': '#FFDB58',
  'orange': '#FFA500',
  'brick': '#CB4154',
  'lavender': '#E6E6FA',
  'lime': '#BFFF00',
  'ivory melange': '#FAF0E6'
};

// ===== 4. 캐시 관리 통합 =====
class CacheManager {
  constructor() {
    this.productCache = new Map();
    this.searchCache = new Map();
    this.safetyStockCache = null;
    this.safetyStockCacheTime = null;
  }
  
  set(type, key, value, ttl = CONFIG.CACHE_TTL) {
    const cache = type === 'product' ? this.productCache : this.searchCache;
    
    if (cache.size >= CONFIG.MAX_CACHE_SIZE) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    cache.set(key, {
      value: value,
      timestamp: Date.now(),
      ttl: ttl
    });
  }
  
  get(type, key) {
    const cache = type === 'product' ? this.productCache : this.searchCache;
    const item = cache.get(key);
    
    if (!item) return null;
    
    if (Date.now() - item.timestamp > item.ttl) {
      cache.delete(key);
      return null;
    }
    
    return item.value;
  }
  
  clear(type) {
    if (type === 'product') {
      this.productCache.clear();
    } else if (type === 'search') {
      this.searchCache.clear();
    } else {
      this.productCache.clear();
      this.searchCache.clear();
    }
  }
}

class LocalCache {
  constructor() {
    this.prefix = 'ohotoro_';
    this.maxAge = 30 * 60 * 1000; // 30분
  }
  
  set(key, data) {
    try {
      const item = {
        data: data,
        timestamp: Date.now()
      };
      localStorage.setItem(this.prefix + key, JSON.stringify(item));
      return true;
    } catch (e) {
      console.warn('로컬 캐시 저장 실패:', e);
      return false;
    }
  }
  
  get(key) {
    try {
      const item = localStorage.getItem(this.prefix + key);
      if (!item) return null;
      
      const parsed = JSON.parse(item);
      const age = Date.now() - parsed.timestamp;
      
      if (age > this.maxAge) {
        localStorage.removeItem(this.prefix + key);
        return null;
      }
      
      return parsed.data;
    } catch (e) {
      console.warn('로컬 캐시 읽기 실패:', e);
      return null;
    }
  }
  
  clear() {
    const keys = Object.keys(localStorage);
    keys.forEach(key => {
      if (key.startsWith(this.prefix)) {
        localStorage.removeItem(key);
      }
    });
  }
}

// ===== 5. SmartRetry 클래스 =====
class SmartRetry {
  constructor() {
    this.maxRetries = 3;
    this.retryDelay = 1000;
    this.backoffMultiplier = 2;
  }
  
  async execute(functionName, args = [], options = {}) {
    const maxRetries = options.maxRetries || this.maxRetries;
    const retryDelay = options.retryDelay || this.retryDelay;
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(resolve)
            .withFailureHandler(reject)
            [functionName](...args);
        });
      } catch (error) {
        lastError = error;
        
        if (attempt < maxRetries) {
          showRetryNotification(functionName, attempt, maxRetries);
          const delay = retryDelay * Math.pow(this.backoffMultiplier, attempt - 1);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    hideRetryNotification();
    throw new Error(`${functionName} 실행 실패 (${maxRetries}회 시도): ${lastError}`);
  }
}

// ===== 6. 전역 인스턴스 =====
const cache = new CacheManager();
const smartRetry = new SmartRetry();

// ===== 7. 초기화 =====
document.addEventListener('DOMContentLoaded', async function() {
  console.log('=== 앱 초기화 시작 ===');
  const startTime = performance.now();

  // URL 파라미터로 강제 새로고침 확인
  const urlParams = new URLSearchParams(window.location.search);
  if (urlParams.get('refresh') === 'shipping') {
    sessionStorage.setItem('forceRefreshShipping', 'true');
    localStorage.removeItem('shippingSession');
  }
  
  showLoading('초기 설정 로드 중...');
  
  try {
    // 1단계: 기본 설정 로드
    const [settings, translations, orderInfo] = await Promise.all([
      loadSettingsDataOnly().catch(() => ({})),
      initializeLanguage().catch(() => ({})),
      checkCurrentOrderAsync().catch(() => null)
    ]);
    
    AppState.settings = settings;
    AppState.translations = translations;
    
    // 음성 설정 로드 추가
    await loadVoiceSettings();
    
    // 이벤트 리스너 설정
    setupEventListeners();
    
    // 발주서 정보 설정
    if (orderInfo) {
      AppState.currentOrderInfo = orderInfo;
      updateOrderStatus();
      enableOrderFeatures();
    }
    
    // 2단계: 상품 데이터 로드
    updateLoadingMessage('상품 데이터 로드 중...');
    
    const dataPromises = [
      loadInitialProductsWithIssuesAsync(),
      loadSmaregiDataAsync(), // 이 함수가 먼저 실행되어야 함
      loadCategoryRulesAsync().catch(() => ({}))
    ];
    
    // 발주서가 있으면 발주 항목도 함께 로드
    if (orderInfo) {
      updateLoadingMessage('발주 항목 로드 중...');
      dataPromises.push(
        loadOrderItemsFromSheetAsync()
          .then(items => {
            console.log('발주 항목 로드 완료:', items ? items.length : 0);
            // 발주 목록이 로드되면 즉시 UI 업데이트
            updateOrderList();
            updateOrderSummary();
            return items;
          })
      );
    }
    
    // 모든 데이터 로드 완료 대기
    const results = await Promise.all(dataPromises);
    
    // 3단계: Smaregi 연결 상태 확인 (데이터 로드 후)
    checkSmaregiConnection();
    
    // 4단계: UI 초기화
    initializeDisplaySettings();
    injectColorChipStyles();
    startAutoSave();
    
    // 세션 복원
    if (AppState.currentOrderInfo && !restoreSession()) {
      // 이미 updateOrderList()가 호출되었으므로 중복 호출 방지
      console.log('세션 복원 스킵');
    }

    // Sticky Header 설정 (여기에 추가)
    setupStickyFooter();
    
    // 5단계: 모든 작업 완료 후 로딩 숨기기
    const loadTime = (performance.now() - startTime) / 1000;
    console.log(`전체 초기화 완료: ${loadTime.toFixed(1)}초`);
    
    hideLoading();
    showQuickSuccess(`초기화 완료 (${loadTime.toFixed(1)}초)`);
    
  } catch (error) {
    console.error('초기화 중 오류:', error);
    hideLoading();
    showError('앱 초기화에 실패했습니다. 페이지를 새로고침해주세요.');
  }
});

// 더 세밀한 버전 (필요시 사용)
function setupStickyFooter() {
  const orderTab = document.getElementById('order-tab');
  const stickyFooter = document.getElementById('order-sticky-footer');
  const orderSection = document.getElementById('order-section');
  const orderActions = document.querySelector('.order-actions');
  
  if (!orderTab || !stickyFooter || !orderSection || !orderActions) return;
  
  let isSticky = false;
  
  function checkStickyState() {
    // 발주 탭이 활성화되어 있지 않으면 숨김
    if (!orderTab.classList.contains('active')) {
      if (isSticky) {
        stickyFooter.classList.remove('show');
        document.body.classList.remove('sticky-footer-active');
        isSticky = false;
      }
      return;
    }
    
    const actionsRect = orderActions.getBoundingClientRect();
    const windowHeight = window.innerHeight;
    const scrollY = window.scrollY;
    
    // 원본 버튼의 하단이 뷰포트 상단을 벗어났고,
    // 발주 목록에 항목이 있을 때만 표시
    const shouldShow = actionsRect.bottom < 0 && AppState.orderItems.length > 0;
    
    if (shouldShow && !isSticky) {
      stickyFooter.classList.add('show');
      document.body.classList.add('sticky-footer-active');
      updateStickyFooterSummary();
      isSticky = true;
    } else if (!shouldShow && isSticky) {
      stickyFooter.classList.remove('show');
      document.body.classList.remove('sticky-footer-active');
      isSticky = false;
    }
  }
  
  // 스크롤 이벤트 (throttle 적용)
  let scrollTimer;
  window.addEventListener('scroll', () => {
    if (scrollTimer) return;
    
    scrollTimer = setTimeout(() => {
      checkStickyState();
      scrollTimer = null;
    }, 50); // 50ms throttle
  });
  
  // 탭 전환 시 체크
  document.querySelectorAll('.nav-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      setTimeout(checkStickyState, 100);
    });
  });
  
  // 발주 목록 업데이트 시에도 체크
  const originalUpdateOrderList = window.updateOrderList;
  window.updateOrderList = function() {
    originalUpdateOrderList.apply(this, arguments);
    setTimeout(checkStickyState, 100);
  };
  
  // 초기 상태 체크
  setTimeout(checkStickyState, 100);
}

// Sticky header 요약 정보 업데이트
function updateStickyFooterSummary() {
  const totalItems = document.getElementById('total-items').textContent;
  const totalQuantity = document.getElementById('total-quantity').textContent;
  const totalAmount = document.getElementById('total-amount').textContent;
  
  document.getElementById('sticky-total-items').textContent = totalItems;
  document.getElementById('sticky-total-quantity').textContent = totalQuantity;
  document.getElementById('sticky-total-amount').textContent = totalAmount;
}

function applyBundleData(bundle) {
  // 상품 데이터
  if (bundle.productsData) {
    AppState.products = bundle.productsData.products || [];
    AppState.productIssues = bundle.productsData.productIssues || {};
  }
  
  // 설정
  if (bundle.settings) {
    AppState.settings = bundle.settings;
  }
  
  // 현재 발주서
  if (bundle.currentOrder) {
    AppState.currentOrderInfo = bundle.currentOrder;
    updateOrderStatus();
    enableOrderFeatures();
  }
  
  // Smaregi 데이터
  if (bundle.smaregiData) {
    AppState.smaregiData = bundle.smaregiData.data || {};
    AppState.smaregiUploadTime = bundle.smaregiData.uploadTime;
    AppState.smaregiDataLoaded = Object.keys(AppState.smaregiData).length > 0;
  }
  
  // 카테고리 규칙
  if (bundle.categoryRules) {
    AppState.categoryRules = bundle.categoryRules;
  }
  
  // UI 초기화
  setupEventListeners();
  initializeDisplaySettings();
  injectColorChipStyles();
  startAutoSave();
  
  // 발주서가 있으면 발주 항목 로드
  if (AppState.currentOrderInfo) {
    loadOrderItemsFromSheetAsync();
  }
}

// 백그라운드 업데이트 확인
function checkForUpdates() {
  // 5초 후에 백그라운드에서 최신 데이터 확인
  setTimeout(() => {
    google.script.run
      .withSuccessHandler((newBundle) => {
        if (newBundle && isDataUpdated(newBundle)) {
          // 데이터가 변경되었으면 업데이트
          const localCache = new LocalCache();
          localCache.set('initial_bundle', newBundle);
          console.log('백그라운드 데이터 업데이트 완료');
        }
      })
      .getInitialDataBundle();
  }, 5000);
}

// 초기 데이터 로드 함수 (새로 추가)
async function loadInitialData(orderInfo) {
  const dataPromises = [
    loadInitialProductsWithIssuesAsync(),
    loadSmaregiDataAsync(),
    loadCategoryRulesAsync().catch(() => ({})),
    loadVoiceSettings()
  ];
  
  if (orderInfo) {
    dataPromises.push(loadOrderItemsFromSheetAsync());
  }
  
  const results = await Promise.all(dataPromises);
  
  // 발주 항목 처리
  if (orderInfo && results[3]) {
    console.log('발주 항목 로드 완료:', results[3].length);
  }
  
  return results;
}

// UI 초기화 함수 (새로 추가)
function initializeUI() {
  initializeDisplaySettings();
  injectColorChipStyles();
  setupKeyboardShortcuts();
  startAutoSave();
  
  // 세션 복원
  if (AppState.currentOrderInfo && !restoreSession()) {
    updateOrderList();
  }
}


// loadSmaregiDataAsync 함수 추가 (이 함수를 위 코드 아래에 추가)
async function loadSmaregiDataAsync() {
  return new Promise((resolve) => {
    google.script.run
      .withSuccessHandler((result) => {
        if (result && result.data) {
          AppState.smaregiData = result.data;
          AppState.smaregiUploadTime = result.uploadTime;
          AppState.smaregiDataLoaded = true;
          console.log(`Smaregi 데이터 로드: ${Object.keys(result.data).length}개`);
          if (result.uploadTime) {
            console.log(`업로드 시간: ${result.uploadTime}`);
          }
        } else {
          AppState.smaregiData = {};
          AppState.smaregiDataLoaded = false;
          console.log('Smaregi 데이터 없음');
        }
        resolve(AppState.smaregiData);
      })
      .withFailureHandler((error) => {
        console.warn('Smaregi 데이터 로드 실패:', error);
        AppState.smaregiData = {};
        AppState.smaregiDataLoaded = false;
        resolve({});
      })
      .getSmaregiData();
  });
}

// loadInitialProductsWithIssuesAsync 함수 수정 (타임아웃 추가)
async function loadInitialProductsWithIssuesAsync() {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      console.error('loadInitialProductsWithIssues 타임아웃 (30초)');
      resolve({ products: [], productIssues: {} });
    }, 30000); // 30초 타임아웃
    
    google.script.run
      .withSuccessHandler((result) => {
        clearTimeout(timeout);
        if (result.products) {
          AppState.products = result.products;
          AppState.productIssues = result.productIssues || {};
          
          // 로컬 캐시 복원
          restoreLocalCache();
        }
        console.log('초기 데이터 로드 완료');
        resolve(result);
      })
      .withFailureHandler((error) => {
        clearTimeout(timeout);
        console.error('통합 데이터 로드 실패:', error);
        resolve({ products: [], productIssues: {} });
      })
      .loadInitialProductsWithIssues();
  });
}

// 로딩 메시지 업데이트 함수
function updateLoadingMessage(message) {
  const loadingEl = document.getElementById('loading');
  if (loadingEl) {
    const messageEl = loadingEl.querySelector('.loading-message');
    if (messageEl) {
      messageEl.textContent = message;
    }
  }
}

// ===== 8. 비동기 함수들 =====
async function checkCurrentOrderAsync() {
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler(resolve)
      .withFailureHandler((error) => {
        console.error('getCurrentOrder 실패:', error);
        resolve(null); // reject 대신 null 반환
      })
      .getCurrentOrder();
  });
}

// scripts.html의 loadOrderItemsFromSheetAsync 함수 수정
async function loadOrderItemsFromSheetAsync() {
  if (!AppState.currentOrderInfo?.orderId) return [];
  
  return new Promise((resolve) => {
    google.script.run
      .withSuccessHandler((result) => {
        if (result?.success && result.items) {
          AppState.orderItems = result.items.map(item => ({
            ...item,
            searchText: `${item.barcode} ${item.name} ${item.option || ''}`.toLowerCase(),
            id: item.id || (Date.now() + Math.random())
          }));
          
          updateOrderList();
          updateOrderSummary();
          resolve(AppState.orderItems);
        } else {
          AppState.orderItems = [];
          updateOrderList();
          resolve([]);
        }
      })
      .withFailureHandler(() => {
        AppState.orderItems = [];
        updateOrderList();
        resolve([]);
      })
      .loadOrderItems(AppState.currentOrderInfo.orderId);
  });
}

async function loadInitialProductsAsync() {
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler((data) => {
        console.log('초기 상품 로드 성공:', data ? data.length : 0);
        AppState.products = data || [];
        
        // 이슈 정보는 별도로 로드 (에러가 있어도 계속 진행)
        google.script.run
          .withSuccessHandler((issues) => {
            AppState.productIssues = issues || {};
            AppState.products.forEach(product => {
              if (AppState.productIssues[product.barcode]) {
                product.issueMemo = AppState.productIssues[product.barcode].memo;
                product.issueRemarks = AppState.productIssues[product.barcode].remarks;
              }
            });
          })
          .withFailureHandler((error) => {
            console.warn('이슈 정보 로드 실패:', error);
          })
          .loadProductIssuesData();
        
        restoreLocalCache();
        resolve(data || []);
      })
      .withFailureHandler((error) => {
        console.error('loadInitialProducts 실패:', error);
        resolve([]); // reject 대신 빈 배열 반환
      })
      .loadInitialProducts();
  });
}

async function loadCategoryRulesAsync() {
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler((rules) => {
        AppState.categoryRules = rules || {};
        resolve(rules || {});
      })
      .withFailureHandler((error) => {
        console.warn('카테고리 규칙 로드 실패:', error);
        resolve({}); // reject 대신 빈 객체 반환
      })
      .loadCategoryRules();
  });
}

// ===== 9. 이벤트 리스너 설정 =====
function setupEventListeners() {
  // === 이벤트 위임 (matches 제거) ===
  document.body.addEventListener('click', handleGlobalClick);
  document.body.addEventListener('change', handleGlobalChange);
  document.body.addEventListener('keydown', handleGlobalKeydown);
  
  // === 검색 관련 ===
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  
  if (searchBtn) {
    searchBtn.addEventListener('click', performSearch);
  }
  
  if (searchInput) {
    // autofocus 대신 placeholder로 안내
    searchInput.placeholder = '클릭하여 검색 시작...';
    
    // 사용자가 클릭했을 때만 포커스
    searchInput.addEventListener('click', function() {
      this.placeholder = '상품명 또는 바코드로 검색...';
    });
    
    const debouncedSearch = debounce(performSearch, 1000);
    
    searchInput.addEventListener('input', function(e) {
      const query = e.target.value.trim();
      if (query.length >= 2) {
        debouncedSearch();
      }
    });
    
    searchInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        performSearch();
      }
    });
  }
  
  // === 태그 필터 ===
  document.querySelectorAll('.tag-filter').forEach(filter => {
    filter.addEventListener('click', function() {
      document.querySelectorAll('.tag-filter').forEach(f => f.classList.remove('active'));
      this.classList.add('active');
      AppState.currentFilter = this.dataset.tag;
      filterSearchResults();
    });
  });
  
  // === 발주 액션 버튼들 ===
  const saveBtn = document.getElementById('save-draft-btn');
  if (saveBtn) saveBtn.addEventListener('click', saveDraft);
  
  const confirmSelectedBtn = document.getElementById('confirm-selected-btn');
  if (confirmSelectedBtn) confirmSelectedBtn.addEventListener('click', confirmSelectedItems);
  
  const confirmAllBtn = document.getElementById('confirm-all-btn');
  if (confirmAllBtn) confirmAllBtn.addEventListener('click', confirmAllItems);
  
  const clearBtn = document.getElementById('clear-btn');
  if (clearBtn) clearBtn.addEventListener('click', clearOrders);
  
  // === 발주서 관리 버튼들 ===
  const createOrderBtn = document.getElementById('create-order-btn');
  if (createOrderBtn) {
    createOrderBtn.addEventListener('click', showCreateOrderModal);
  }
  
  const openOrderBtn = document.getElementById('open-order-btn');
  if (openOrderBtn) {
    openOrderBtn.addEventListener('click', showOpenOrderModal);
  }
  
  const mergeItemsBtn = document.getElementById('merge-items-btn');
  if (mergeItemsBtn) {
    mergeItemsBtn.addEventListener('click', mergeDuplicateItems);
  }
  
  // === 발주서 생성 모달 내부 버튼 ===
  const createOrderConfirmBtn = document.getElementById('create-order-confirm');
  if (createOrderConfirmBtn) {
    createOrderConfirmBtn.addEventListener('click', createOrder);
  }
  
  // === 설정 저장 ===
  const saveSettingsBtn = document.getElementById('save-settings');
  if (saveSettingsBtn) {
    saveSettingsBtn.addEventListener('click', saveSettings);
  }
  
  // === 모달 닫기 버튼들 ===
  document.querySelectorAll('.modal-close').forEach(btn => {
    btn.addEventListener('click', function() {
      const modal = this.closest('.modal');
      if (modal && modal.id) {
        closeModal(modal.id);
      }
    });
  });
  
  // === 재고 상태 모달 라디오 버튼 ===
  document.querySelectorAll('input[name="stockStatus"]').forEach(radio => {
    radio.addEventListener('change', function() {
      const customInput = document.getElementById('custom-status');
      if (this.value === 'custom') {
        customInput.disabled = false;
        customInput.focus();
      } else {
        customInput.disabled = true;
        customInput.value = '';
      }
    });
  });
  
  // === 페이지 언로드 ===
  window.addEventListener('beforeunload', handleBeforeUnload);
  
  // === 코멘트 툴팁 설정 ===
  setupCommentTooltips();
  
  // === 동적 이벤트 위임 설정 ===
  setupDynamicEventDelegation();
}

let currentCommentTooltip = null;
let commentTooltipTimeout = null;

// 툴팁 표시 함수
function showCommentTooltip(button) {
  // 기존 툴팁 제거
  hideCommentTooltip();
  
  const orderItem = button.closest('.order-item');
  if (!orderItem || !orderItem.dataset.id) return;
  
  const itemId = orderItem.dataset.id;
  const item = AppState.orderItems.find(i => String(i.id) === String(itemId));
  
  if (!item || !item.comment) return;
  
  // 툴팁 생성
  const tooltip = document.createElement('div');
  tooltip.className = 'comment-tooltip';
  tooltip.id = 'active-comment-tooltip';
  tooltip.textContent = item.comment;
  
  // body에 추가
  document.body.appendChild(tooltip);
  
  // 위치 계산
  const rect = button.getBoundingClientRect();
  const tooltipRect = tooltip.getBoundingClientRect();
  
  // 기본 위치 (버튼 위)
  let top = rect.top - tooltipRect.height - 10;
  let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);
  
  // 화면 상단 벗어남 체크
  if (top < 10) {
    // 버튼 아래로 표시
    top = rect.bottom + 10;
    tooltip.classList.add('bottom');
    
    // 화살표 방향 변경을 위한 스타일 추가
    const style = document.createElement('style');
    style.textContent = `
      #active-comment-tooltip.bottom::before {
        top: -5px;
        bottom: auto;
        border-top: none;
        border-bottom: 5px solid #333;
      }
    `;
    tooltip.appendChild(style);
  }
  
  // 좌우 화면 벗어남 체크
  if (left < 10) {
    left = 10;
  } else if (left + tooltipRect.width > window.innerWidth - 10) {
    left = window.innerWidth - tooltipRect.width - 10;
  }
  
  tooltip.style.position = 'fixed';
  tooltip.style.top = top + 'px';
  tooltip.style.left = left + 'px';
  
  currentCommentTooltip = tooltip;
  
  // 페이드인 효과
  requestAnimationFrame(() => {
    tooltip.classList.add('visible');
  });
}

// 툴팁 숨기기 함수
function hideCommentTooltip() {
  if (currentCommentTooltip) {
    currentCommentTooltip.classList.remove('visible');
    setTimeout(() => {
      if (currentCommentTooltip) {
        currentCommentTooltip.remove();
        currentCommentTooltip = null;
      }
    }, 200);
  }
  
  // 기존 방식도 지원 (호환성)
  const existingTooltip = document.getElementById('active-comment-tooltip');
  if (existingTooltip && existingTooltip !== currentCommentTooltip) {
    existingTooltip.remove();
  }
}

// 코멘트 툴팁 이벤트 설정
function setupCommentTooltips() {
  // 이벤트 위임 사용
  document.addEventListener('mouseenter', function(e) {
    // e.target이 Element인지 확인
    if (!e.target || typeof e.target.closest !== 'function') return;
    
    const commentBtn = e.target.closest('.order-action-btn.comment.has-comment');
    if (!commentBtn) return;
    
    // 타이머 초기화
    if (commentTooltipTimeout) {
      clearTimeout(commentTooltipTimeout);
    }
    
    // 약간의 지연 후 툴팁 표시
    commentTooltipTimeout = setTimeout(() => {
      showCommentTooltip(commentBtn);
    }, 300);
  }, true);
  
  document.addEventListener('mouseleave', function(e) {
    // e.target이 Element인지 확인
    if (!e.target || typeof e.target.closest !== 'function') return;
    
    const commentBtn = e.target.closest('.order-action-btn.comment.has-comment');
    if (!commentBtn) return;
    
    // 타이머 취소
    if (commentTooltipTimeout) {
      clearTimeout(commentTooltipTimeout);
      commentTooltipTimeout = null;
    }
    
    // 툴팁 숨기기
    hideCommentTooltip();
  }, true);
  
  // 스크롤 시 툴팁 숨기기
  document.addEventListener('scroll', function() {
    hideCommentTooltip();
  }, true);
  
  // 클릭 시 툴팁 숨기기
  document.addEventListener('click', function() {
    hideCommentTooltip();
  }, true);
}

// DOM 로드 후 실행
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', setupCommentTooltips);
} else {
  setupCommentTooltips();
}

// setupEventListeners() 함수 내에서 호출
setupCommentTooltips();

// 동적으로 생성되는 요소들의 이벤트 처리
function setupDynamicEventDelegation() {
  // 모달이 동적으로 생성될 때 이벤트 처리
  const observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
      mutation.addedNodes.forEach(function(node) {
        if (node.nodeType === 1) { // Element node
          // 모달 닫기 버튼
          if (node.classList && node.classList.contains('modal')) {
            const closeBtn = node.querySelector('.modal-close');
            if (closeBtn && !closeBtn.hasAttribute('data-listener')) {
              closeBtn.setAttribute('data-listener', 'true');
              closeBtn.addEventListener('click', function() {
                closeModal(node.id);
              });
            }
          }
        }
      });
    });
  });
  
  observer.observe(document.body, {
    childList: true,
    subtree: true
  });
}

// ===== 재고 상태 병합 헬퍼 함수 =====
function getMergedStockStatus(items) {
  // 재고 상태 우선순위 (낮을수록 우선)
  const stockPriority = {
    '품절': 1,
    '오더중': 2,
    // "X개만 가능" 형태는 3으로 처리
    '가능': 4,
    '미확인': 5
  };
  
  let mostRestrictive = null;
  let lowestPriority = 999;
  let minAvailableQty = Infinity;
  
  items.forEach(item => {
    const status = item.stockAvailable || '미확인';
    
    // "X개만 가능" 형태 처리
    const partialMatch = status.match(/(\d+)개만 가능/);
    if (partialMatch) {
      const availableQty = parseInt(partialMatch[1]);
      if (availableQty < minAvailableQty) {
        minAvailableQty = availableQty;
        mostRestrictive = status;
        lowestPriority = 3;
      }
    } else {
      // 일반 상태 처리
      const priority = stockPriority[status] || 999;
      if (priority < lowestPriority) {
        lowestPriority = priority;
        mostRestrictive = status;
      }
    }
  });
  
  return mostRestrictive || '미확인';
}

function mergeDuplicateItems() {
  if (!AppState.currentOrderInfo) {
    showError('먼저 발주서를 생성해주세요.');
    return;
  }
  
  if (AppState.orderItems.length === 0) {
    showError('병합할 항목이 없습니다.');
    return;
  }
  
  const groupedItems = {};
  let mergedCount = 0;
  let conflictCount = 0;
  let exportedSkipCount = 0;
  
  // 바코드별로 그룹화
  AppState.orderItems.forEach(item => {
    if (!groupedItems[item.barcode]) {
      groupedItems[item.barcode] = {
        exported: [],
        confirmed: [],
        unconfirmed: []
      };
    }
    
    if (item.exportedAt || item.exportStatus) {
      groupedItems[item.barcode].exported.push(item);
    } else if (item.status === '확정') {
      groupedItems[item.barcode].confirmed.push(item);
    } else {
      groupedItems[item.barcode].unconfirmed.push(item);
    }
  });
  
  // 병합 실행
  const newOrderItems = [];
  const mergeReport = [];
  
  Object.keys(groupedItems).forEach(barcode => {
    const group = groupedItems[barcode];
    
    // 내보내기된 항목은 그대로 유지
    group.exported.forEach(item => {
      newOrderItems.push(item);
      if (group.confirmed.length > 1) {
        exportedSkipCount++; // 병합 가능했지만 내보내기 때문에 스킵
      }
    });
    
    // 내보내기되지 않은 확정 항목들 병합
    if (group.confirmed.length > 1) {
      const mergedConfirmed = {
        ...group.confirmed[0],
        quantity: group.confirmed.reduce((sum, item) => sum + item.quantity, 0),
        comment: group.confirmed
          .map(item => item.comment)
          .filter(c => c)
          .join(' / '),
        priority: Math.min(...group.confirmed.map(item => item.priority || 3)),
        stockAvailable: getMergedStockStatus(group.confirmed)
      };
      
      // 재고 상태가 다른 경우 경고
      const uniqueStockStatuses = new Set(group.confirmed.map(item => item.stockAvailable));
      if (uniqueStockStatuses.size > 1) {
        conflictCount++;
        mergeReport.push({
          name: group.confirmed[0].name,
          statuses: Array.from(uniqueStockStatuses),
          merged: mergedConfirmed.stockAvailable
        });
      }
      
      newOrderItems.push(mergedConfirmed);
      mergedCount += group.confirmed.length - 1;
    } else if (group.confirmed.length === 1) {
      // 확정 항목이 1개만 있으면 그대로 추가
      newOrderItems.push(group.confirmed[0]);
    }
    
    // 미확정 항목들은 병합하지 않고 그대로 추가
    group.unconfirmed.forEach(item => {
      newOrderItems.push(item);
    });
  });
  
  if (mergedCount > 0) {
    AppState.orderItems = newOrderItems;
    updateOrderList();
    scheduleAutoSave();
    
    let message = `✅ ${mergedCount}개의 중복 항목이 병합되었습니다.`;
    
    if (exportedSkipCount > 0) {
      message += `\n📤 ${exportedSkipCount}개는 이미 내보내기되어 제외되었습니다.`;
    }
    
    if (conflictCount > 0) {
      message += `\n⚠️ ${conflictCount}개 항목의 재고 상태가 달라 가장 제한적인 상태로 설정되었습니다.`;
    }
    
    // showInfo 대신 모달로 표시
    const modalContent = `
      <div style="padding: 20px;">
        <h3>병합 완료</h3>
        <p style="white-space: pre-line;">${message}</p>
        <div style="margin-top: 20px; text-align: right;">
          <button class="btn btn-primary" onclick="closeModal()">확인</button>
        </div>
      </div>
    `;
    showModal(modalContent);
    
  } else if (exportedSkipCount > 0) {
    showError('병합 가능한 항목이 있지만 모두 내보내기되어 병합할 수 없습니다.');
  } else {
    showError('병합할 중복 항목이 없습니다.');
  }
}

// ===== 10. 이벤트 핸들러 =====
function handleGlobalClick(e) {
  const target = e.target;
  
  // 탭 전환
  if (target.classList && target.classList.contains('nav-btn')) {
    e.preventDefault();
    switchTab(target.dataset.tab);
    return;
  }
  
  // 모달 닫기
  if (target.classList && target.classList.contains('modal-close')) {
    e.preventDefault();
    const modal = target.closest('.modal');
    if (modal) closeModal(modal.id);
    return;
  }
  
  // Quick 메뉴 외부 클릭
  const isQuickMenu = target.closest('.quick-stock-menu');
  const isStockBtn = target.classList && target.classList.contains('stock-status-btn');
  
  if (!isQuickMenu && !isStockBtn) {
    document.querySelectorAll('.quick-stock-menu.show').forEach(menu => {
      menu.classList.remove('show');
    });
  }
}

function handleGlobalChange(e) {
  const target = e.target;
  
  if (target.classList && target.classList.contains('quantity-input')) {
    const orderItem = target.closest('.order-item');
    if (orderItem && orderItem.dataset.id) {
      updateQuantity(orderItem.dataset.id, target.value);
    }
  }
  
  if (target.classList && target.classList.contains('order-checkbox')) {
    updateBulkEditButton();
  }
}

function handleGlobalKeydown(e) {
  const target = e.target;
  
  if (e.key === 'Escape') {
    closeAllModals();
    return;
  }
  
  if (e.altKey && e.key.toLowerCase() === 's') {
    e.preventDefault();
    if (AppState.currentOrderInfo && AppState.orderItems.length > 0) {
      saveDraft();
    }
  }
  
  if (e.altKey && e.key.toLowerCase() === 'f') {
    e.preventDefault();
    const searchInput = document.getElementById('search-input');
    if (searchInput) searchInput.focus();
  }
  
  if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
    e.preventDefault();
    openProductIssueModal();
  }
}

// ===== 11. 탭 전환 =====
function switchTab(tabName) {
  document.querySelectorAll('.nav-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.dataset.tab === tabName) {
      btn.classList.add('active');
    }
  });
  
  document.querySelectorAll('.tab-content').forEach(content => {
    content.classList.remove('active');
  });
  document.getElementById(`${tabName}-tab`).classList.add('active');
  
  if (tabName === 'dashboard') {
    loadDashboard();
  } else if (tabName === 'frequent') {
    loadFrequentItems();
  } else if (tabName === 'settings') {
    loadSettingsTab(); // 수정
  } else if (tabName === 'safety-stock') {
    loadSafetyStockTab();
  }
}

// 설정 탭 로드 함수 추가
function loadSettingsTab() {
  if (AppState.settings && Object.keys(AppState.settings).length > 0) {
    displaySettings(AppState.settings);
  } else {
    google.script.run
      .withSuccessHandler((settings) => {
        AppState.settings = settings;
        displaySettings(settings);
      })
      .withFailureHandler(() => {
        displaySettings({});
      })
      .getSettings();
  }
  
  setTimeout(initializeDisplaySettings, 100);
}

// ===== 12. 발주서 관리 =====
function updateOrderStatus() {
  const statusContainer = document.getElementById('current-order-info');
  
  if (AppState.currentOrderInfo) {
    statusContainer.innerHTML = `
      <div class="order-details">
        <span class="order-badge">작업중</span>
        <span class="order-name">${AppState.currentOrderInfo.fileName}</span>
        <span class="order-recipient">(${AppState.currentOrderInfo.recipientName})</span>
        <a href="${AppState.currentOrderInfo.orderUrl}" target="_blank" class="btn btn-sm">📝 open</a>
      </div>
    `;
  } else {
    statusContainer.innerHTML = '<span class="no-order-message">발주서를 생성하거나 선택해주세요.</span>';
  }
}

function enableOrderFeatures() {
  // search-section과 order-section은 존재하므로 안전하게 처리
  const searchSection = document.getElementById('search-section');
  const orderSection = document.getElementById('order-section');
  
  if (searchSection) searchSection.classList.remove('disabled');
  if (orderSection) orderSection.classList.remove('disabled');
  
  // 각 요소가 존재하는지 확인 후 처리
  const searchInput = document.getElementById('search-input');
  if (searchInput) searchInput.disabled = false;
  
  const searchBtn = document.getElementById('search-btn');
  if (searchBtn) searchBtn.disabled = false;
  
  // 이 버튼들은 HTML에 없을 수 있으므로 존재 여부 확인
  const saveDraftBtn = document.getElementById('save-draft-btn');
  if (saveDraftBtn) saveDraftBtn.disabled = false;
  
  const confirmSelectedBtn = document.getElementById('confirm-selected-btn');
  if (confirmSelectedBtn) confirmSelectedBtn.disabled = false;
  
  const confirmAllBtn = document.getElementById('confirm-all-btn');
  if (confirmAllBtn) confirmAllBtn.disabled = false;
  
  const clearBtn = document.getElementById('clear-btn');
  if (clearBtn) clearBtn.disabled = false;
  
  const exportCsvBtn = document.getElementById('export-csv-btn');
  if (exportCsvBtn) exportCsvBtn.disabled = false;
  
  // updateExportButtonStatus 함수도 존재하는지 확인
  if (typeof updateExportButtonStatus === 'function') {
    updateExportButtonStatus();
  }
}

// ===== 13. 발주서 생성/열기 =====

function createOrder() {
  const recipientSelect = document.getElementById('recipient-select');
  const newRecipientInput = document.getElementById('new-recipient-input');
  const recipientName = newRecipientInput.value.trim() || recipientSelect.value;
  
  if (!recipientName) {
    showError('발주처를 선택하거나 입력해주세요.');
    return;
  }
  
  // 로딩 표시 시작
  showLoading('발주서를 생성하는 중입니다...');
  
  // 미출고 항목 먼저 확인
  google.script.run
    .withSuccessHandler(function(undeliveredItems) {
      // 로딩 메시지 업데이트
      updateLoadingMessage('미출고 항목을 확인하는 중...');
      
      if (undeliveredItems && undeliveredItems.length > 0) {
        hideLoading();
        
        if (confirm(`이전 발주에서 미출고된 항목이 ${undeliveredItems.length}개 있습니다.\n발주목록에 추가하시겠습니까?`)) {
          createOrderWithUndelivered(recipientName, undeliveredItems);
        } else {
          createOrderNormal(recipientName);
        }
      } else {
        createOrderNormal(recipientName);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      console.warn('미출고 항목 확인 실패:', error);
      // 실패해도 발주서는 생성
      createOrderNormal(recipientName);
    })
    .getUndeliveredItems();
}

function createNewOrderWithBase() {
  showCreateOrderModal(); // 기존 모달 활용
}

// 미출고 항목 포함하여 발주서 생성
function createOrderWithUndelivered(recipientName, undeliveredItems) {
  showLoading(`발주서 생성 중... (미출고 ${undeliveredItems.length}개 항목 포함)`);
  
  google.script.run
    .withSuccessHandler(function(result) {
      if (result.success) {
        AppState.currentOrderInfo = result.orderInfo;
        AppState.orderItems = [];
        clearSession();
        
        updateOrderStatus();
        enableOrderFeatures();
        
        // 로딩 메시지 업데이트
        updateLoadingMessage('미출고 항목을 추가하는 중...');
        
        // 미출고 항목을 발주 목록에 추가
        let addedCount = 0;
        const totalItems = undeliveredItems.length;
        
        undeliveredItems.forEach((item, index) => {
          google.script.run
            .withSuccessHandler(function(productDetails) {
              if (productDetails) {
                const orderItem = {
                  ...productDetails,
                  quantity: item.undeliveredQty,
                  priority: 1, // 높은 우선순위
                  comment: `미출고 (${item.lastDate})`,
                  status: '대기',
                  id: Date.now() + index,
                  stockAvailable: '미확인'
                };
                
                AppState.orderItems.push(orderItem);
                addedCount++;
                
                // 진행률 업데이트
                updateLoadingMessage(`미출고 항목 추가 중... (${addedCount}/${totalItems})`);
                
                if (addedCount === totalItems) {
                  hideLoading();
                  updateOrderList();
                  scheduleAutoSave();
                  showQuickSuccess(`발주서가 생성되고 ${addedCount}개의 미출고 항목이 추가되었습니다.`);
                }
              }
            })
            .withFailureHandler(function(error) {
              console.error('상품 정보 조회 실패:', error);
              addedCount++;
              
              if (addedCount === totalItems) {
                hideLoading();
                updateOrderList();
              }
            })
            .getProductDetails(item.code);
        });
        
        closeModal('create-order-modal');
      } else {
        hideLoading();
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('발주서 생성 실패: ' + error);
    })
    .createNewOrder(recipientName);
}

function createOrderNormal(recipientName) {
  showLoading('새 발주서를 생성하는 중...');
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      
      if (result.success) {
        AppState.currentOrderInfo = result.orderInfo;
        AppState.orderItems = [];
        clearSession();
        
        updateOrderStatus();
        enableOrderFeatures();
        updateOrderList();
        closeModal('create-order-modal');
        showQuickSuccess(result.message);
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('발주서 생성 실패: ' + error);
    })
    .createNewOrder(recipientName);
}

function addUndeliveredItemsToOrder(items) {
  let processed = 0;
  
  items.forEach((item, index) => {
    // 약간의 지연을 두고 순차적으로 추가
    setTimeout(() => {
      google.script.run
        .withSuccessHandler((productDetails) => {
          if (productDetails) {
            const orderItem = {
              ...productDetails,
              quantity: item.quantity,
              priority: item.priority,
              comment: item.comment,
              status: '대기',
              id: Date.now() + index,
              stockAvailable: '미확인'
            };
            
            AppState.orderItems.push(orderItem);
            processed++;
            
            if (processed === items.length) {
              updateOrderList();
              scheduleAutoSave();
              showQuickSuccess(`${items.length}개의 미출고 항목이 발주목록에 추가되었습니다.`);
            }
          }
        })
        .withFailureHandler((error) => {
          console.error('상품 정보 조회 실패:', error);
          processed++;
        })
        .getProductDetails(item.barcode);
    }, index * 100); // 100ms 간격으로 호출
  });
}

function showCreateOrderModal() {
  const modal = document.getElementById('create-order-modal');
  const recipientSelect = document.getElementById('recipient-select');
  
  showSaveIndicator('loading');
  google.script.run
    .withSuccessHandler(function(recipients) {
      showSaveIndicator('hide');
      recipientSelect.innerHTML = '<option value="">발주처를 선택하세요</option>';
      recipients.forEach(recipient => {
        const option = document.createElement('option');
        option.value = recipient;
        option.textContent = recipient;
        recipientSelect.appendChild(option);
      });
      modal.style.display = 'block';
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('발주처 목록 로드 실패');
    })
    .getOrderRecipientsList();
}

function showOpenOrderModal() {
  const modal = document.getElementById('open-order-modal');
  const listContainer = document.getElementById('recent-orders-list');
  
  listContainer.innerHTML = `
    <div class="loading-container">
      <div class="loading-spinner"></div>
      <p>최근 30일간의 발주서를 불러오는 중...</p>
    </div>
  `;
  modal.style.display = 'block';
  
  google.script.run
    .withSuccessHandler(function(orders) {
      if (!orders || orders.length === 0) {
        listContainer.innerHTML = `
          <div class="empty-state">
            <div class="empty-icon">📋</div>
            <h3>최근 발주서가 없습니다</h3>
          </div>
        `;
        return;
      }
      
      const ordersByDate = {};
      orders.forEach(order => {
        const date = new Date(order.createdAt);
        const dateKey = date.toLocaleDateString('ko-KR');
        if (!ordersByDate[dateKey]) {
          ordersByDate[dateKey] = [];
        }
        ordersByDate[dateKey].push(order);
      });
      
      let html = `<div class="order-list-header"><h4>최근 30일간 발주서 (총 ${orders.length}개)</h4></div>`;
      
      Object.keys(ordersByDate)
        .sort((a, b) => new Date(b) - new Date(a))
        .forEach(dateKey => {
          html += `
            <div class="order-date-group">
              <div class="date-header">${dateKey}</div>
              ${ordersByDate[dateKey].map(order => `
                <div class="recent-order-item" onclick="openExistingOrder('${order.id || ''}')">
                  <div class="recent-order-header">
                    <div class="recent-order-supplier">${order.supplier || '알 수 없음'}</div>
                    <div class="recent-order-time">${new Date(order.createdAt).toLocaleTimeString('ko-KR')}</div>
                  </div>
                  <div class="recent-order-name">${order.name || '제목 없음'}</div>
                </div>
              `).join('')}
            </div>
          `;
        });
      
      listContainer.innerHTML = html;
    })
    .withFailureHandler(function(error) {
      listContainer.innerHTML = `
        <div class="error-state">
          <div class="error-icon">❌</div>
          <h3>발주서 목록 로드 실패</h3>
        </div>
      `;
    })
    .getRecentOrders();
}

function openExistingOrder(orderId) {
  if (!orderId) {
    showError('발주서 ID가 올바르지 않습니다.');
    return;
  }
  
  showSaveIndicator('loading');
  AppState.orderItems = [];
  clearSession();
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result?.success) {
        AppState.currentOrderInfo = result.orderInfo;
        AppState.orderItems = result.items || [];
        
        updateOrderStatus();
        enableOrderFeatures();
        updateOrderList();
        closeModal('open-order-modal');
        showQuickSuccess(`발주서를 불러왔습니다. (${AppState.orderItems.length}개 항목)`);
      } else {
        showError(result?.message || '발주서를 열 수 없습니다.');
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('발주서 열기 실패: ' + error);
    })
    .openOrder(orderId);
}

// ===== 14. 검색 기능 =====
function performSearch() {
  const query = document.getElementById('search-input').value.trim();
  
  if (!query || query.length < 2) {
    if (query.length === 1) {
      showError('검색어를 2글자 이상 입력해주세요.');
    }
    return;
  }
  
  const container = document.getElementById('search-results');
  
  // 검색어를 단어 단위로 분리
  const searchTerms = query.toLowerCase().split(/\s+/);
  
  // 로컬 검색 로직 개선
  const localResults = AppState.products.filter(product => {
    const searchableText = [
      product.barcode || '',
      product.name || '',
      product.option || '',
      product.supplierName || '',
      product.searchText || ''
    ].join(' ').toLowerCase();
    
    // 모든 검색어가 포함되어 있는지 확인
    return searchTerms.every(term => searchableText.includes(term));
  });
  
  // 검색 결과 정렬 (정확도 순)
  const sortedResults = sortSearchResults(localResults, query);
  
  // 로컬 결과가 충분하면 서버 검색 버튼만 표시
  if (sortedResults.length >= 20) {
    displaySearchResults(sortedResults);
    return;
  }
  
  // 결과 표시
  displaySearchResults(sortedResults);
  
  // 로컬 결과가 적으면 서버 검색 버튼 추가
  if (sortedResults.length < 10) {
    const existingBtn = container.querySelector('.search-more-container');
    if (!existingBtn) {
      const searchMoreBtn = document.createElement('div');
      searchMoreBtn.className = 'search-more-container';
      searchMoreBtn.innerHTML = `
        <button class="btn btn-secondary" onclick="searchAllProducts('${query}')">
          전체 상품에서 검색 (${sortedResults.length}개 외 추가 검색)
        </button>
      `;
      container.appendChild(searchMoreBtn);
    }
  }
}

function searchAllProducts(query) {
  AppState.isSearching = true;
  const container = document.getElementById('search-results');
  
  const searchMoreContainer = container.querySelector('.search-more-container');
  if (searchMoreContainer) {
    searchMoreContainer.innerHTML = `
      <div class="search-loading">
        <div class="loading-spinner-small"></div>
        <p>전체 상품에서 검색 중...</p>
      </div>
    `;
  }
  
  google.script.run
    .withSuccessHandler(function(results) {
      AppState.isSearching = false;
      
      if (results.length > 0) {
        const existingBarcodes = new Set(AppState.products.map(p => p.barcode));
        const newProducts = [];
        
        results.forEach(r => {
          if (!existingBarcodes.has(r.barcode)) {
            AppState.products.push(r);
            newProducts.push(r);
          }
        });
        
        // 검색어를 단어 단위로 분리
        const searchTerms = query.toLowerCase().trim().split(/\s+/);
        
        // 모든 상품에서 검색 (기존 + 새로 추가된 상품)
        const allResults = AppState.products.filter(p => {
          const searchableText = [
            p.barcode || '',
            p.name || '',
            p.option || '',
            p.supplierName || '',
            p.searchText || ''
          ].join(' ').toLowerCase();
          
          // 모든 검색어가 포함되어 있는지 확인
          return searchTerms.every(term => searchableText.includes(term));
        });
        
        // 검색 결과 정렬 (전체 일치 우선)
        const sortedResults = sortSearchResults(allResults, query);
        
        displaySearchResults(sortedResults);
        
        if (newProducts.length > 0) {
          showQuickSuccess(`${newProducts.length}개의 추가 결과를 찾았습니다.`);
        }
      } else {
        // 검색 결과가 없을 때 더 자세한 정보 제공
        container.innerHTML = `
          <div class="empty-state">
            <p>추가 검색 결과가 없습니다.</p>
            <div style="margin-top: 10px; font-size: 14px; color: #666;">
              <p>검색 팁:</p>
              <ul style="text-align: left; display: inline-block;">
                <li>띄어쓰기를 확인해주세요</li>
                <li>일부 단어만 입력해보세요 (예: "nap" 또는 "jogger")</li>
                <li>정확한 상품명으로 검색해보세요</li>
              </ul>
            </div>
          </div>
        `;
      }
    })
    .withFailureHandler(function(error) {
      AppState.isSearching = false;
      container.innerHTML = '<div class="empty-state">검색 중 오류가 발생했습니다.</div>';
      showError('전체 검색 실패: ' + error);
    })
    .searchAllProducts(query);
}

// 검색 결과 정렬 함수 - 정확도 순으로 정렬
function sortSearchResults(results, query) {
  const queryLower = query.toLowerCase().trim();
  
  return results.sort((a, b) => {
    const nameA = (a.name || '').toLowerCase();
    const nameB = (b.name || '').toLowerCase();
    
    // 1. 상품명이 정확히 일치하는 경우 최우선
    if (nameA === queryLower && nameB !== queryLower) return -1;
    if (nameB === queryLower && nameA !== queryLower) return 1;
    
    // 2. 상품명이 검색어로 시작하는 경우
    const startsWithA = nameA.startsWith(queryLower);
    const startsWithB = nameB.startsWith(queryLower);
    if (startsWithA && !startsWithB) return -1;
    if (startsWithB && !startsWithA) return 1;
    
    // 3. 상품명에 검색어가 포함된 경우 (위치가 앞일수록 우선)
    const indexA = nameA.indexOf(queryLower);
    const indexB = nameB.indexOf(queryLower);
    if (indexA !== -1 && indexB !== -1 && indexA !== indexB) {
      return indexA - indexB;
    }
    
    // 4. 자주 발주 상품 우선
    if (a.isFrequent && !b.isFrequent) return -1;
    if (b.isFrequent && !a.isFrequent) return 1;
    
    // 5. 최근 상품 우선
    if (a.isRecent && !b.isRecent) return -1;
    if (b.isRecent && !a.isRecent) return 1;
    
    // 6. 상품명 알파벳 순
    return nameA.localeCompare(nameB);
  });
}

function displaySearchResults(results) {
  const container = document.getElementById('search-results');
  const displaySettings = loadDisplaySettings();
  const query = document.getElementById('search-input').value.trim().toLowerCase();
  
  if (results.length === 0) {
    container.innerHTML = '<div class="empty-state">검색 결과가 없습니다.</div>';
    return;
  }
  
  // AppState에서 Smaregi 데이터 가져오기 (서버 호출 제거)
  const smaregiData = AppState.smaregiData || {};
  
  let html = `
    <div class="search-results-header">
      <span>${results.length}개의 검색 결과</span>
      <button class="close-search-results" onclick="closeSearchResults()">✕</button>
    </div>
  `;
  
  html += results.map(product => {
    let badges = '';
    if (product.isFrequent === true) badges += '<span class="product-badge badge-frequent">자주발주</span>';
    if (product.isRecent === true) badges += '<span class="product-badge badge-recent">최근</span>';
    
    const category = getCategory(product.name);
    const categoryBadge = category ? `<span class="product-badge badge-category">${category}</span>` : '';
    
    const colorSizeInfo = parseColorSize(product.option);
    let issueIcon = '';
    const issueData = AppState.productIssues[product.barcode];
    
    if (issueData) {
      const memo = issueData.memo || '';
      let iconType = 'ℹ️';
      if (memo.includes('품절')) iconType = '🚫';
      else if (memo.includes('오더중')) iconType = '⚠️';
      
      issueIcon = `
        <span class="issue-icon" title="${memo}">
          ${iconType}
          <span class="issue-tooltip">${memo}</span>
        </span>
      `;
    }
    
    const storeStock = smaregiData[product.barcode] || 0;
    const hasSmaregiData = product.barcode in smaregiData;
    
    let stockDisplay = '';
    if (Object.keys(smaregiData).length > 0) {
      if (hasSmaregiData) {
        stockDisplay = `<span class="inline-stock-badge">🏪 매장: ${storeStock}개</span>`;
      } else {
        stockDisplay = `<span class="inline-stock-badge no-data">🏪 매장: 재고 없음</span>`;
      }
    }
    
    // 이미 발주 목록에 있는지 확인
    const existingItems = AppState.orderItems.filter(item => item.barcode === product.barcode);
    const confirmedItem = existingItems.find(item => item.status === '확정');
    const unconfirmedItem = existingItems.find(item => item.status !== '확정');
    
    let buttonHtml = '';
    let totalQuantity = 0;

    if (confirmedItem && unconfirmedItem) {
      // 확정과 미확정 둘 다 있는 경우
      totalQuantity = confirmedItem.quantity + unconfirmedItem.quantity;
      buttonHtml = `
        <div class="search-item-button-group">
          <button class="add-to-order-btn already-added has-both" onclick="addToOrderWithData('${product.barcode}', this)">
            <span class="btn-main-text">추가 (${totalQuantity})</span>
            <span class="btn-sub-text">확정 ${confirmedItem.quantity} + 대기 ${unconfirmedItem.quantity}</span>
          </button>
        </div>
      `;
    } else if (confirmedItem) {
      // 확정만 있는 경우
      buttonHtml = `
        <div class="search-item-button-group">
          <button class="add-to-order-btn confirmed-only" onclick="addDuplicateConfirmed('${product.barcode}', this)">
            <span class="btn-main-text">재추가</span>
            <span class="btn-sub-text">확정 ${confirmedItem.quantity}개</span>
          </button>
        </div>
      `;
    } else if (unconfirmedItem) {
      // 미확정만 있는 경우
      totalQuantity = unconfirmedItem.quantity;
      buttonHtml = `
        <button class="add-to-order-btn already-added" onclick="addToOrderWithData('${product.barcode}', this)">
          추가 (${totalQuantity})
        </button>
      `;
    } else {
      // 발주 목록에 없는 경우
      buttonHtml = `
        <button class="add-to-order-btn" onclick="addToOrderWithData('${product.barcode}', this)">
          추가
        </button>
      `;
    }
    
    let colorSizeHtml = '';
    if (product.option && colorSizeInfo.color) {
      colorSizeHtml = `
        <div class="search-product-options">
          ${displaySettings.colorChipEnabled !== false && colorSizeInfo.colorHex ? 
            `<span class="color-chip-container">
              <span class="color-chip" style="background-color: ${colorSizeInfo.colorHex}"></span>
              <span class="color-name">${colorSizeInfo.color}</span>
            </span>` : 
            `<span class="color-text">${colorSizeInfo.color}</span>`
          }
          ${colorSizeInfo.size ? `<span class="size-text">${colorSizeInfo.size}</span>` : ''}
        </div>
      `;
    }
    
    const productDataJson = JSON.stringify({
      barcode: product.barcode,
      name: product.name,
      option: product.option || '',
      supplierName: product.supplierName || '',
      purchasePrice: product.purchasePrice || 0,
      weight: product.weight || '',
      memo: product.memo || '',
      remarks: product.remarks || '',
      storeStock: storeStock
    }).replace(/"/g, '&quot;');
    
    return `
      <div class="search-item ${displaySettings.compactMode ? 'compact' : ''}" 
           data-category="${category}"
           data-product="${productDataJson}">
        <div class="search-product-info">
          <div class="search-product-main">
            <span class="search-product-name">${product.name}</span>
            ${stockDisplay}
            ${categoryBadge}
            ${badges}
            ${issueIcon}
          </div>
          ${colorSizeHtml}
        </div>
        
        <div class="search-product-price">
          ${product.purchasePrice > 0 ? '₩' + formatNumber(product.purchasePrice) : '-'}
        </div>
        
        ${buttonHtml}
      </div>
    `;
  }).join('');
  
  container.innerHTML = html;
  filterSearchResults();
}

// 검색 결과 재고 정보 로드
function loadSearchResultsStock(results) {
  console.log('재고 정보 로드 시작, Smaregi 연결:', AppState.smaregiConnected);
  
  // Smaregi 데이터가 로드되었는지 확인
  if (!AppState.smaregiDataLoaded || !AppState.smaregiData) {
    console.log('Smaregi 데이터 없음');
    // 재고 배지를 기본 상태로 변경
    document.querySelectorAll('.stock-badge.loading').forEach(badge => {
      badge.classList.remove('loading');
      badge.classList.add('no-data');
      badge.querySelector('.stock-text').textContent = '재고 없음';
    });
    return;
  }
  
  // 로컬 데이터에서 재고 정보 업데이트
  results.forEach(product => {
    const stockQuantity = AppState.smaregiData[product.barcode] || 0;
    updateStockBadge(product.barcode, {
      stock: stockQuantity,
      availableStock: stockQuantity
    });
  });
  
  // 판매 정보 핸들러는 그대로 유지
  initializeSalesInfoHandlers();
}


// 개별 재고 배지 업데이트
function updateStockBadge(barcode, stockInfo) {
  const badge = document.querySelector(`.stock-badge[data-barcode="${barcode}"]`);
  if (!badge) return;
  
  badge.classList.remove('loading');
  
  const stock = stockInfo.availableStock || stockInfo.stock || 0;
  const stockText = badge.querySelector('.stock-text');
  
  if (stock === 0) {
    badge.classList.add('out-of-stock');
    stockText.textContent = '품절';
  } else if (stock < 10) {
    badge.classList.add('low-stock');
    stockText.textContent = `${stock}개`;
  } else {
    badge.classList.add('in-stock');
    stockText.textContent = `${stock}개`;
  }
  
  // 마지막 업데이트 시간 툴팁
  if (stockInfo.lastUpdate) {
    const updateTime = new Date(stockInfo.lastUpdate);
    const timeStr = updateTime.toLocaleString('ko-KR', {
      month: 'numeric',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    badge.title = `마지막 업데이트: ${timeStr}`;
  }
}

// 판매 정보 핸들러 초기화
function initializeSalesInfoHandlers() {
  document.querySelectorAll('.sales-icon').forEach(icon => {
    icon.style.display = 'inline-flex';
    
    // 마우스 오버 시 판매 정보 로드
    icon.addEventListener('mouseenter', function() {
      if (!this.dataset.loaded) {
        loadSalesInfo(this.dataset.barcode, this);
      }
    });
  });
}

// 개별 판매 정보 로드
function loadSalesInfo(barcode, iconElement) {
  iconElement.title = '판매 정보 로딩중...';
  
  google.script.run
    .withSuccessHandler(function(response) {
      if (response.success && response.salesInfo) {
        const info = response.salesInfo;
        const settings = AppState.settings || {};
        
        iconElement.dataset.loaded = 'true';
        iconElement.title = `최근 ${info.shortPeriod}일: ${info.lastShortDays}개\n최근 ${info.longPeriod}일: ${info.lastLongDays}개\n일평균: ${info.dailyAverage}개`;
        
        // 설정된 임계값 가져오기
        const hotThreshold = parseInt(settings.salesThresholdHot) || 20;
        const popularThreshold = parseInt(settings.salesThresholdPopular) || 10;
        const normalThreshold = parseInt(settings.salesThresholdNormal) || 5;
        
        // 판매량에 따른 아이콘 색상 (단기 기간 기준)
        if (info.lastShortDays >= hotThreshold) {
          iconElement.style.color = '#f44336'; // 빨강 (핫)
          iconElement.textContent = '🔥';
        } else if (info.lastShortDays >= popularThreshold) {
          iconElement.style.color = '#ff9800'; // 주황 (인기)
          iconElement.textContent = '⭐';
        } else if (info.lastShortDays >= normalThreshold) {
          iconElement.style.color = '#4caf50'; // 초록 (보통)
          iconElement.textContent = '✓';
        } else {
          iconElement.style.color = '#9e9e9e'; // 회색 (저조)
          iconElement.textContent = '📊';
        }
      } else {
        iconElement.title = '판매 정보 없음';
        iconElement.style.color = '#9e9e9e';
      }
    })
    .withFailureHandler(function(error) {
      iconElement.title = '판매 정보 로드 실패';
      iconElement.style.color = '#9e9e9e';
    })
    .getProductSalesData(barcode);
}

// 개별 재고 배지 업데이트
function updateStockBadge(barcode, stockInfo) {
  const badge = document.querySelector(`.stock-badge[data-barcode="${barcode}"]`);
  if (!badge) return;
  
  badge.classList.remove('loading');
  
  const stock = stockInfo.availableStock || stockInfo.stock || 0;
  const stockText = badge.querySelector('.stock-text');
  
  if (stock === 0) {
    badge.classList.add('out-of-stock');
    stockText.textContent = '품절';
  } else if (stock < 10) {
    badge.classList.add('low-stock');
    stockText.textContent = `${stock}개`;
  } else {
    badge.classList.add('in-stock');
    stockText.textContent = `${stock}개`;
  }
  
  // 마지막 업데이트 시간 툴팁
  if (stockInfo.lastUpdate) {
    const updateTime = new Date(stockInfo.lastUpdate);
    const timeStr = updateTime.toLocaleString('ko-KR', {
      month: 'numeric',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    badge.title = `마지막 업데이트: ${timeStr}`;
  }
}

// 판매 정보 핸들러 초기화
function initializeSalesInfoHandlers() {
  document.querySelectorAll('.sales-icon').forEach(icon => {
    icon.style.display = 'inline-flex';
    
    // 마우스 오버 시 판매 정보 로드
    icon.addEventListener('mouseenter', function() {
      if (!this.dataset.loaded) {
        loadSalesInfo(this.dataset.barcode, this);
      }
    });
  });
}

// 개별 판매 정보 로드
function loadSalesInfo(barcode, iconElement) {
  iconElement.title = '판매 정보 로딩중...';
  
  google.script.run
    .withSuccessHandler(function(response) {
      if (response.success && response.salesInfo) {
        const info = response.salesInfo;
        iconElement.dataset.loaded = 'true';
        iconElement.title = `최근 7일: ${info.last7Days}개\n최근 30일: ${info.last30Days}개\n일평균: ${info.dailyAverage}개`;
        
        // 판매량에 따른 아이콘 색상
        if (info.last7Days > 20) {
          iconElement.style.color = '#f44336'; // 빨강 (핫)
        } else if (info.last7Days > 10) {
          iconElement.style.color = '#ff9800'; // 주황 (인기)
        } else if (info.last7Days > 5) {
          iconElement.style.color = '#4caf50'; // 초록 (보통)
        } else {
          iconElement.style.color = '#9e9e9e'; // 회색 (저조)
        }
      } else {
        iconElement.title = '판매 정보 없음';
        iconElement.style.color = '#9e9e9e';
      }
    })
    .withFailureHandler(function(error) {
      iconElement.title = '판매 정보 로드 실패';
      iconElement.style.color = '#9e9e9e';
    })
    .getProductSalesData(barcode);
}

// 확정된 항목 재추가 함수 (displaySearchResults 함수 바로 다음에 추가)
function addDuplicateConfirmed(barcode, button) {
  console.log('addDuplicateConfirmed 호출됨:', barcode); // 디버깅용
  
  if (confirm('이미 확정된 항목입니다.\n추가로 발주하시겠습니까?')) {
    // 새로운 미확정 항목으로 추가
    addToOrderWithData(barcode, button);
  }
}

// 발주 목록의 특정 아이템으로 스크롤 및 하이라이트
function focusOrderItem(barcode) {
  const orderItems = document.querySelectorAll('.order-item');
  
  orderItems.forEach(item => {
    const itemBarcode = item.querySelector('.item-barcode')?.textContent;
    if (itemBarcode === barcode) {
      // 스크롤
      item.scrollIntoView({ behavior: 'smooth', block: 'center' });
      
      // 하이라이트 효과
      item.classList.add('highlight');
      setTimeout(() => {
        item.classList.remove('highlight');
      }, 2000);
    }
  });
}

function closeSearchResults() {
  document.getElementById('search-results').innerHTML = '';
}

// ===== 15. 발주 목록 관리 =====
function addToOrderWithData(barcode, button) {
  console.log('addToOrderWithData 호출됨:', barcode); // 디버깅용
  
  if (!AppState.currentOrderInfo) {
    showError('먼저 발주서를 생성해주세요.');
    return;
  }
  
  const searchItem = button.closest('.search-item');
  if (!searchItem) {
    console.error('search-item을 찾을 수 없습니다');
    addToOrder(barcode);
    return;
  }
  
  const productData = searchItem.dataset.product;
  if (!productData) {
    console.error('product 데이터가 없습니다');
    addToOrder(barcode);
    return;
  }
  
  try {
    const product = JSON.parse(productData);
    console.log('파싱된 product:', product); // 디버깅용
    proceedAddToOrder(product, button);
  } catch (error) {
    console.error('JSON 파싱 에러:', error);
    addToOrder(barcode);
  }
}

function addToOrder(barcode) {
  if (!AppState.currentOrderInfo) {
    showError('먼저 발주서를 생성해주세요.');
    return;
  }
  
  let product = AppState.products.find(p => p.barcode === barcode);
  
  if (!product) {
    product = cache.get('product', barcode);
  }
  
  if (!product) {
    const addBtn = event.target;
    const originalText = addBtn.textContent;
    addBtn.textContent = '조회중...';
    addBtn.disabled = true;
    
    google.script.run
      .withSuccessHandler(function(details) {
        if (details) {
          product = {
            ...details,
            searchText: `${details.barcode} ${details.name} ${details.option}`.toLowerCase()
          };
          
          cache.set('product', barcode, product);
          AppState.products.push(product);
          proceedAddToOrder(product, addBtn);
        }
      })
      .withFailureHandler(function(error) {
        addBtn.textContent = originalText;
        addBtn.disabled = false;
        showError('상품 조회 실패');
      })
      .getProductDetails(barcode);
    
    return;
  }
  
  proceedAddToOrder(product, event.target);
}

function proceedAddToOrder(product, addBtn) {
  // 애니메이션 시작
  addBtn.classList.add('adding');
  addBtn.textContent = '추가중...';
  addBtn.disabled = true;
  addBtn.style.cursor = 'wait';
  
  const existingUnconfirmed = AppState.orderItems.find(item => 
    item.barcode === product.barcode && item.status !== '확정'
  );
  
  if (existingUnconfirmed) {
    existingUnconfirmed.quantity += 1;
    updateOrderList();
    
    const totalQuantity = AppState.orderItems
      .filter(item => item.barcode === product.barcode)
      .reduce((sum, item) => sum + item.quantity, 0);
    
    // 성공 애니메이션
    addBtn.classList.remove('adding');
    addBtn.classList.add('added-success', 'ripple');
    addBtn.textContent = '추가됨';
    
    setTimeout(() => {
      addBtn.classList.remove('added-success', 'ripple');
      addBtn.classList.add('already-added');
      addBtn.textContent = `추가 (${totalQuantity})`;
      addBtn.disabled = false;
      addBtn.style.cursor = 'pointer';
    }, 1000);
    
    showQuickSuccess('수량이 증가되었습니다.');
    scheduleAutoSave();
    return;
  }
  
  const newItem = {
    ...product,
    quantity: 1,
    priority: 3,
    comment: '',
    status: '대기',
    id: Date.now() + Math.random(),
    confirmedAt: null,
    stockAvailable: '미확인'
  };
  
  AppState.orderItems.push(newItem);
  updateOrderList();
  
  // 최근 사용 업데이트
  google.script.run.updateSharedRecentProducts(product);
  
  // 로컬 캐시 저장
  try {
    let localCache = localStorage.getItem('recentAddedProducts');
    localCache = localCache ? JSON.parse(localCache) : [];
    localCache = localCache.filter(p => p.barcode !== product.barcode);
    localCache.unshift({ ...product, isFromCache: true, cachedAt: new Date().toISOString() });
    localCache = localCache.slice(0, 100);
    localStorage.setItem('recentAddedProducts', JSON.stringify(localCache));
  } catch (e) {
    console.warn('로컬 캐시 저장 실패:', e);
  }
  
  // 성공 애니메이션
  addBtn.classList.remove('adding');
  addBtn.classList.add('added-success', 'ripple');
  addBtn.textContent = '추가됨';
  
  setTimeout(() => {
    addBtn.classList.remove('added-success', 'ripple');
    addBtn.classList.add('already-added');
    addBtn.textContent = '추가 (1)';
    addBtn.disabled = false;
    addBtn.style.cursor = 'pointer';
  }, 1000);
  
  showQuickSuccess('상품이 추가되었습니다.');
  scheduleAutoSave();
}

function updateOrderList() {
  const container = document.getElementById('order-list');
  const displaySettings = loadDisplaySettings();
  
  if (!AppState.currentOrderInfo) {
    container.innerHTML = '<div class="empty-state"><p>발주서를 먼저 생성해주세요.</p></div>';
    updateOrderSummary();
    return;
  }
  
  if (AppState.orderItems.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>발주할 상품을 검색하여 추가해주세요.</p></div>';
    updateOrderSummary();
    return;
  }
  
  const smaregiData = AppState.smaregiData || {};
  const hasSmaregiData = Object.keys(smaregiData).length > 0;
  
  // 바코드별로 그룹화하여 중복 표시
  const barcodeGroups = {};
  AppState.orderItems.forEach(item => {
    if (!barcodeGroups[item.barcode]) {
      barcodeGroups[item.barcode] = [];
    }
    barcodeGroups[item.barcode].push(item);
  });
  
  container.innerHTML = AppState.orderItems.map(item => {
    const isConfirmed = item.status === '확정';
    const isExported = !!(item.exportedAt || (item.exportStatus && item.exportStatus.includes('내보내기 완료')));
    if (isExported) {
      console.log(`내보내기된 항목: ${item.barcode}, exportedAt: ${item.exportedAt}, exportStatus: ${item.exportStatus}`);
    }
    const amount = item.quantity * (item.purchasePrice || 0);
    const priorityDisplay = getPriorityDisplay(item.priority || 3);
    
    const stockStatus = getStockStatusDisplay(item.stockAvailable || '미확인');
    const storeStock = smaregiData[item.barcode] || 0;
    const hasSmaregiDataForItem = item.barcode in smaregiData;
    
    let storeStockBadge = '';
    if (hasSmaregiData) {
      if (hasSmaregiDataForItem) {
        let stockClass = 'store-stock-normal';
        if (storeStock === 0) stockClass = 'store-stock-empty';
        else if (storeStock < 10) stockClass = 'store-stock-low';
        
        storeStockBadge = `
          <span class="store-stock-badge ${stockClass}">
            <span class="store-icon">🏪</span>
            <span class="store-count">${storeStock}개</span>
          </span>
        `;
      } else {
        storeStockBadge = `
          <span class="store-stock-badge store-stock-no-data">
            <span class="store-icon">🏪</span>
            <span class="store-count">-</span>
          </span>
        `;
      }
    }
    
    // ★★★ 박스 정보 처리 - 형식 개선 ★★★
    let boxInfoHtml = '';
    if (item.boxNumbers) {
      // "1(5), 2(3)" 형식을 "1번(5개), 2번(3개)"로 변환
      const formattedBoxInfo = item.boxNumbers.replace(/(\d+)\((\d+)\)/g, '$1번($2개)');
      boxInfoHtml = `
        <span class="box-info">
          <span class="box-icon">📦</span>
          <span class="box-numbers">${formattedBoxInfo}</span>
        </span>
      `;
    }
    
    const colorSizeInfo = parseColorSize(item.option);
    let colorSizeHtml = '';
    if (item.option && colorSizeInfo.color) {
      colorSizeHtml = `
        <div class="order-product-options">
          ${displaySettings.colorChipEnabled !== false && colorSizeInfo.colorHex ? 
            `<span class="color-chip-container">
              <span class="color-chip" style="background-color: ${colorSizeInfo.colorHex}"></span>
              <span class="color-name">${colorSizeInfo.color}</span>
            </span>` : 
            `<span class="color-text">${colorSizeInfo.color}</span>`
          }
          ${colorSizeInfo.size ? `<span class="size-text">${colorSizeInfo.size}</span>` : ''}
          ${boxInfoHtml}
        </div>
      `;
    } else if (boxInfoHtml) {
      // 옵션이 없는 경우에도 박스 정보가 있으면 표시
      colorSizeHtml = `
        <div class="order-product-options">
          ${boxInfoHtml}
        </div>
      `;
    }
    
    // 같은 바코드의 다른 항목 확인
    const sameProducts = barcodeGroups[item.barcode];
    const isDuplicate = sameProducts.length > 1;
    const duplicateInfo = isDuplicate ? 
      `<span class="duplicate-badge" title="동일 상품 ${sameProducts.length}개">×${sameProducts.length}</span>` : 
      '';
    
    return `
      <div class="order-item ${isConfirmed ? 'confirmed' : ''} ${isExported ? 'exported' : ''} ${isDuplicate ? 'has-duplicate' : ''} ${displaySettings.compactMode ? 'compact' : ''}" data-id="${item.id}">
        <div class="order-checkbox-wrapper">
          <input type="checkbox" class="order-checkbox" onchange="updateBulkEditButton()">
        </div>
        
        <div class="order-product-info">
          <div class="order-product-main">
            <span class="order-product-name">${item.name}</span>
            ${duplicateInfo}
            ${storeStockBadge}
            ${isConfirmed ? '<span class="confirmed-badge">확정</span>' : ''}
            ${isExported ? `<span class="exported-badge" title="내보내기: ${item.exportedAt || '완료'}">내보내기 완료</span>` : ''}
          </div>
          ${colorSizeHtml}
        </div>
        
        <div class="order-quantity-wrapper">
          <input type="number" 
                 class="quantity-input" 
                 value="${item.quantity}" 
                 min="1" 
                 onchange="updateQuantity('${item.id}', this.value)"
                 ${isConfirmed ? 'disabled' : ''}>
          <span class="quantity-unit">개</span>
          ${isExported && item.exportedQuantity && item.exportedQuantity !== item.quantity ? 
            `<span class="exported-quantity">(내보냄: ${item.exportedQuantity}개)</span>` : 
            ''
          }
        </div>
        
        <div class="order-amount">₩${formatNumber(amount)}</div>

        <div class="stock-status-wrapper">
          <button class="stock-status-btn ${stockStatus.class}" 
                  onclick="showQuickStockMenu(event, '${item.id}')"
                  data-csv-status="${item.stockStatus || ''}">
            <span>${stockStatus.icon}</span>
            <span>${stockStatus.text}</span>
            ${item.stockStatus ? '<span class="csv-indicator">📊</span>' : ''}
          </button>
          <div class="quick-stock-menu" id="quick-menu-${item.id}">
            <div class="quick-stock-option" onclick="setQuickStock('${item.id}', '가능')">
              <span>✅</span> 가능
            </div>
            <div class="quick-stock-option" onclick="setQuickStock('${item.id}', '품절')">
              <span>❌</span> 품절
            </div>
            <div class="quick-stock-option" onclick="setQuickStock('${item.id}', '오더중')">
              <span>⏳</span> 오더중
            </div>
            <div class="quick-stock-option custom" onclick="showStockStatusModal('${item.id}')">
              <span>✏️</span> 직접 입력...
            </div>
          </div>
        </div>
        
        <div class="order-actions">
          <button class="order-action-btn priority ${priorityDisplay.class}" 
                  onclick="window.showPriorityPicker('${item.id}')"
                  data-item-id="${item.id}"
                  ${isConfirmed ? 'disabled' : ''}
                  title="우선순위: ${priorityDisplay.text}">
            <span class="priority-badge">${priorityDisplay.icon}</span>
            <span class="priority-text">${priorityDisplay.text}</span>
          </button>
          <button class="order-action-btn comment ${item.comment ? 'has-comment' : ''}" 
                  onclick="window.showCommentInput('${item.id}')"
                  title="${item.comment ? '코멘트 수정' : '코멘트 추가'}">
            💬
            ${item.comment ? '<span class="comment-indicator"></span>' : ''}
          </button>
          ${!isConfirmed ? 
            `<button class="order-action-btn delete" onclick="window.removeItem('${item.id}')" title="삭제">삭제</button>` :
            ''
          }
        </div>
      </div>
    `;
  }).join('');
  
  updateOrderSummary();
  updateBulkEditButton();
  updateExportButtonStatus();
}

// 3. sortOrderItems 함수 수정
function sortOrderItems(sortBy) {
  if (!AppState.orderItems || AppState.orderItems.length === 0) return;
  
  // 같은 필드로 다시 정렬하면 순서 반대로
  if (currentSortField === sortBy) {
    currentSortOrder = currentSortOrder === 'asc' ? 'desc' : 'asc';
  } else {
    currentSortField = sortBy;
    currentSortOrder = 'asc';
  }
  
  // 정렬 실행
  AppState.orderItems.sort((a, b) => {
    let compareValue = 0;
    
    switch (sortBy) {
      case 'status':
        // 확정 > 대기 순
        const statusOrder = { '확정': 0, '대기': 1 };
        compareValue = (statusOrder[a.status] || 2) - (statusOrder[b.status] || 2);
        break;
        
      case 'priority':
        // 우선순위 높음(1) > 보통(2) > 낮음(3)
        compareValue = (a.priority || 3) - (b.priority || 3);
        break;
        
      case 'name':
        // 상품명 가나다순
        compareValue = (a.name || '').localeCompare(b.name || '');
        break;
        
      case 'quantity':
        // 수량 많은 순
        compareValue = (b.quantity || 0) - (a.quantity || 0);
        break;
        
      case 'amount':
        // 금액 높은 순
        const amountA = (a.quantity || 0) * (a.purchasePrice || 0);
        const amountB = (b.quantity || 0) * (b.purchasePrice || 0);
        compareValue = amountB - amountA;
        break;
        
      case 'stock':
        // 재고 상태 순 (품절 > 오더중 > X개만 가능 > 가능 > 미확인)
        const stockOrder = {
          '품절': 0,
          '오더중': 1,
          '미확인': 4
        };
        
        const getStockOrder = (stock) => {
          if (stock in stockOrder) return stockOrder[stock];
          if (stock && stock.includes('개만 가능')) return 2;
          if (stock === '가능') return 3;
          return 5;
        };
        
        compareValue = getStockOrder(a.stockAvailable) - getStockOrder(b.stockAvailable);
        break;
        
      case 'exported':
        // 내보내기 상태 (내보내기 완료 > 미내보내기)
        const exportedA = a.exportedAt ? 0 : 1;
        const exportedB = b.exportedAt ? 0 : 1;
        compareValue = exportedA - exportedB;
        break;
        
      default:
        // 기본: 추가된 순서 (ID 순)
        compareValue = (a.id || 0) - (b.id || 0);
    }
    
    // 오름차순/내림차순 적용
    return currentSortOrder === 'asc' ? compareValue : -compareValue;
  });
  
  // UI 업데이트
  updateOrderList();
  
  // 모달 닫기
  const modal = document.getElementById('modal');
  if (modal) modal.style.display = 'none';
  
  showQuickSuccess(`${getSortLabel(sortBy)}으로 정렬되었습니다.`);
}

// 4. 정렬 라벨 헬퍼 함수 추가
function getSortLabel(sortBy) {
  const labels = {
    'status': '상태순',
    'priority': '우선순위',
    'name': '상품명',
    'quantity': '수량순',
    'amount': '금액순',
    'stock': '재고상태',
    'exported': '내보내기상태',
    'default': '기본순서'
  };
  return labels[sortBy] || sortBy;
}

// 5. showSortMenu 함수 개선
function showSortMenu() {
  const modalContent = `
    <h3>발주 목록 정렬</h3>
    <div class="sort-options">
      <button class="sort-option ${currentSortField === 'status' ? 'active' : ''}" 
              onclick="sortOrderItems('status')">
        <span class="sort-icon">📋</span>
        <div>
          <div class="sort-title">상태순</div>
          <div class="sort-desc">확정된 항목을 상단에 표시</div>
        </div>
      </button>
      
      <button class="sort-option ${currentSortField === 'priority' ? 'active' : ''}" 
              onclick="sortOrderItems('priority')">
        <span class="sort-icon">⭐</span>
        <div>
          <div class="sort-title">우선순위</div>
          <div class="sort-desc">긴급한 항목부터 표시</div>
        </div>
      </button>
      
      <button class="sort-option ${currentSortField === 'stock' ? 'active' : ''}" 
              onclick="sortOrderItems('stock')">
        <span class="sort-icon">📦</span>
        <div>
          <div class="sort-title">재고 상태</div>
          <div class="sort-desc">품절/오더중 항목 우선</div>
        </div>
      </button>
      
      <button class="sort-option ${currentSortField === 'amount' ? 'active' : ''}" 
              onclick="sortOrderItems('amount')">
        <span class="sort-icon">💰</span>
        <div>
          <div class="sort-title">금액순</div>
          <div class="sort-desc">금액이 큰 순서대로</div>
        </div>
      </button>
      
      <button class="sort-option ${currentSortField === 'name' ? 'active' : ''}" 
              onclick="sortOrderItems('name')">
        <span class="sort-icon">🔤</span>
        <div>
          <div class="sort-title">상품명</div>
          <div class="sort-desc">가나다순 정렬</div>
        </div>
      </button>
      
      <button class="sort-option ${currentSortField === 'exported' ? 'active' : ''}" 
              onclick="sortOrderItems('exported')">
        <span class="sort-icon">📤</span>
        <div>
          <div class="sort-title">내보내기 상태</div>
          <div class="sort-desc">내보낸 항목 구분</div>
        </div>
      </button>
    </div>
  `;
  
  showModal(modalContent);
}

function updateQuantity(id, value) {
  const item = AppState.orderItems.find(i => i.id == id);
  if (item) {
    item.quantity = Math.max(1, parseInt(value) || 1);
    updateOrderSummary();
    scheduleAutoSave();
  }
}

function removeItem(id) {
  if (confirm('정말 삭제하시겠습니까?')) {
    AppState.orderItems = AppState.orderItems.filter(i => i.id != id);
    updateOrderList();
    scheduleAutoSave();
  }
}

function updateOrderSummary() {
  const totalItems = AppState.orderItems.length;
  const totalQuantity = AppState.orderItems.reduce((sum, item) => sum + item.quantity, 0);
  const totalAmount = AppState.orderItems.reduce((sum, item) => sum + (item.quantity * item.purchasePrice), 0);
  const pendingItems = AppState.orderItems.filter(item => item.status !== '확정').length;
  
  document.getElementById('total-items').textContent = totalItems;
  document.getElementById('total-quantity').textContent = totalQuantity;
  document.getElementById('total-amount').textContent = '₩' + formatNumber(totalAmount);
  document.getElementById('pending-items').textContent = pendingItems;
}

// ===== 16. 재고 상태 관리 =====
function showQuickStockMenu(event, itemId) {
  event.stopPropagation();
  
  const item = AppState.orderItems.find(i => i.id == itemId);
  if (!item) return;
  
  // 내보내기된 항목은 재고 상태 변경 불가
  if (item.exportedAt || item.exportStatus) {
    showError('내보내기된 항목은 재고 상태를 변경할 수 없습니다.');
    return;
  }
  
  // 기존 코드 계속...
  document.querySelectorAll('.quick-stock-menu').forEach(menu => {
    if (menu.id !== `quick-menu-${itemId}`) {
      menu.classList.remove('show');
    }
  });
  
  const menu = document.getElementById(`quick-menu-${itemId}`);
  menu.classList.toggle('show');
  
  if (menu.classList.contains('show')) {
    setTimeout(() => {
      document.addEventListener('click', function closeMenu(e) {
        if (!menu.contains(e.target) && !e.target.closest('.stock-status-btn')) {
          menu.classList.remove('show');
          document.removeEventListener('click', closeMenu);
        }
      });
    }, 10);
  }
}

function setQuickStock(itemId, status) {
  const item = AppState.orderItems.find(i => i.id == itemId);
  if (!item) return;
  
  item.stockAvailable = status;
  
  // Quick 메뉴 닫기
  document.querySelectorAll('.quick-stock-menu').forEach(menu => {
    menu.classList.remove('show');
  });
  
  // 해당 아이템만 UI 업데이트
  updateOrderItem(itemId);
  
  // 자동 저장
  if (AppState.currentOrderInfo) {
    scheduleAutoSave();
  }
  
  showQuickSuccess('재고 상태가 변경되었습니다.');
}

function showStockStatusModal(itemId) {
  const item = AppState.orderItems.find(i => i.id == itemId);
  if (!item) return;
  
  // Quick 메뉴 먼저 닫기
  document.querySelectorAll('.quick-stock-menu').forEach(menu => {
    menu.classList.remove('show');
  });
  
  AppState.currentStockEditItem = item;
  
  document.getElementById('stock-modal-product-info').innerHTML = `
    <strong>${item.name}</strong><br>
    <span class="text-muted">${item.barcode} | 요청수량: ${item.quantity}개</span><br>
    <span class="stock-current-status">현재 상태: ${item.stockAvailable || '미확인'}</span>
  `;
  
  resetStockStatusModal();
  
  if (item.stockAvailable === '가능') {
    document.querySelector('input[value="available"]').checked = true;
  } else if (item.stockAvailable === '품절') {
    document.querySelector('input[value="soldout"]').checked = true;
  } else if (item.stockAvailable === '오더중') {
    document.querySelector('input[value="ordering"]').checked = true;
  } else if (item.stockAvailable && item.stockAvailable !== '미확인') {
    document.querySelector('input[value="custom"]').checked = true;
    document.getElementById('custom-status').value = item.stockAvailable;
    document.getElementById('custom-status').disabled = false;
  }
  
  document.getElementById('stock-status-modal').style.display = 'block';
}

function updateOrderItem(itemId) {
  const item = AppState.orderItems.find(i => i.id == itemId);
  if (!item) return;
  
  const orderItemEl = document.querySelector(`[data-id="${itemId}"]`);
  if (!orderItemEl) return;
  
  // 재고 상태 버튼 업데이트
  const stockBtn = orderItemEl.querySelector('.stock-status-btn');
  if (stockBtn) {
    const stockStatus = getStockStatusDisplay(item.stockAvailable || '미확인');
    stockBtn.className = `stock-status-btn ${stockStatus.class}`;
    stockBtn.innerHTML = `
      <span>${stockStatus.icon}</span>
      <span>${stockStatus.text}</span>
      ${item.stockStatus ? '<span class="csv-indicator">📊</span>' : ''}
    `;
  }
  
  // 수량 업데이트
  const qtyInput = orderItemEl.querySelector('.quantity-input');
  if (qtyInput) {
    qtyInput.value = item.quantity;
  }
  
  // 금액 업데이트
  const amountEl = orderItemEl.querySelector('.order-amount');
  if (amountEl) {
    const amount = item.quantity * (item.purchasePrice || 0);
    amountEl.textContent = '₩' + formatNumber(amount);
  }
  
  // 요약 업데이트
  updateOrderSummary();
}

function resetStockStatusModal() {
  document.querySelectorAll('input[name="stockStatus"]').forEach(radio => {
    radio.checked = false;
  });
  document.getElementById('custom-status').value = '';
  document.getElementById('custom-status').disabled = true;
}

function saveStockStatus() {
  if (!AppState.currentStockEditItem) return;
  
  const selectedStatus = document.querySelector('input[name="stockStatus"]:checked');
  if (!selectedStatus) {
    showError('재고 상태를 선택해주세요.');
    return;
  }
  
  let newStatus = '';
  switch(selectedStatus.value) {
    case 'available': newStatus = '가능'; break;
    case 'soldout': newStatus = '품절'; break;
    case 'ordering': newStatus = '오더중'; break;
    case 'custom':
      newStatus = document.getElementById('custom-status').value.trim();
      if (!newStatus) {
        showError('상태를 입력해주세요.');
        return;
      }
      break;
  }
  
  AppState.currentStockEditItem.stockAvailable = newStatus;
  updateOrderList();
  
  if (AppState.currentOrderInfo) {
    scheduleAutoSave();
  }
  
  AppState.currentStockEditItem = null;
  closeModal('stock-status-modal');
  showQuickSuccess('재고 상태가 업데이트되었습니다.');
}

function getStockStatusDisplay(status, stockData) {
  const statusStr = status ? String(status).trim() : '미확인';
  const isCSVConfirmed = stockData && stockData.stockStatus;
  
  const statusMap = {
    '미확인': { icon: '❓', text: '미확인', class: 'status-unconfirmed' },
    '가능': { icon: '✅', text: '가능', class: 'status-available' },
    '품절': { icon: '❌', text: '품절', class: 'status-soldout' },
    '오더중': { icon: '⏳', text: '오더중', class: 'status-ordering' }
  };
  
  if (isCSVConfirmed) {
    if (stockData.stockStatus === 'not_found') {
      return { icon: '🔍', text: 'CSV 미등록', class: 'status-not-found csv-confirmed' };
    } else if (stockData.stockStatus === 'partial') {
      return { icon: '📊', text: statusStr, class: 'status-partial csv-confirmed' };
    }
    
    const baseStatus = statusMap[statusStr] || statusMap['미확인'];
    return { ...baseStatus, class: baseStatus.class + ' csv-confirmed' };
  }
  
  if (statusStr.includes('개만 가능')) {
    return { icon: '📊', text: statusStr, class: 'status-partial' };
  }
  
  if (!isNaN(statusStr) && statusStr !== '' && statusStr !== '미확인') {
    return { icon: '📊', text: `${statusStr}개만 가능`, class: 'status-partial' };
  }
  
  if (statusStr && !statusMap[statusStr]) {
    return { icon: '📝', text: statusStr, class: 'status-custom' };
  }
  
  return statusMap[statusStr] || statusMap['미확인'];
}

// ===== 17. 확정/저장 기능 =====
function showConfirmModal(title, message, onConfirm) {
  const modalContent = `
    <div class="confirm-modal-content">
      <h3>${title}</h3>
      <p>${message}</p>
      <div class="modal-actions" style="margin-top: 30px; display: flex; gap: 10px; justify-content: flex-end;">
        <button class="btn btn-secondary" onclick="closeModal()">취소</button>
        <button class="btn btn-primary" id="confirm-action-btn">확인</button>
      </div>
    </div>
  `;
  
  showModal(modalContent);
  
  // 확인 버튼에 이벤트 리스너 추가
  setTimeout(() => {
    const confirmBtn = document.getElementById('confirm-action-btn');
    if (confirmBtn) {
      confirmBtn.onclick = function() {
        closeModal();
        if (onConfirm) onConfirm();
      };
    }
  }, 100);
}

// confirmSelectedItems 함수 수정
function confirmSelectedItems() {
  const checkboxes = document.querySelectorAll('.order-checkbox:checked');
  
  if (checkboxes.length === 0) {
    showError('확정할 항목을 선택해주세요.');
    return;
  }
  
  // 선택된 항목들의 정보 수집
  const selectedItems = [];
  checkboxes.forEach(checkbox => {
    const orderItem = checkbox.closest('.order-item');
    if (orderItem && orderItem.dataset.id) {
      const item = AppState.orderItems.find(i => String(i.id) === String(orderItem.dataset.id));
      if (item && item.status !== '확정') {
        selectedItems.push(item);
      }
    }
  });
  
  if (selectedItems.length === 0) {
    showError('이미 확정된 항목입니다.');
    return;
  }
  
  // 상품 목록 HTML 생성
  const itemListHtml = selectedItems.map(item => `
    <div style="text-align: left; padding: 8px; border-bottom: 1px solid #eee;">
      <strong>${item.name}</strong>
      ${item.option ? `<span style="color: #666;"> - ${item.option}</span>` : ''}
      <span style="float: right; color: #3498db;">${item.quantity}개</span>
    </div>
  `).join('');
  
  // 커스텀 확인 모달 사용
  showConfirmModal(
    '선택 항목 확정',
    `<div style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
      ${itemListHtml}
    </div>
    <p style="margin-top: 15px; font-weight: bold;">
      총 ${selectedItems.length}개 항목을 확정하시겠습니까?
    </p>`,
    function() {
      let confirmedCount = 0;
      selectedItems.forEach(item => {
        item.status = '확정';
        item.confirmedAt = new Date().toLocaleString('ko-KR');
        confirmedCount++;
      });
      
      updateOrderList();
      saveDraft();
      
      if (confirmedCount > 0) {
        showQuickSuccess(`${confirmedCount}개 항목이 확정되었습니다.`);
      }
    }
  );
}

// confirmAllItems 함수 수정
function confirmAllItems() {
  const unconfirmedItems = AppState.orderItems.filter(item => item.status !== '확정');
  
  if (unconfirmedItems.length === 0) {
    showError('확정할 항목이 없습니다.');
    return;
  }
  
  // 상품 목록 HTML 생성 (최대 10개까지만 표시)
  const displayItems = unconfirmedItems.slice(0, 10);
  const itemListHtml = displayItems.map(item => `
    <div style="text-align: left; padding: 8px; border-bottom: 1px solid #eee;">
      <strong>${item.name}</strong>
      ${item.option ? `<span style="color: #666;"> - ${item.option}</span>` : ''}
      <span style="float: right; color: #3498db;">${item.quantity}개</span>
    </div>
  `).join('');
  
  const moreItemsText = unconfirmedItems.length > 10 ? 
    `<p style="text-align: center; color: #666; margin-top: 10px;">
      ... 외 ${unconfirmedItems.length - 10}개 항목
    </p>` : '';
  
  // 커스텀 확인 모달 사용
  showConfirmModal(
    '전체 확정',
    `<div style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;">
      ${itemListHtml}
      ${moreItemsText}
    </div>
    <p style="margin-top: 15px; font-weight: bold;">
      총 ${unconfirmedItems.length}개 항목을 모두 확정하시겠습니까?
    </p>
    <p style="color: #e74c3c; margin-top: 10px; font-size: 14px;">
      ⚠️ 확정 후에는 수량 변경이 불가능합니다.
    </p>`,
    function() {
      unconfirmedItems.forEach(item => {
        item.status = '확정';
        item.confirmedAt = new Date().toLocaleString('ko-KR');
      });
      
      updateOrderList();
      saveDraft();
      showQuickSuccess(`${unconfirmedItems.length}개 항목이 모두 확정되었습니다.`);
    }
  );
}

function saveDraft(showMessage = true) {
  if (!AppState.currentOrderInfo) {
    if (showMessage) showError('발주서가 없습니다.');
    return;
  }
  
  if (AppState.orderItems.length === 0) {
    if (showMessage) showError('저장할 항목이 없습니다.');
    return;
  }
  
  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('saved');
      if (result.success && showMessage) {
        showQuickSuccess(`${result.savedCount}개 항목이 저장되었습니다.`);
      }
      AppState.hasUnsavedChanges = false;
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      if (showMessage) showError('저장 실패: ' + error);
    })
    .saveToOrderSheetWithVersion(AppState.orderItems)
}

function clearOrders() {
  const modalContent = `
    <div class="clear-orders-modal">
      <h3>⚠️ 발주 목록 초기화</h3>
      <p class="warning-text">정말 초기화 하시겠습니까?</p>
      <p class="sub-text">발주서의 모든 항목이 삭제됩니다.</p>
      
      <div class="modal-actions">
        <button id="clear-confirm-btn" class="btn btn-danger" disabled onclick="confirmClearOrders()">
          예 (<span id="clear-timer">5</span>초)
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">아니오</button>
      </div>
    </div>
  `;
  
  showModal(modalContent);
  
  let timeLeft = 5;
  const confirmBtn = document.getElementById('clear-confirm-btn');
  const timerSpan = document.getElementById('clear-timer');
  
  const timerInterval = setInterval(() => {
    timeLeft--;
    
    if (timeLeft > 0) {
      timerSpan.textContent = timeLeft;
    } else {
      clearInterval(timerInterval);
      confirmBtn.disabled = false;
      confirmBtn.innerHTML = '예, 초기화합니다';
      confirmBtn.classList.add('active');
    }
  }, 1000);
}

function confirmClearOrders() {
  AppState.orderItems = [];
  clearSession();
  updateOrderList();
  closeModal();
  
  if (AppState.currentOrderInfo) {
    google.script.run
      .withSuccessHandler(function(result) {
        if (result.success) {
          showQuickSuccess('발주 목록이 초기화되었습니다.');
        }
      })
      .clearOrderSheet(AppState.currentOrderInfo.orderId);
  } else {
    showQuickSuccess('발주 목록이 초기화되었습니다.');
  }
}

// ===== 18. 세션 관리 =====
function restoreSession() {
  try {
    const sessionData = sessionStorage.getItem('currentOrderSession');
    if (!sessionData) return false;
    
    const data = JSON.parse(sessionData);
    
    if (Date.now() - data.timestamp > CONFIG.SESSION_TTL) {
      sessionStorage.removeItem('currentOrderSession');
      return false;
    }
    
    if (data.orderInfo?.orderId !== AppState.currentOrderInfo?.orderId) {
      sessionStorage.removeItem('currentOrderSession');
      return false;
    }
    
    AppState.orderItems = data.orderItems;
    updateOrderList();
    showQuickSuccess('이전 작업이 복원되었습니다.');
    return true;
    
  } catch (e) {
    console.error('세션 복원 실패:', e);
    sessionStorage.removeItem('currentOrderSession');
    return false;
  }
}

function saveSession() {
  if (!AppState.currentOrderInfo || AppState.orderItems.length === 0) return;
  
  try {
    const sessionData = {
      orderInfo: {
        orderId: AppState.currentOrderInfo.orderId,
        recipientName: AppState.currentOrderInfo.recipientName,
        fileName: AppState.currentOrderInfo.fileName
      },
      orderItems: AppState.orderItems.slice(0, CONFIG.MAX_SESSION_ITEMS),
      timestamp: Date.now()
    };
    
    sessionStorage.setItem('currentOrderSession', JSON.stringify(sessionData));
  } catch (e) {
    console.warn('세션 저장 실패:', e);
  }
}

function clearSession() {
  sessionStorage.removeItem('currentOrderSession');
  
  if (AppState.currentOrderInfo?.orderId) {
    localStorage.removeItem(`order_${AppState.currentOrderInfo.orderId}`);
  }
  
  Object.values(AppState.timers).forEach(timer => {
    if (timer) clearTimeout(timer);
  });
  
  AppState.hasUnsavedChanges = false;
}

// ===== 19. 자동 저장 =====
function startAutoSave() {
  if (AppState.timers.autoSave) {
    clearInterval(AppState.timers.autoSave);
  }
  
  AppState.timers.autoSave = setInterval(() => {
    saveSession();
    
    if (AppState.hasUnsavedChanges && AppState.currentOrderInfo) {
      performAutoSave();
    }
  }, CONFIG.AUTO_SAVE_DELAY);
}

function scheduleAutoSave() {
  AppState.hasUnsavedChanges = true;
  saveSession();
}

function performAutoSave() {
  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler(() => {
      showSaveIndicator('saved');
      AppState.hasUnsavedChanges = false;
    })
    .withFailureHandler((error) => {
      showSaveIndicator('hide');
      console.error('자동 저장 실패:', error);
    })
    .saveToOrderSheetWithVersion(AppState.orderItems)
}

// ===== 20. 유틸리티 함수들 =====
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

function parseColorSize(optionText) {
  if (!optionText) return { color: '', size: '', display: '' };
  
  const parts = optionText.split('/');
  if (parts.length !== 2) {
    return { color: '', size: optionText, display: optionText };
  }
  
  const [colorPart, sizePart] = parts.map(p => p.trim());
  const colorLower = colorPart.toLowerCase();
  const hexColor = colorMap[colorLower];
  
  return {
    color: colorPart,
    colorHex: hexColor,
    size: sizePart,
    display: optionText
  };
}

// ===== 20. 유틸리티 함수들 ===== 섹션에 추가
function getPriorityDisplay(priority) {
  switch(priority) {
    case 1:
      return { 
        icon: '★', 
        text: '높음', 
        class: 'priority-high' 
      };
    case 2:
      return { 
        icon: '★', 
        text: '보통', 
        class: 'priority-medium' 
      };
    case 3:
      return { 
        icon: '★', 
        text: '낮음', 
        class: 'priority-low' 
      };
    default:
      return { 
        icon: '★', 
        text: '낮음', 
        class: 'priority-medium' 
      };
  }
}

function getCategory(productName) {
  if (!productName) return '';
  
  // AppState.categoryRules가 없으면 빈 문자열 반환
  if (!AppState.categoryRules || typeof AppState.categoryRules !== 'object') {
    return '';
  }
  
  const nameLower = productName.toLowerCase();
  
  // 정확히 일치하는 경우 먼저 확인
  if (AppState.categoryRules[nameLower]) {
    return AppState.categoryRules[nameLower];
  }
  
  // 부분 일치 확인
  for (const [keyword, category] of Object.entries(AppState.categoryRules)) {
    if (nameLower.includes(keyword.toLowerCase())) {
      return category;
    }
  }
  
  return '';
}

function filterSearchResults() {
  const items = document.querySelectorAll('.search-item');
  
  items.forEach(item => {
    if (AppState.currentFilter === 'all' || item.dataset.tag === AppState.currentFilter) {
      item.style.display = 'flex';
    } else {
      item.style.display = 'none';
    }
  });
}

function showModal(content) {
  console.log('showModal 호출됨');
  
  let modalBody = document.getElementById('modal-body');
  let modal = document.getElementById('modal');
  
  // 모달이 없으면 생성
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'modal';
    modal.className = 'modal';
    modal.innerHTML = `
      <div class="modal-content">
        <span class="modal-close" onclick="closeModal()">&times;</span>
        <div id="modal-body"></div>
      </div>
    `;
    document.body.appendChild(modal);
    modalBody = document.getElementById('modal-body');
  }
  
  if (modalBody) {
    modalBody.innerHTML = content;
    modal.style.display = 'block';
  } else {
    console.error('모달 body를 찾을 수 없습니다');
  }
}

function closeModal(modalId) {
  console.log('closeModal 호출됨, modalId:', modalId);
  
  if (modalId) {
    const modal = document.getElementById(modalId);
    if (modal) {
      modal.style.display = 'none';
    }
  } else {
    // 기본 모달 닫기
    const modal = document.getElementById('modal');
    if (modal) {
      modal.style.display = 'none';
    }
    
    // 모든 모달 닫기
    document.querySelectorAll('.modal').forEach(m => {
      if (m.style.display === 'block') {
        m.style.display = 'none';
      }
    });
  }
}

function closeAllModals() {
  document.querySelectorAll('.modal').forEach(modal => {
    modal.style.display = 'none';
  });
  
  document.querySelectorAll('.quick-stock-menu.show').forEach(menu => {
    menu.classList.remove('show');
  });
}

function handleBeforeUnload(e) {
  if (AppState.hasUnsavedChanges) {
    e.preventDefault();
    e.returnValue = '저장하지 않은 변경사항이 있습니다.';
  }
}

function showQuickSuccess(message) {
  const translatedMessage = typeof message === 'string' && message.startsWith('messages.') 
    ? t(message) 
    : message;
    
  const existingToast = document.querySelector('.toast-message');
  if (existingToast) existingToast.remove();
  
  const toast = document.createElement('div');
  toast.className = 'toast-message success show';
  toast.textContent = translatedMessage;
  document.body.appendChild(toast);
  
setTimeout(() => {
   toast.classList.remove('show');
   setTimeout(() => toast.remove(), 300);
 }, 2000);
}

function showError(message) {
 const translatedMessage = typeof message === 'string' && message.startsWith('messages.') 
   ? t(message) 
   : message;
   
 const existingToast = document.querySelector('.toast-message');
 if (existingToast) existingToast.remove();
 
 const toast = document.createElement('div');
 toast.className = 'toast-message error show';
 toast.textContent = translatedMessage;
 document.body.appendChild(toast);
 
 setTimeout(() => {
   toast.classList.remove('show');
   setTimeout(() => toast.remove(), 300);
 }, 3000);
}

function showSaveIndicator(status) {
 let indicator = document.getElementById('save-indicator');
 
 if (!indicator) {
   indicator = document.createElement('div');
   indicator.id = 'save-indicator';
   indicator.className = 'save-indicator';
   document.body.appendChild(indicator);
 }
 
 const messages = {
   'loading': '⟳ 로딩중...',
   'saving': '💾 저장 중...',
   'saved': '✓ 저장됨',
   'hide': ''
 };
 
 indicator.textContent = messages[status] || '';
 
 if (status === 'hide') {
   indicator.classList.remove('show');
   indicator.style.display = 'none';
 } else {
   indicator.classList.add('show');
   indicator.style.display = 'block';
 }
 
 if (status === 'saved') {
   setTimeout(() => {
     indicator.classList.remove('show');
     setTimeout(() => {
       indicator.style.display = 'none';
     }, 300);
   }, 2000);
 }
}

function showLoading(message = '처리 중...') {
  let loading = document.getElementById('loading');
  if (!loading) {
    loading = document.createElement('div');
    loading.id = 'loading';
    loading.className = 'loading';
    loading.innerHTML = `
      <div class="loading-content">
        <div class="loading-spinner"></div>
        <div class="loading-message">${message}</div>
        <div class="loading-progress">
          <div class="loading-progress-bar"></div>
        </div>
      </div>
    `;
    document.body.appendChild(loading);
  } else {
    const messageEl = loading.querySelector('.loading-message');
    if (messageEl) {
      messageEl.textContent = message;
    }
  }
  loading.style.display = 'flex';
}

function hideLoading() {
  const loading = document.getElementById('loading');
  if (loading) {
    loading.style.display = 'none';
  }
}

function showRetryNotification(functionName, attempt, maxRetries) {
 let notification = document.getElementById('retry-notification');
 
 if (!notification) {
   notification = document.createElement('div');
   notification.id = 'retry-notification';
   notification.className = 'retry-notification';
   document.body.appendChild(notification);
 }
 
 notification.innerHTML = `
   <div class="retry-icon">🔄</div>
   <div class="retry-text">
     <div class="retry-title">연결 재시도 중...</div>
     <div class="retry-detail">${attempt}/${maxRetries} 시도</div>
   </div>
 `;
 
 notification.classList.add('show');
}

function hideRetryNotification() {
 const notification = document.getElementById('retry-notification');
 if (notification) {
   notification.classList.remove('show');
   setTimeout(() => {
     notification.remove();
   }, 300);
 }
}

// ===== 21. 다국어 지원 =====
function initializeLanguage() {
  // const savedLang = localStorage.getItem('preferredLanguage');
  const savedLang = safeGetItem('preferredLanguage');
  
  if (savedLang) {
    AppState.currentLang = savedLang;
  } else {
    AppState.currentLang = detectBrowserLanguage();
    // localStorage.setItem('preferredLanguage', AppState.currentLang);
    safeSetItem('preferredLanguage', AppState.currentLang);
  }
  
  return loadTranslations(AppState.currentLang);
}

function detectBrowserLanguage() {
 const browserLang = navigator.language || navigator.userLanguage;
 return browserLang.startsWith('ja') ? 'ja' : 'ko';
}

function loadTranslations(lang) {
 return new Promise((resolve, reject) => {
   google.script.run
     .withSuccessHandler(function(trans) {
       AppState.translations = trans;
       applyTranslations();
       resolve();
     })
     .withFailureHandler(reject)
     .getTranslations(lang);
 });
}

function applyTranslations() {
 document.querySelectorAll('[data-i18n]').forEach(element => {
   const key = element.getAttribute('data-i18n');
   const translation = getNestedTranslation(key);
   
   if (translation) {
     if (element.tagName === 'INPUT' && element.type === 'text') {
       element.placeholder = translation;
     } else {
       element.textContent = translation;
     }
   }
 });
}

function getNestedTranslation(key) {
 const keys = key.split('.');
 let value = AppState.translations;
 
 for (const k of keys) {
   if (value && value[k]) {
     value = value[k];
   } else {
     return null;
   }
 }
 
 return value;
}

function t(key) {
 return getNestedTranslation(key) || key;
}

// ===== 22. 표시 설정 =====
function loadDisplaySettings() {
  // const stored = localStorage.getItem('displaySettings');
  const stored = safeGetItem('displaySettings');
  
  if (stored) {
    // try {
    //   return JSON.parse(stored);
    // } catch (e) {
    //   return getDefaultDisplaySettings();
    // }
    return stored; // safeGetItem이 이미 파싱해서 반환
  }
  
  return getDefaultDisplaySettings();
}

function getDefaultDisplaySettings() {
  const defaults = {
    showBarcode: false,
    showSupplier: false,
    showWeight: false,
    showMemo: false,
    colorChipEnabled: true,
    compactMode: false
  };
  
  // localStorage.setItem('displaySettings', JSON.stringify(defaults));
  safeSetItem('displaySettings', defaults);
  return defaults;
}

// 설정 표시 함수 수정
function displaySettings(settings) {
  const elements = {
    'product-sheet-id': settings.productSheetId,
    'order-sheet-id': settings.orderSheetId,
    'max-results': settings.maxSearchResults || 100,
    'monthly-budget': settings.monthlyBudget || 10000000,
    'language': settings.language || 'ko'
  };
  
  Object.entries(elements).forEach(([id, value]) => {
    const el = document.getElementById(id);
    if (el) el.value = value || '';
  });
  
  // 박스 바코드 목록 표시
  displayBoxBarcodes();
}

// 박스 모드 전환 UI
function toggleBoxModeUI(mode) {
  // 박스 설정이 설정 탭에 없으므로 함수 비활성화
  console.log('박스 모드:', mode);
  
  // 박스 바코드 목록만 표시/업데이트
  if (mode === 'barcode') {
    displayBoxBarcodes();
  }
}

function initializeDisplaySettings() {
 const settings = loadDisplaySettings();
 
 Object.keys(settings).forEach(key => {
   const toggleId = `toggle-${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;
   const toggleElement = document.getElementById(toggleId);
   
   if (toggleElement) {
     if (settings[key]) {
       toggleElement.classList.add('active');
     } else {
       toggleElement.classList.remove('active');
     }
   }
 });
}

function toggleSetting(settingName) {
 const settings = loadDisplaySettings();
 const toggleElement = event.currentTarget;
 
 settings[settingName] = !settings[settingName];
 
 if (settings[settingName]) {
   toggleElement.classList.add('active');
 } else {
   toggleElement.classList.remove('active');
 }
 
 saveDisplaySettings(settings);
}

// ===== 23. 추가 기능들 =====
function injectColorChipStyles() {
 if (document.getElementById('colorchip-styles')) return;
 
 const styleElement = document.createElement('style');
 styleElement.id = 'colorchip-styles';
 styleElement.textContent = `
   .color-chip-container {
     display: inline-flex !important;
     align-items: center !important;
     gap: 6px !important;
     margin-right: 12px !important;
   }
   
   .color-chip {
     display: inline-block !important;
     width: 14px !important;
     height: 14px !important;
     border-radius: 4px !important;
     border: 1px solid rgba(0, 0, 0, 0.2) !important;
     vertical-align: middle !important;
     box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12) !important;
   }
   
   .color-name {
     font-size: 12px !important;
     color: #666 !important;
     text-transform: capitalize !important;
   }
   
   .size-text {
     font-size: 12px !important;
     color: #333 !important;
     font-weight: 500 !important;
     padding: 2px 8px !important;
     background: #f0f0f0 !important;
     border-radius: 12px !important;
     text-transform: uppercase !important;
   }
 `;
 
 document.head.appendChild(styleElement);
}

function setupKeyboardShortcuts() {
 // 이미 handleGlobalKeydown에서 처리됨
}

function restoreLocalCache() {
 try {
   const localCache = localStorage.getItem('recentAddedProducts');
   if (!localCache) return;
   
   const cached = JSON.parse(localCache);
   const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
   
   const validCache = cached.filter(p => {
     const cachedTime = new Date(p.cachedAt).getTime();
     return cachedTime > thirtyDaysAgo;
   });
   
   const existingBarcodes = new Set(AppState.products.map(p => p.barcode));
   let addedCount = 0;
   
   validCache.forEach(p => {
     if (!existingBarcodes.has(p.barcode)) {
       p.isFromCache = true;
       AppState.products.push(p);
       addedCount++;
     }
   });
   
   if (validCache.length < cached.length) {
     localStorage.setItem('recentAddedProducts', JSON.stringify(validCache));
   }
   
   if (addedCount > 0) {
     console.info(`로컬 캐시에서 ${addedCount}개 상품 복원`);
   }
   
 } catch (e) {
   console.warn('로컬 캐시 복원 실패:', e);
 }
}

// ===== 24. 나머지 비즈니스 로직 함수들 =====
// 우선순위, 코멘트, 대시보드, 자주발주, 안전재고, CSV 업로드/내보내기, 제품 이슈, 설정 등의 함수들
// 이 부분은 기존 코드에서 중복 제거 후 그대로 유지

// ===== 우선순위 관련 함수들 - 전역 스코프에 직접 정의 =====

// 1. getPriorityDisplay 함수 수정 (기본값 3으로)
window.getPriorityDisplay = function(priority) {
  // 기본값을 3으로 설정
  const p = priority || 3;
  
  switch(p) {
    case 1:
      return { 
        icon: '★★★', 
        text: '높음', 
        class: 'priority-high' 
      };
    case 2:
      return { 
        icon: '★★', 
        text: '보통', 
        class: 'priority-medium' 
      };
    case 3:
      return { 
        icon: '★', 
        text: '낮음', 
        class: 'priority-low' 
      };
    default:
      return { 
        icon: '★', 
        text: '낮음', 
        class: 'priority-low' 
      };
  }
}

// 우선순위 선택 모달 표시 - 전역 함수로 직접 정의
window.showPriorityPicker = function(itemId) {
  console.log('=== showPriorityPicker 디버깅 ===');
  console.log('1. 함수 호출됨, itemId:', itemId);
  console.log('2. AppState 확인:', typeof AppState !== 'undefined' ? 'OK' : 'ERROR - AppState 없음');
  console.log('3. orderItems 개수:', AppState?.orderItems?.length || 0);
  
  // AppState 체크
  if (typeof AppState === 'undefined' || !AppState.orderItems) {
    console.error('AppState 또는 orderItems가 없습니다');
    alert('앱 상태를 확인할 수 없습니다. 페이지를 새로고침해주세요.');
    return;
  }
  
  // 아이템 찾기
  const item = AppState.orderItems.find(i => String(i.id) === String(itemId));
  console.log('4. 아이템 찾기 결과:', item ? 'FOUND' : 'NOT FOUND');
  
  if (!item) {
    console.error('아이템을 찾을 수 없습니다. ID:', itemId);
    console.log('현재 orderItems IDs:', AppState.orderItems.map(i => i.id));
    alert('해당 상품을 찾을 수 없습니다.');
    return;
  }
  
  if (item.status === '확정') {
    console.log('5. 확정된 항목입니다');
    alert('확정된 항목은 우선순위를 변경할 수 없습니다.');
    return;
  }
  
  const currentPriority = item.priority || 2;
  console.log('6. 현재 우선순위:', currentPriority);
  
  // 모달 HTML 생성
  const modalContent = `
    <div class="priority-modal-content">
      <h3>우선순위 선택</h3>
      <p class="item-info">${item.name}</p>
      <div class="priority-picker">
        <button class="priority-option ${currentPriority === 1 ? 'selected' : ''}" 
                onclick="window.setPriority('${itemId}', 1)">
          <span class="priority-level high">★★★</span>
          <span class="priority-desc">긴급 발주 필요</span>
        </button>
        <button class="priority-option ${currentPriority === 2 ? 'selected' : ''}" 
                onclick="window.setPriority('${itemId}', 2)">
          <span class="priority-level medium">★★</span>
          <span class="priority-desc">일반 발주</span>
        </button>
        <button class="priority-option ${currentPriority === 3 ? 'selected' : ''}" 
                onclick="window.setPriority('${itemId}', 3)">
          <span class="priority-level low">★</span>
          <span class="priority-desc">여유 있음</span>
        </button>
      </div>
      <div style="margin-top: 20px; text-align: center;">
        <button class="btn btn-secondary" onclick="window.closeModal()">취소</button>
      </div>
    </div>
  `;
  
  console.log('7. 모달 표시 시도');
  
  // 기존 모달이 있으면 제거
  const existingModal = document.getElementById('priority-modal');
  if (existingModal) {
    existingModal.remove();
  }
  
  // 새 모달 생성
  const modal = document.createElement('div');
  modal.id = 'priority-modal';
  modal.className = 'modal';
  modal.style.cssText = 'display: block; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4);';
  
  const modalInner = document.createElement('div');
  modalInner.className = 'modal-content';
  modalInner.style.cssText = 'background-color: white; margin: 10% auto; padding: 20px; width: 80%; max-width: 500px; border-radius: 8px; position: relative;';
  
  const closeBtn = document.createElement('span');
  closeBtn.className = 'modal-close';
  closeBtn.innerHTML = '&times;';
  closeBtn.style.cssText = 'position: absolute; right: 20px; top: 20px; font-size: 28px; cursor: pointer; color: #aaa;';
  closeBtn.onclick = function() { modal.remove(); };
  
  modalInner.appendChild(closeBtn);
  modalInner.insertAdjacentHTML('beforeend', modalContent);
  modal.appendChild(modalInner);
  document.body.appendChild(modal);
  
  console.log('8. 모달 생성 완료');
  
  // 모달 외부 클릭 시 닫기
  modal.onclick = function(e) {
    if (e.target === modal) {
      modal.remove();
    }
  };
};

// 우선순위 설정 - 전역 함수로 직접 정의
window.setPriority = function(itemId, priority) {
  console.log('=== setPriority 디버깅 ===');
  console.log('1. 함수 호출됨, itemId:', itemId, 'priority:', priority);
  
  const item = AppState.orderItems.find(i => String(i.id) === String(itemId));
  if (!item) {
    console.error('아이템을 찾을 수 없습니다:', itemId);
    return;
  }
  
  console.log('2. 이전 우선순위:', item.priority);
  item.priority = priority || 2;
  console.log('3. 새 우선순위:', item.priority);
  
  // 모달 닫기
  const modal = document.getElementById('priority-modal');
  if (modal) {
    modal.remove();
  }
  
  // 해당 항목만 업데이트
  const orderItemEl = document.querySelector(`[data-id="${itemId}"]`);
  if (orderItemEl) {
    const priorityBtn = orderItemEl.querySelector('.order-action-btn.priority');
    if (priorityBtn) {
      const priorityDisplay = getPriorityDisplay(priority);
      priorityBtn.className = `order-action-btn priority ${priorityDisplay.class}`;
      priorityBtn.innerHTML = `
        <span class="priority-badge">${priorityDisplay.icon}</span>
        <span class="priority-text">${priorityDisplay.text}</span>
      `;
      priorityBtn.title = `우선순위: ${priorityDisplay.text}`;
      console.log('4. UI 업데이트 완료');
    }
  }
  
  // 자동 저장
  if (typeof scheduleAutoSave === 'function') {
    scheduleAutoSave();
  }
  
  // 성공 메시지
  if (typeof showQuickSuccess === 'function') {
    showQuickSuccess('우선순위가 변경되었습니다.');
  } else {
    alert('우선순위가 변경되었습니다.');
  }
  
  console.log('5. 우선순위 변경 완료');
};

// closeModal 함수도 전역으로
window.closeModal = function(modalId) {
  if (modalId) {
    const modal = document.getElementById(modalId);
    if (modal) modal.style.display = 'none';
  } else {
    // priority-modal 먼저 확인
    const priorityModal = document.getElementById('priority-modal');
    if (priorityModal) {
      priorityModal.remove();
      return;
    }
    
    // 기본 모달
    const modal = document.getElementById('modal');
    if (modal) modal.style.display = 'none';
    
    // 모든 모달
    document.querySelectorAll('.modal').forEach(m => {
      if (m.style.display === 'block') {
        m.style.display = 'none';
      }
    });
  }
};

function showCommentInput(id) {
  const item = AppState.orderItems.find(i => i.id == id);
  if (!item) return;
  
  const modalContent = `
    <h3>코멘트 입력</h3>
    <textarea id="comment-textarea" class="comment-textarea" placeholder="클릭하여 입력...">${item.comment || ''}</textarea>
    <div style="margin-top: 20px; text-align: right;">
      <button class="btn btn-primary" onclick="saveComment('${id}')">저장</button>
      <button class="btn btn-secondary" onclick="closeModal()">취소</button>
    </div>
  `;
  
  showModal(modalContent);
  
  // autofocus 대신 클릭 이벤트 사용
  setTimeout(() => {
    const textarea = document.getElementById('comment-textarea');
    if (textarea) {
      textarea.addEventListener('click', function() {
        this.placeholder = '코멘트를 입력하세요...';
      }, { once: true });
    }
  }, 100);
}

function saveComment(id) {
  const comment = document.getElementById('comment-textarea').value.trim();
  const item = AppState.orderItems.find(i => i.id == id);
  
  if (item) {
    item.comment = comment;
    
    // 해당 항목의 UI만 업데이트
    const orderItem = document.querySelector(`[data-id="${id}"]`);
    if (orderItem) {
      const commentBtn = orderItem.querySelector('.order-action-btn.comment');
      if (commentBtn) {
        if (comment) {
          commentBtn.classList.add('has-comment');
          commentBtn.setAttribute('data-comment', comment);
          
          // 코멘트 표시기 추가
          if (!commentBtn.querySelector('.comment-indicator')) {
            commentBtn.innerHTML = '💬<span class="comment-indicator"></span>';
          }
        } else {
          commentBtn.classList.remove('has-comment');
          commentBtn.removeAttribute('data-comment');
          commentBtn.innerHTML = '💬';
        }
      }
    }
    
    closeModal();
    scheduleAutoSave();
    showQuickSuccess(comment ? '코멘트가 저장되었습니다.' : '코멘트가 삭제되었습니다.');
  }
}

function loadSettings() {
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler(function(data) {
        AppState.settings = data;
        
        // DOM 요소가 존재하는지 확인 후 설정
        const productSheetEl = document.getElementById('product-sheet-id');
        if (productSheetEl) {
          productSheetEl.value = data.productSheetId || '';
        }
        
        const orderSheetEl = document.getElementById('order-sheet-id');
        if (orderSheetEl) {
          orderSheetEl.value = data.orderSheetId || '';
        }
        
        const maxResultsEl = document.getElementById('max-results');
        if (maxResultsEl) {
          maxResultsEl.value = data.maxSearchResults || 100;
        }
        
        const languageEl = document.getElementById('language');
        if (languageEl) {
          languageEl.value = data.language || 'ko';
        }
        
        const suggestStock0El = document.getElementById('suggest-stock-0');
        if (suggestStock0El) {
          suggestStock0El.value = data.suggestStock0 || 30;
        }
        
        const suggestStock10El = document.getElementById('suggest-stock-10');
        if (suggestStock10El) {
          suggestStock10El.value = data.suggestStock10 || 20;
        }
        
        const suggestStock20El = document.getElementById('suggest-stock-20');
        if (suggestStock20El) {
          suggestStock20El.value = data.suggestStock20 || 10;
        }
        
        resolve();
      })
      .withFailureHandler(function(error) {
        console.error('설정 로드 실패:', error);
        // 에러가 발생해도 앱은 계속 실행되도록 resolve 호출
        resolve();
      })
      .getSettings();
  });
}

// 더 안전한 방법: 설정 탭이 활성화될 때만 설정 로드
function loadSettingsWhenVisible() {
  // 설정 탭이 표시될 때만 DOM 업데이트
  const settingsTab = document.getElementById('settings-tab');
  if (!settingsTab || !settingsTab.classList.contains('active')) {
    // 설정은 저장하되 DOM 업데이트는 하지 않음
    return new Promise((resolve) => {
      google.script.run
        .withSuccessHandler(function(data) {
          AppState.settings = data;
          resolve();
        })
        .withFailureHandler(function(error) {
          console.warn('설정 로드 실패:', error);
          AppState.settings = {}; // 기본값 설정
          resolve();
        })
        .getSettings();
    });
  }
  
  // 설정 탭이 활성화되어 있을 때만 전체 로드
  return loadSettings();
}

// 초기화 시에는 설정만 로드하고 DOM 업데이트는 하지 않음
async function loadSettingsDataOnly() {
  return new Promise((resolve) => {
    google.script.run
      .withSuccessHandler((data) => {
        AppState.settings = data || {};
        resolve(data || {});
      })
      .withFailureHandler(() => {
        AppState.settings = {};
        resolve({});
      })
      .getSettings();
  });
}

// 설정 저장 함수 수정
function saveSettings() {
  // DOM 요소 안전 조회 함수
  const safeGetValue = (id, defaultValue = '') => {
    const element = document.getElementById(id);
    return element ? element.value : defaultValue;
  };

  const newSettings = {
    productSheetId: safeGetValue('product-sheet-id'),
    orderSheetId: safeGetValue('order-sheet-id'),
    maxSearchResults: safeGetValue('max-results', '100'),
    language: safeGetValue('language', 'ko'),
    monthlyBudget: safeGetValue('monthly-budget', '10000000'),
    suggestStock0: safeGetValue('suggest-stock-0', '30'),
    suggestStock10: safeGetValue('suggest-stock-10', '20'),
    suggestStock20: safeGetValue('suggest-stock-20', '10'),
    // 박스 설정
    boxMode: safeGetValue('box-mode', 'barcode'),
    boxDigits: safeGetValue('box-digits', '3'),
    maxLowStockDisplay: safeGetValue('max-low-stock-display', '50')
  };

  // 음성 설정 처리 (요소가 있을 때만)
  const voiceVolumeEl = document.getElementById('voice-volume');
  const voiceRateEl = document.getElementById('voice-rate');
  const voicePitchEl = document.getElementById('voice-pitch');
  const voiceLanguageEl = document.getElementById('voice-language');

  if (voiceVolumeEl && voiceRateEl && voicePitchEl && voiceLanguageEl) {
    newSettings.voiceSettings = {
      volume: parseFloat(voiceVolumeEl.value),
      rate: parseFloat(voiceRateEl.value),
      pitch: parseFloat(voicePitchEl.value),
      language: voiceLanguageEl.value
    };
  }

  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      if (result.success) {
        AppState.settings = newSettings;
        showQuickSuccess(result.message);
        updateBoxNumberStatus();
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('설정 저장 실패: ' + error);
    })
    .updateSettings(newSettings);
}

function updateBulkEditButton() {
 const checkedBoxes = document.querySelectorAll('.order-checkbox:checked');
 const bulkEditBtn = document.getElementById('bulk-stock-edit-btn');
 
 if (checkedBoxes.length > 0) {
   bulkEditBtn.style.display = 'inline-flex';
   bulkEditBtn.innerHTML = `<span style="margin-right: 4px;">📦</span> 재고 상태 (${checkedBoxes.length})`;
 } else {
   bulkEditBtn.style.display = 'none';
 }
}

function updateExportButtonStatus() {
  const exportBtn = document.getElementById('export-csv-btn');
  
  // 버튼이 없으면 그냥 리턴 (오류 방지)
  if (!exportBtn) {
    console.log('export-csv-btn not found in DOM');
    return;
  }
  
  if (!AppState.currentOrderInfo || AppState.orderItems.length === 0) {
    exportBtn.disabled = true;
    return;
  }
  
  const hasConfirmed = AppState.orderItems.some(item => item.status === '확정');
  exportBtn.disabled = !hasConfirmed;
}

// ===== 25. 대시보드 기능 =====
// 로딩 상태 표시
function showChartLoading(containerId) {
  const container = document.getElementById(containerId);
  if (container) {
    container.innerHTML = `
      <div class="chart-loading">
        <div class="chart-spinner"></div>
      </div>
    `;
  }
}

// 대시보드 로드 함수 개선
function loadDashboard() {
  // 모든 차트에 로딩 표시
  ['top-products', 'category-chart', 'monthly-trend', 'supplier-chart', 'weekday-pattern'].forEach(id => {
    showChartLoading(id);
  });
  
  google.script.run
    .withSuccessHandler(function(data) {
      if (!data) {
        showError('대시보드 데이터를 불러올 수 없습니다.');
        return;
      }
      
      // 각 데이터 표시
      displayActionItems(data.actionItems || []);
      displayMetrics(data);
      displayTopProducts(data.topProducts || []);
      displayCategoryChart(data.categoryStats || []);
      displayMonthlyTrend(data.monthlyTrend || []);
      displaySupplierChart(data.supplierStats || []);
      displayWeekdayPattern(data.weekdayPattern || []);
      displayBudgetStatus(data.budgetStatus || {});
      
      if (data.trendingProducts) {
        displayTrendingProducts(data.trendingProducts);
      }
    })
    .withFailureHandler(function(error) {
      showError('대시보드 로드 실패: ' + error);
      // 모든 차트에 에러 상태 표시
      document.querySelectorAll('.chart-container').forEach(container => {
        container.innerHTML = `
          <div class="empty-chart">
            <div class="empty-chart-icon">❌</div>
            <div class="empty-chart-text">로드 실패</div>
          </div>
        `;
      });
    })
    .getDashboardData();
}

function displayActionItems(items) {
  const container = document.getElementById('action-items');
  
  if (!items || items.length === 0) {
    container.innerHTML = '';
    return;
  }
  
  container.innerHTML = items.map(item => `
    <div class="action-item ${item.type}">
      <div class="action-content">
        <h4>${item.title}</h4>
        <p>${item.message}</p>
      </div>
      <button class="btn btn-primary" onclick="handleAction('${item.action}')">
        확인
      </button>
    </div>
  `).join('');
}

function handleAction(action) {
  switch(action) {
    case 'checkInventory':
      showFrequentNotOrdered();
      break;
    case 'viewBudget':
      showBudgetDetails();
      break;
    case 'confirmOrders':
      switchTab('order');
      break;
  }
}

function displayMetrics(data) {
  const monthlyTotal = data.monthlyTrend.length > 0 ? 
    data.monthlyTrend[data.monthlyTrend.length - 1].totalAmount : 0;
  document.getElementById('monthly-total').textContent = '₩' + formatNumber(monthlyTotal);
  
  if (data.monthlyTrend.length > 1) {
    const prevMonth = data.monthlyTrend[data.monthlyTrend.length - 2].totalAmount;
    const change = ((monthlyTotal - prevMonth) / prevMonth * 100).toFixed(1);
    const changeEl = document.getElementById('monthly-change');
    changeEl.textContent = (change >= 0 ? '+' : '') + change + '%';
    changeEl.className = 'metric-change ' + (change >= 0 ? 'positive' : 'negative');
  }
  
  if (data.efficiencyMetrics) {
    document.getElementById('avg-cycle').textContent = data.efficiencyMetrics.avgOrderCycle || '-';
    document.getElementById('repeat-rate').textContent = data.efficiencyMetrics.repeatOrderRate || '-';
  }
  
  if (data.budgetStatus) {
    document.getElementById('budget-rate').textContent = data.budgetStatus.percentage + '%';
    document.getElementById('budget-mini-fill').style.width = data.budgetStatus.percentage + '%';
    
    if (data.budgetStatus.percentage >= 80) {
      document.getElementById('budget-mini-fill').style.background = 'var(--error)';
    } else if (data.budgetStatus.percentage >= 60) {
      document.getElementById('budget-mini-fill').style.background = 'var(--warning)';
    }
  }
}

// 대시보드 데이터 표시 함수들 개선
function displayTopProducts(products) {
  const container = document.getElementById('top-products');
  
  if (!container) return;
  
  if (!products || products.length === 0) {
    container.innerHTML = '<div class="empty-state">데이터가 없습니다</div>';
    return;
  }
  
  // 상위 10개만 표시
  const topItems = products.slice(0, 10);
  const maxAmount = Math.max(...topItems.map(p => p.totalAmount || 0));
  
  let html = '';
  topItems.forEach((product, index) => {
    const percentage = maxAmount > 0 ? (product.totalAmount / maxAmount * 100) : 0;
    
    html += `
      <div class="chart-bar">
        <div class="chart-label" title="${product.name}">
          ${index + 1}. ${product.name}
        </div>
        <div class="chart-bar-container">
          <div class="chart-bar-fill" style="width: ${percentage}%"></div>
        </div>
        <div class="chart-value">₩${formatNumber(product.totalAmount || 0)}</div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function displayCategoryChart(categories) {
  const container = document.getElementById('category-chart');
  
  if (!container) return;
  
  if (!categories || categories.length === 0) {
    container.innerHTML = '<div class="empty-state">데이터가 없습니다</div>';
    return;
  }
  
  const total = categories.reduce((sum, cat) => sum + (cat.totalAmount || 0), 0);
  
  let html = '';
  categories.forEach(cat => {
    const percentage = total > 0 ? (cat.totalAmount / total * 100) : 0;
    
    html += `
      <div class="chart-bar">
        <div class="chart-label">${cat.category}</div>
        <div class="chart-bar-container">
          <div class="chart-bar-fill" style="width: ${percentage}%; background: #4caf50;"></div>
        </div>
        <div class="chart-value">${percentage.toFixed(1)}%</div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function displayMonthlyTrend(trend) {
  const container = document.getElementById('monthly-trend');
  
  if (!container) return;
  
  if (!trend || trend.length === 0) {
    container.innerHTML = '<div class="empty-state">데이터가 없습니다</div>';
    return;
  }
  
  const maxAmount = Math.max(...trend.map(t => t.totalAmount || 0));
  
  let html = '<div class="monthly-trend-chart">';
  
  trend.forEach(month => {
    const height = maxAmount > 0 ? (month.totalAmount / maxAmount * 180) : 0;
    const amount = Math.round((month.totalAmount || 0) / 1000000);
    
    html += `
      <div class="month-bar">
        <div class="month-value">₩${amount}M</div>
        <div class="month-bar-fill" style="height: ${height}px"></div>
        <div class="month-label">${month.month.substring(5)}</div>
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
}

function displaySupplierChart(suppliers) {
  const container = document.getElementById('supplier-chart');
  
  if (!container) return;
  
  if (!suppliers || suppliers.length === 0) {
    container.innerHTML = '<div class="empty-state">데이터가 없습니다</div>';
    return;
  }
  
  const topSuppliers = suppliers.slice(0, 10);
  const maxAmount = Math.max(...topSuppliers.map(s => s.totalAmount || 0));
  
  let html = '';
  topSuppliers.forEach((supplier, index) => {
    const percentage = maxAmount > 0 ? (supplier.totalAmount / maxAmount * 100) : 0;
    
    html += `
      <div class="chart-bar">
        <div class="chart-label">${index + 1}. ${supplier.supplier}</div>
        <div class="chart-bar-container">
          <div class="chart-bar-fill" style="width: ${percentage}%; background: #ff9800;"></div>
        </div>
        <div class="chart-value">₩${formatNumber(supplier.totalAmount || 0)}</div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function displayWeekdayPattern(pattern) {
  const container = document.getElementById('weekday-pattern');
  
  if (!container) return;
  
  if (!pattern || pattern.length === 0) {
    container.innerHTML = '<div class="empty-state">데이터가 없습니다</div>';
    return;
  }
  
  const maxCount = Math.max(...pattern.map(p => p.count || 0));
  
  let html = '<div class="weekday-pattern-chart">';
  
  pattern.forEach(day => {
    const height = maxCount > 0 ? (day.count / maxCount * 150) : 0;
    const color = (day.day === '화' || day.day === '목') ? '#ff9800' : '#2196F3';
    
    html += `
      <div class="weekday-bar">
        <div class="weekday-value">${day.count || 0}</div>
        <div class="weekday-bar-fill" style="height: ${height}px; background: ${color};"></div>
        <div class="weekday-label">${day.day}</div>
      </div>
    `;
  });
  
  html += '</div>';
  container.innerHTML = html;
}

function displayBudgetStatus(budget) {
  if (!budget) return;
  
  const fillEl = document.getElementById('budget-used');
  const textEl = document.getElementById('budget-text');
  const percentEl = document.getElementById('budget-percent');
  
  if (fillEl) {
    fillEl.style.width = (budget.percentage || 0) + '%';
    
    if (budget.percentage >= 90) {
      fillEl.className = 'progress-fill danger';
    } else if (budget.percentage >= 70) {
      fillEl.className = 'progress-fill warning';
    } else {
      fillEl.className = 'progress-fill';
    }
  }
  
  if (textEl) {
    textEl.textContent = `₩${formatNumber(budget.used || 0)} / ₩${formatNumber(budget.budget || 0)}`;
  }
  
  if (percentEl) {
    percentEl.textContent = (budget.percentage || 0) + '%';
  }
}

// formatNumber 함수가 없다면 추가
if (typeof formatNumber === 'undefined') {
  window.formatNumber = function(num) {
    return (num || 0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  };
}

function displayTrendingProducts(trending) {
  const upContainer = document.getElementById('trending-up');
  if (trending.trendingUp && trending.trendingUp.length > 0) {
    upContainer.innerHTML = trending.trendingUp.map(product => `
      <div class="trend-item">
        ${product.name}
        <span class="trend-rate up">+${product.changeRate}%</span>
      </div>
    `).join('');
  } else {
    upContainer.innerHTML = '<div class="empty-state">급상승 상품이 없습니다.</div>';
  }
  
  const downContainer = document.getElementById('trending-down');
  if (trending.trendingDown && trending.trendingDown.length > 0) {
    downContainer.innerHTML = trending.trendingDown.map(product => `
      <div class="trend-item">
        ${product.name}
        <span class="trend-rate down">${product.changeRate}%</span>
      </div>
    `).join('');
  } else {
    downContainer.innerHTML = '<div class="empty-state">급하락 상품이 없습니다.</div>';
  }
}

// ===== 26. 자주발주 기능 =====
function loadFrequentItems() {
  showLoading('자주 발주 상품을 불러오는 중...');
  
  google.script.run
    .withSuccessHandler(function(items) {
      hideLoading(); // showSaveIndicator 대신 hideLoading 사용
      displayFrequentItems(items);
    })
    .withFailureHandler(function(error) {
      hideLoading(); // showSaveIndicator 대신 hideLoading 사용
      showError('자주 발주 상품 로드 실패: ' + error);
    })
    .getFrequentItems();
}

function refreshFrequentItems() {
  showLoading('자주 발주 목록을 갱신하는 중...');
  
  // 서버의 캐시를 갱신하고 다시 로드
  google.script.run
    .withSuccessHandler(function(items) {
      hideLoading();
      // 갱신된 데이터를 바로 표시
      displayFrequentItems(items);
      showQuickSuccess('자주 발주 목록이 갱신되었습니다.');
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('자주 발주 상품 갱신 실패: ' + error);
    })
    .refreshFrequentItemsCache();
}

function displayFrequentItems(items) {
  const container = document.getElementById('frequent-list');
  
  if (!container) {
    console.error('frequent-list 컨테이너를 찾을 수 없습니다.');
    return;
  }
  
  if (!items || items.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-icon">📊</div>
        <h3>자주 발주하는 상품이 없습니다</h3>
        <p>최근 3개월간 3회 이상 발주한 상품이 없습니다.</p>
      </div>
    `;
    updateFrequentStats(0, 0, 0);
    return;
  }
  
  const today = new Date();
  const totalItems = items.length;
  
  const needOrderItems = items.filter(item => {
    if (!item.lastOrder) return true;
    const lastOrderDate = new Date(item.lastOrder);
    const daysSinceLastOrder = Math.floor((today - lastOrderDate) / (1000 * 60 * 60 * 24));
    return daysSinceLastOrder > 14;
  }).length;
  
  const thisMonthItems = items.filter(item => {
    if (!item.lastOrder) return false;
    const lastOrderDate = new Date(item.lastOrder);
    return lastOrderDate.getMonth() === today.getMonth() && 
           lastOrderDate.getFullYear() === today.getFullYear();
  }).length;
  
  updateFrequentStats(totalItems, needOrderItems, thisMonthItems);
  
  let html = '';
  
  items.forEach((item, index) => {
    let daysSinceLastOrder = 0;
    let statusClass = '';
    let statusIcon = '';
    
    if (item.lastOrder) {
      const lastOrderDate = new Date(item.lastOrder);
      daysSinceLastOrder = Math.floor((today - lastOrderDate) / (1000 * 60 * 60 * 24));
      
      if (daysSinceLastOrder > 30) {
        statusClass = 'need-urgent';
        statusIcon = '🔴';
      } else if (daysSinceLastOrder > 14) {
        statusClass = 'need-check';
        statusIcon = '🟡';
      } else {
        statusClass = 'ok';
        statusIcon = '🟢';
      }
    } else {
      statusClass = 'need-urgent';
      statusIcon = '🔴';
    }
    
    html += `
      <div class="frequent-simple-item ${statusClass}">
        <div class="item-number">${index + 1}</div>
        
        <div class="item-main">
          <div class="item-title">
            <span class="item-status">${statusIcon}</span>
            <span class="item-name">${item.productName}</span>
            ${item.option ? `<span class="item-option">${item.option}</span>` : ''}
          </div>
          
          <div class="item-stats">
            <span class="stat">발주 ${item.orderCount}회</span>
            <span class="stat">평균 ${item.avgQuantity}개</span>
            <span class="stat">주기 ${item.avgCycle}</span>
            <span class="stat last-order">${daysSinceLastOrder}일 전</span>
          </div>
        </div>
        
        <div class="item-action">
          <input type="number" 
                 id="qty-${item.barcode}" 
                 class="quick-qty-input" 
                 value="${item.avgQuantity}"
                 min="1">
          <button class="btn btn-primary btn-sm" 
                  onclick="quickAddFromFrequent('${item.barcode}')">
            발주 추가
          </button>
        </div>
      </div>
    `;
  });
  
  container.innerHTML = html;
}

function updateFrequentStats(total, needOrder, thisMonth) {
  const totalEl = document.getElementById('total-frequent');
  const needOrderEl = document.getElementById('need-order');
  const thisMonthEl = document.getElementById('this-month');
  
  if (totalEl) totalEl.textContent = total;
  if (needOrderEl) needOrderEl.textContent = needOrder;
  if (thisMonthEl) thisMonthEl.textContent = thisMonth;
}

function quickAddFromFrequent(barcode) {
  if (!AppState.currentOrderInfo) {
    if (confirm('발주서가 없습니다. 새로 생성하시겠습니까?')) {
      showCreateOrderModal();
    }
    return;
  }
  
  const qtyInput = document.getElementById(`qty-${barcode}`);
  if (!qtyInput) {
    showError('수량 입력 필드를 찾을 수 없습니다.');
    return;
  }
  
  const quantity = parseInt(qtyInput.value) || 1;
  
  showLoading();
  
  google.script.run
    .withSuccessHandler(function(product) {
      hideLoading();
      
      if (product) {
        const existingItem = AppState.orderItems.find(item => 
          item.barcode === barcode && item.status !== '확정'
        );
        
        if (existingItem) {
          existingItem.quantity += quantity;
          showQuickSuccess(`수량이 ${existingItem.quantity}개로 증가되었습니다.`);
        } else {
          const newItem = {
            ...product,
            quantity: 1,
            priority: 3,  // 기본값 3 (낮음/여유있음)
            comment: '',
            status: '대기',
            id: Date.now() + Math.random(),
            confirmedAt: null,
            stockAvailable: '미확인'
          };
          
          AppState.orderItems.push(newItem);
          showQuickSuccess(`${product.name} ${quantity}개가 추가되었습니다.`);
        }
        
        updateOrderList();
        scheduleAutoSave();
        
        const btn = event.target;
        if (btn) {
          const originalText = btn.textContent;
          btn.textContent = '추가됨';
          btn.classList.add('added');
          setTimeout(() => {
            btn.textContent = originalText;
            btn.classList.remove('added');
          }, 2000);
        }
      } else {
        showError('상품 정보를 찾을 수 없습니다.');
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('상품 추가 실패: ' + error);
    })
    .getProductDetails(barcode);
}

// ===== 27. 제품 이슈사항 기능 =====
function openProductIssueModal(barcode = null) {
  let product = null;
  if (barcode) {
    product = AppState.products.find(p => p.barcode === barcode);
  }
  
  const modalContent = `
    <h3>${product ? '제품 이슈사항 수정' : '제품 이슈사항 추가'}</h3>
    <div class="issue-form">
      ${!product ? `
        <div class="form-group">
          <label>제품 검색</label>
          <div class="product-search-wrapper">
            <input type="text" 
                   id="issue-product-search" 
                   class="form-input" 
                   placeholder="상품명 또는 바코드로 검색..."
                   autocomplete="off">
            <div id="issue-search-results" class="issue-search-results"></div>
          </div>
          <input type="hidden" id="selected-barcode" value="">
          <div id="selected-product-info" class="selected-product-info" style="display:none;"></div>
        </div>
      ` : `
        <div class="form-group">
          <label>상품정보</label>
          <div class="product-info-display">
            <strong>${product.name}</strong><br>
            <span class="text-muted">${product.barcode} | ${product.supplierName || ''}</span>
          </div>
        </div>
      `}
      
      <div class="form-group">
        <label>메모 (상태)</label>
        <select id="issue-memo" class="form-input">
          <option value="">선택하세요</option>
          <option value="품절" ${product && AppState.productIssues[product.barcode]?.memo === '품절' ? 'selected' : ''}>품절</option>
          <option value="오더중" ${product && AppState.productIssues[product.barcode]?.memo === '오더중' ? 'selected' : ''}>오더중</option>
          <option value="기타" ${product && AppState.productIssues[product.barcode]?.memo === '기타' ? 'selected' : ''}>기타</option>
        </select>
      </div>
      
      <div class="form-group">
        <label>비고 (상세정보)</label>
        <textarea id="issue-remarks" class="form-input" rows="3" placeholder="상세 정보를 입력하세요">${product && AppState.productIssues[product.barcode]?.remarks || ''}</textarea>
      </div>
      
      <div class="modal-actions">
        <button class="btn btn-primary" onclick="saveProductIssue('${barcode || ''}')">저장</button>
        ${product && AppState.productIssues[product.barcode] ? 
          `<button class="btn btn-danger" onclick="deleteProductIssue('${barcode}')">삭제</button>` : 
          ''
        }
        <button class="btn btn-secondary" onclick="closeModal()">취소</button>
      </div>
    </div>
  `;
  
  showModal(modalContent);
  
  // 검색 입력 필드에 이벤트 리스너 추가
  if (!product) {
    setTimeout(() => {
      const searchInput = document.getElementById('issue-product-search');
      if (searchInput) {
        searchInput.addEventListener('input', function(e) {
          searchProductsForIssue(e.target.value);
        });
        searchInput.focus();
      }
    }, 100);
  }
}

function searchProductsForIssue(query) {
  const resultsContainer = document.getElementById('issue-search-results');
  
  if (!query || query.trim().length < 2) {
    resultsContainer.style.display = 'none';
    resultsContainer.innerHTML = '';
    return;
  }
  
  // 기존 타이머 취소
  if (AppState.timers.issue) {
    clearTimeout(AppState.timers.issue);
  }
  
  const searchLower = query.toLowerCase().trim();
  
  // 로컬 검색
  const localResults = AppState.products.filter(product => {
    if (!product) return false;
    
    const barcode = (product.barcode || '').toLowerCase();
    const name = (product.name || '').toLowerCase();
    const option = (product.option || '').toLowerCase();
    const searchText = product.searchText || `${barcode} ${name} ${option}`;
    
    return searchText.includes(searchLower) || 
           barcode.includes(searchLower) ||
           name.includes(searchLower) ||
           option.includes(searchLower);
  }).slice(0, 10);
  
  // 결과 표시
  if (localResults.length > 0) {
    displayIssueSearchResults(localResults, false);
  } else {
    resultsContainer.innerHTML = '<div class="searching-message">검색 중...</div>';
    resultsContainer.style.display = 'block';
  }
  
  // 서버 검색 (디바운스)
  if (localResults.length < 5) {
    AppState.timers.issue = setTimeout(() => {
      searchAllProductsForIssue(query, localResults);
    }, 500);
  }
}

function searchAllProductsForIssue(query, existingResults = []) {
  google.script.run
    .withSuccessHandler(function(serverResults) {
      if (!serverResults || serverResults.length === 0) {
        if (existingResults.length === 0) {
          const container = document.getElementById('issue-search-results');
          container.innerHTML = '<div class="no-results">검색 결과가 없습니다</div>';
        }
        return;
      }
      
      const existingBarcodes = new Set(existingResults.map(p => p.barcode));
      const newResults = serverResults.filter(p => !existingBarcodes.has(p.barcode));
      const combinedResults = [...existingResults, ...newResults].slice(0, 15);
      displayIssueSearchResults(combinedResults, true);
    })
    .withFailureHandler(function(error) {
      console.error('전체 검색 실패:', error);
      if (existingResults.length === 0) {
        const container = document.getElementById('issue-search-results');
        container.innerHTML = '<div class="no-results">검색 중 오류가 발생했습니다</div>';
      }
    })
    .searchAllProducts(query, 10);
}

function displayIssueSearchResults(results, showSource = false) {
  const container = document.getElementById('issue-search-results');
  
  if (!container) {
    console.error('issue-search-results 컨테이너를 찾을 수 없습니다.');
    return;
  }
  
  if (results.length === 0) {
    container.innerHTML = '<div class="no-results">검색 결과가 없습니다</div>';
    container.style.display = 'block';
    return;
  }
  
  container.innerHTML = results.map(product => {
    if (!product) return '';
    
    const barcode = product.barcode || '';
    const name = product.name || '이름 없음';
    const option = product.option || '';
    const supplier = product.supplierName || product.supplier || '';
    
    const hasIssue = AppState.productIssues[barcode] || 
                     (product.issueMemo || product.issueRemarks);
    
    const sourceTag = showSource && product.isServerResult ? 
      '<span class="source-tag">전체</span>' : 
      '<span class="source-tag cached">캐시</span>';
    
    return `
      <div class="issue-search-item ${hasIssue ? 'has-issue' : ''}" 
           onclick="selectProductForIssue('${barcode}')"
           data-barcode="${barcode}">
        <div class="search-item-header">
          <div class="search-item-name">${name}</div>
          ${hasIssue ? '<span class="has-issue-badge">⚠️ 이슈</span>' : ''}
        </div>
        <div class="search-item-details">
          ${option ? `${option} | ` : ''}
          ${barcode} 
          ${supplier ? `| ${supplier}` : ''}
          ${showSource ? sourceTag : ''}
        </div>
      </div>
    `;
  }).filter(html => html).join('');
  
  container.style.display = 'block';
}

function selectProductForIssue(barcode) {
  let product = AppState.products.find(p => p.barcode === barcode);
  
  if (!product) {
    showSaveIndicator('loading');
    
    google.script.run
      .withSuccessHandler(function(details) {
        showSaveIndicator('hide');
        
        if (details) {
          displaySelectedProduct(details, barcode);
        } else {
          showError('상품 정보를 찾을 수 없습니다.');
        }
      })
      .withFailureHandler(function(error) {
        showSaveIndicator('hide');
        showError('상품 정보 로드 실패: ' + error);
      })
      .getProductDetails(barcode);
  } else {
    displaySelectedProduct(product, barcode);
  }
}

function displaySelectedProduct(product, barcode) {
  document.getElementById('selected-barcode').value = barcode;
  document.getElementById('issue-search-results').style.display = 'none';
  document.getElementById('issue-product-search').value = '';
  
  const infoContainer = document.getElementById('selected-product-info');
  infoContainer.innerHTML = `
    <div class="selected-product">
      <strong>${product.name}</strong><br>
      <span class="text-muted">${product.barcode} | ${product.supplierName || ''}</span>
      <button class="btn-sm btn-secondary" onclick="resetProductSelection()">다시 선택</button>
    </div>
  `;
  infoContainer.style.display = 'block';
  
  if (AppState.productIssues[barcode]) {
    document.getElementById('issue-memo').value = AppState.productIssues[barcode].memo || '';
    document.getElementById('issue-remarks').value = AppState.productIssues[barcode].remarks || '';
  }
}

function resetProductSelection() {
  document.getElementById('selected-barcode').value = '';
  document.getElementById('selected-product-info').style.display = 'none';
  document.getElementById('issue-product-search').value = '';
  document.getElementById('issue-memo').value = '';
  document.getElementById('issue-remarks').value = '';
}

function saveProductIssue(barcode) {
  let targetBarcode = barcode;
  let product = null;
  
  if (!barcode) {
    targetBarcode = document.getElementById('selected-barcode').value;
    if (!targetBarcode) {
      showError('제품을 선택해주세요.');
      return;
    }
    product = AppState.products.find(p => p.barcode === targetBarcode);
  } else {
    product = AppState.products.find(p => p.barcode === targetBarcode);
  }
  
  const memo = document.getElementById('issue-memo').value;
  const remarks = document.getElementById('issue-remarks').value.trim();
  
  if (!memo && !remarks) {
    showError('메모 또는 비고를 입력해주세요.');
    return;
  }
  
  showSaveIndicator('saving');
  
  const issueData = {
    barcode: targetBarcode,
    productName: product?.name || '',
    option: product?.option || '',
    supplierName: product?.supplierName || '',
    memo: memo,
    remarks: remarks
  };
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        AppState.productIssues[targetBarcode] = {
          memo: memo,
          remarks: remarks
        };
        
        if (product) {
          product.issueMemo = memo;
          product.issueRemarks = remarks;
        }
        
        const searchInput = document.getElementById('search-input').value;
        if (searchInput) {
          performSearch();
        }
        
        closeModal();
        showQuickSuccess(result.message);
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('저장 실패: ' + error);
    })
    .updateProductIssue(issueData);
}

function deleteProductIssue(barcode) {
  if (!confirm('정말 이슈사항을 삭제하시겠습니까?')) {
    return;
  }
  
  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        delete AppState.productIssues[barcode];
        
        const product = AppState.products.find(p => p.barcode === barcode);
        if (product) {
          delete product.issueMemo;
          delete product.issueRemarks;
        }
        
        const searchInput = document.getElementById('search-input').value;
        if (searchInput) {
          performSearch();
        }
        
        closeModal();
        showQuickSuccess(result.message);
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('삭제 실패: ' + error);
    })
    .deleteProductIssue(barcode);
}

// ===== 28. 안전재고 기능 =====
function loadSafetyStockTab() {
  const container = document.getElementById('safety-stock-list');
  
  if (container.dataset.loading === 'true') {
    return;
  }
  
  if (cache.safetyStockCache && cache.safetyStockCacheTime) {
    const now = new Date();
    const cacheAge = (now - cache.safetyStockCacheTime) / 1000 / 60;
    
    if (cacheAge < 5 && cache.safetyStockCache.length > 0) {
      displaySafetyStockList(cache.safetyStockCache);
      return;
    }
  }
  
  container.dataset.loading = 'true';
  container.innerHTML = `
    <div class="loading-container">
      <div class="loading-spinner-small"></div>
      <p>안전재고 목록을 불러오는 중...</p>
    </div>
  `;
  
  google.script.run
    .withSuccessHandler(function(list) {
      container.dataset.loading = 'false';
      
      const safeList = list || [];
      cache.safetyStockCache = safeList;
      cache.safetyStockCacheTime = new Date();
      
      displaySafetyStockList(safeList);
      AppState.safetyStockCache = safeList;
    })
    .withFailureHandler(function(error) {
      container.dataset.loading = 'false';
      container.innerHTML = `
        <div class="error-state">
          <div class="error-icon">❌</div>
          <h3>로드 실패</h3>
          <p>${error}</p>
          <button class="btn btn-primary" onclick="loadSafetyStockTab()">다시 시도</button>
        </div>
      `;
    })
    .getSafetyStockList();
}

function displaySafetyStockList(list) {
  const container = document.getElementById('safety-stock-list');
  
  if (!list || !Array.isArray(list)) {
    list = [];
  }
  
  if (list.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-icon">📦</div>
        <h3>안전재고가 설정되지 않았습니다</h3>
        <p>상품별 안전재고를 설정하여 재고 부족을 예방하세요</p>
        <button class="btn btn-primary" onclick="showAddSafetyStockModal()">
          첫 안전재고 추가하기
        </button>
      </div>
    `;
    return;
  }
  
  const totalItems = list.length;
  const percentageItems = list.filter(item => item.type === 'percentage').length;
  const quantityItems = list.filter(item => item.type === 'quantity').length;
  
  container.innerHTML = `
    <div class="safety-stock-stats">
      <div class="stat-card">
        <div class="stat-value">${totalItems}</div>
        <div class="stat-label">전체 설정</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${quantityItems}</div>
        <div class="stat-label">수량 기준</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${percentageItems}</div>
        <div class="stat-label">퍼센트 기준</div>
      </div>
    </div>
    
    <div class="safety-stock-grid">
      ${list.map(item => {
        const typeIcon = item.type === 'percentage' ? '%' : '개';
        const typeClass = item.type === 'percentage' ? 'type-percent' : 'type-quantity';
        
        return `
          <div class="safety-stock-card">
            <div class="card-header">
              <h4>${item.productName}</h4>
              <span class="safety-type-badge ${typeClass}">
                ${item.value}${typeIcon}
              </span>
            </div>
            
            <div class="card-body">
              <div class="product-details">
                <span class="barcode">${item.barcode}</span>
                ${item.option ? `<span class="option">${item.option}</span>` : ''}
              </div>
              
              <div class="safety-info">
                <div class="info-item">
                  <span class="info-label">안전재고:</span>
                  <span class="info-value">${item.type === 'percentage' ? '현재고의 ' : ''}${item.value}${typeIcon}</span>
                </div>
                <div class="info-item">
                  <span class="info-label">등록일:</span>
                  <span class="info-value">${formatDate(item.registeredAt)}</span>
                </div>
              </div>
            </div>
            
            <div class="card-actions">
              <button class="btn-icon" onclick="editSafetyStock('${item.barcode}')" title="수정">
                <span>✏️</span>
              </button>
              <button class="btn-icon danger" onclick="deleteSafetyStock('${item.barcode}')" title="삭제">
                <span>🗑️</span>
              </button>
            </div>
          </div>
        `;
      }).join('')}
    </div>
  `;
}

function formatDate(dateValue) {
  if (!dateValue) return '';
  
  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (isNaN(date.getTime())) return '';
  
  return date.toLocaleDateString('ko-KR') + ' ' + date.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
}

function searchSafetyStockItems(query) {
  if (!AppState.safetyStockCache || !Array.isArray(AppState.safetyStockCache)) {
    AppState.safetyStockCache = [];
  }
  
  if (!query || query.trim().length < 1) {
    displaySafetyStockList(AppState.safetyStockCache);
    return;
  }
  
  const searchLower = query.toLowerCase();
  const filtered = AppState.safetyStockCache.filter(item => {
    if (!item) return false;
    
    const barcode = (item.barcode || '').toLowerCase();
    const productName = (item.productName || '').toLowerCase();
    const option = (item.option || '').toLowerCase();
    
    return barcode.includes(searchLower) ||
           productName.includes(searchLower) ||
           option.includes(searchLower);
  });
  
  displaySafetyStockList(filtered);
  
  if (filtered.length === 0) {
    const container = document.getElementById('safety-stock-list');
    container.innerHTML = `
      <div class="no-search-results">
        <div class="no-results-icon">🔍</div>
        <h3>검색 결과가 없습니다</h3>
        <p>"${query}"에 대한 안전재고 설정을 찾을 수 없습니다</p>
        <button class="btn btn-secondary" onclick="document.getElementById('safety-stock-search').value=''; loadSafetyStockTab();">
          전체 보기
        </button>
      </div>
    `;
  }
}

function showAddSafetyStockModal() {
  resetSafetyStockModal();
  document.getElementById('safety-stock-modal').style.display = 'block';
}

function editSafetyStock(barcode) {
  showSaveIndicator('loading');
  
  google.script.run
    .withSuccessHandler(function(item) {
      showSaveIndicator('hide');
      
      if (!item) {
        showError('안전재고 정보를 찾을 수 없습니다.');
        return;
      }
      
      showAddSafetyStockModal();
      
      const selectedProduct = document.getElementById('selected-safety-product');
      selectedProduct.innerHTML = `
        <div class="selected-product">
          <strong>${item.productName}</strong><br>
          <span class="text-muted">${item.barcode} | ${item.option || ''}</span>
        </div>
      `;
      selectedProduct.style.display = 'block';
      selectedProduct.dataset.barcode = item.barcode;
      selectedProduct.dataset.productName = item.productName;
      selectedProduct.dataset.option = item.option || '';
      
      document.getElementById('safety-product-search').value = '';
      document.getElementById('safety-search-results').style.display = 'none';
      
      document.querySelector(`input[name="safetyType"][value="${item.type}"]`).checked = true;
      document.getElementById('safety-value').value = item.value;
      toggleSafetyInput();
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('안전재고 정보 로드 실패: ' + error);
    })
    .getSafetyStockForBarcode(barcode);
}

function toggleSafetyInput() {
  const type = document.querySelector('input[name="safetyType"]:checked').value;
  const unit = document.getElementById('safety-unit');
  const input = document.getElementById('safety-value');
  
  if (type === 'percentage') {
    unit.textContent = '%';
    input.max = 100;
    input.placeholder = '0-100';
  } else {
    unit.textContent = '개';
    input.max = '';
    input.placeholder = '수량 입력';
  }
}

function searchProductsForSafety(query) {
  if (!query || query.trim().length < 2) {
    document.getElementById('safety-search-results').style.display = 'none';
    return;
  }
  
  const searchLower = query.toLowerCase();
  
  let results = [];
  
  if (AppState.products && AppState.products.length > 0) {
    results = AppState.products.filter(product => {
      if (!product) return false;
      
      if (product.searchText && product.searchText.includes(searchLower)) {
        return true;
      }
      
      const barcode = product.barcode || '';
      const name = product.name || '';
      const option = product.option || '';
      
      return barcode.toLowerCase().includes(searchLower) ||
             name.toLowerCase().includes(searchLower) ||
             option.toLowerCase().includes(searchLower);
    }).slice(0, 10);
  }
  
  if (results.length < 5) {
    const container = document.getElementById('safety-search-results');
    container.innerHTML = results.length > 0 ? 
      results.map(p => createSafetySearchItem(p)).join('') + 
      '<div class="searching-more">추가 검색 중...</div>' :
      '<div class="searching-message">검색 중...</div>';
    container.style.display = 'block';
    
    clearTimeout(AppState.timers.safetySearch);
    AppState.timers.safetySearch = setTimeout(() => {
      google.script.run
        .withSuccessHandler(function(serverResults) {
          if (!serverResults || !Array.isArray(serverResults)) {
            if (results.length > 0) {
              displaySafetySearchResults(results);
            }
            return;
          }
          
          const existingBarcodes = new Set(results.map(p => p.barcode));
          const newResults = serverResults.filter(p => {
            return p && p.barcode && !existingBarcodes.has(p.barcode);
          });
          
          const combinedResults = [...results, ...newResults].slice(0, 15);
          displaySafetySearchResults(combinedResults);
        })
        .withFailureHandler(function(error) {
          console.error('서버 검색 실패:', error);
          if (results.length > 0) {
            displaySafetySearchResults(results);
          } else {
            container.innerHTML = '<div class="no-results">검색 중 오류가 발생했습니다</div>';
          }
        })
        .searchAllProducts(query, 10);
    }, 300);
  } else {
    displaySafetySearchResults(results);
  }
}

function createSafetySearchItem(product) {
  if (!product) return '';
  
  const name = product.name || '이름 없음';
  const option = product.option || '';
  const barcode = product.barcode || '';
  
  return `
    <div class="safety-search-item" onclick="selectProductForSafety('${barcode}')">
      <div>${name}</div>
      <div class="search-item-details">
        ${option ? option + ' | ' : ''}${barcode}
      </div>
    </div>
  `;
}

function selectProductForSafety(barcode) {
  if (!barcode) {
    showError('바코드가 없습니다.');
    return;
  }
  
  const product = AppState.products.find(p => p && p.barcode === barcode);
  
  if (!product) {
    showSaveIndicator('loading');
    
    google.script.run
      .withSuccessHandler(function(details) {
        showSaveIndicator('hide');
        
        if (details) {
          displaySelectedSafetyProduct(details);
        } else {
          showError('상품 정보를 찾을 수 없습니다.');
        }
      })
      .withFailureHandler(function(error) {
        showSaveIndicator('hide');
        showError('상품 정보 로드 실패: ' + error);
      })
      .getProductDetails(barcode);
  } else {
    displaySelectedSafetyProduct(product);
  }
}

function displaySelectedSafetyProduct(product) {
  const name = product.name || '이름 없음';
  const barcode = product.barcode || '';
  const option = product.option || '';
  
  document.getElementById('selected-safety-product').innerHTML = `
    <div class="selected-product">
      <strong>${name}</strong><br>
      <span class="text-muted">${barcode} | ${option}</span>
    </div>
  `;
  document.getElementById('selected-safety-product').style.display = 'block';
  document.getElementById('selected-safety-product').dataset.barcode = barcode;
  document.getElementById('selected-safety-product').dataset.productName = name;
  document.getElementById('selected-safety-product').dataset.option = option;
  
  document.getElementById('safety-product-search').value = '';
  document.getElementById('safety-search-results').style.display = 'none';
}

function saveSafetyStock() {
  const selectedProduct = document.getElementById('selected-safety-product');
  if (!selectedProduct.dataset.barcode) {
    showError('제품을 선택해주세요.');
    return;
  }
  
  const type = document.querySelector('input[name="safetyType"]:checked').value;
  const value = document.getElementById('safety-value').value;
  
  if (!value || value < 0) {
    showError('안전재고 값을 입력해주세요.');
    return;
  }
  
  if (type === 'percentage' && value > 100) {
    showError('퍼센트는 100 이하로 입력해주세요.');
    return;
  }
  
  const safetyStockData = {
    barcode: selectedProduct.dataset.barcode,
    productName: selectedProduct.dataset.productName,
    option: selectedProduct.dataset.option,
    type: type,
    value: Number(value)
  };
  
  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        closeModal('safety-stock-modal');
        showQuickSuccess(result.message);
        loadSafetyStockTab();
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('저장 실패: ' + error);
    })
    .saveSafetyStock(safetyStockData);
}

function deleteSafetyStock(barcode) {
  if (!confirm('정말 삭제하시겠습니까?')) return;
  
  showSaveIndicator('loading');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        showQuickSuccess(result.message);
        loadSafetyStockTab();
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('삭제 실패: ' + error);
    })
    .deleteSafetyStock(barcode);
}

function resetSafetyStockModal() {
  document.getElementById('safety-product-search').value = '';
  document.getElementById('safety-search-results').style.display = 'none';
  document.getElementById('selected-safety-product').style.display = 'none';
  document.getElementById('selected-safety-product').innerHTML = '';
  document.querySelector('input[value="quantity"]').checked = true;
  document.getElementById('safety-value').value = '';
  toggleSafetyInput();
}

// ===== 29. CSV 업로드/내보내기 기능 =====
function showStockUploadModal() {
  if (!AppState.currentOrderInfo) {
    showError('먼저 발주서를 생성해주세요.');
    return;
  }
  
  document.getElementById('stock-upload-modal').style.display = 'block';
  setupDropZone();
}

function setupDropZone() {
  const dropZone = document.getElementById('csv-drop-zone');
  const fileInput = document.getElementById('csv-file-input');
  
  if (dropZone.dataset.initialized === 'true') return;
  dropZone.dataset.initialized = 'true';
  
  dropZone.addEventListener('click', () => fileInput.click());
  
  dropZone.addEventListener('dragover', (e) => {
    e.preventDefault();
    dropZone.classList.add('drag-over');
  });
  
  dropZone.addEventListener('dragleave', () => {
    dropZone.classList.remove('drag-over');
  });
  
  dropZone.addEventListener('drop', (e) => {
    e.preventDefault();
    dropZone.classList.remove('drag-over');
    
    const file = e.dataTransfer.files[0];
    if (file && file.type === 'text/csv') {
      handleCSVFile(file);
    } else {
      showError('CSV 파일만 업로드 가능합니다.');
    }
  });
  
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      handleCSVFile(file);
    }
  });
}

function handleCSVFile(file) {
  const reader = new FileReader();
  
  reader.onload = (e) => {
    AppState.uploadedCSVContent = e.target.result;
    
    // CSV 미리보기
    const lines = e.target.result.split(/\r?\n/);
    console.log('업로드된 CSV 라인 수:', lines.length);
    console.log('첫 5줄:', lines.slice(0, 5));
    
    const dropZone = document.getElementById('csv-drop-zone');
    dropZone.innerHTML = `
      <div class="upload-success">
        <span class="success-icon">✅</span>
        <p>${file.name}</p>
        <small>${(file.size / 1024).toFixed(2)} KB</small>
      </div>
    `;
    
    document.getElementById('process-csv-btn').disabled = false;
  };
  
  reader.onerror = (e) => {
    console.error('파일 읽기 에러:', e);
    showError('파일을 읽을 수 없습니다.');
  };
  
  // UTF-8로 읽기 (한글 지원)
  reader.readAsText(file, 'UTF-8');
}

function processCSVUpload() {
  if (!AppState.uploadedCSVContent) {
    showError('CSV 파일을 먼저 업로드해주세요.');
    return;
  }
  
  const updateType = document.querySelector('input[name="updateType"]:checked').value;
  
  // 모달 닫고 로딩 표시
  closeModal('stock-upload-modal');
  showLoading('재고 데이터 처리 중...');
  
  google.script.run
    .withSuccessHandler(function(result) {
      if (result.success) {
        showQuickSuccess(`${result.itemCount}개 재고 정보가 업로드되었습니다.`);
        
        // 재고 데이터 로드 후 발주 항목 업데이트
        updateLoadingMessage('재고 정보를 적용하는 중...');
        
        // 발주 항목의 재고 상태 업데이트
        updateOrderItemsWithStockBatch(updateType);
      } else {
        hideLoading();
        showError('CSV 처리 실패: ' + (result.error || '알 수 없는 오류'));
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('업로드 실패: ' + error);
    })
    .processStockCSV(AppState.uploadedCSVContent, updateType);
}

// 서버에서 재고 데이터 로드
async function loadStockDataFromServer() {
  return new Promise((resolve, reject) => {
    google.script.run
      .withSuccessHandler(function(result) {
        if (result && result.data) {
          AppState.stockData = result.data;
          AppState.stockDataTimestamp = result.updatedAt;
          console.log('재고 데이터 로드 완료:', Object.keys(result.data).length);
          resolve(result);
        } else {
          resolve(null);
        }
      })
      .withFailureHandler(reject)
      .loadSavedStockData();
  });
}

function updateOrderItemsWithStockBatch(updateType) {
  const itemsToUpdate = AppState.orderItems.filter(item => {
    // 내보내기된 항목은 제외
    if (item.exportedAt || item.exportStatus) return false;
    
    if (updateType === 'confirmed' && item.status !== '확정') return false;
    if (updateType === 'unconfirmed' && item.status === '확정') return false;
    return true;
  });
  
  if (itemsToUpdate.length === 0) {
    hideLoading();
    showInfo('업데이트할 항목이 없습니다.');
    return;
  }
  
  let processed = 0;
  updateLoadingMessage(`재고 정보 적용 중... (0/${itemsToUpdate.length})`);
  
  // 서버에 일괄 업데이트 요청
  google.script.run
    .withSuccessHandler(function(results) {
      // 결과를 로컬 데이터에 반영
      results.forEach(result => {
        const item = AppState.orderItems.find(i => i.id === result.id);
        if (item) {
          item.stockAvailable = result.stockStatus.message;
          item.stockStatus = result.stockStatus.status;
          item.csvConfirmed = true; // CSV 확인 플래그 추가
        }
      });
      
      // UI 업데이트
      updateOrderList();
      hideLoading();
      showQuickSuccess(`${results.length}개 항목의 재고가 업데이트되었습니다.`);
      
      // 자동 저장
      scheduleAutoSave();
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('재고 업데이트 실패: ' + error);
    })
    .updateOrderItemsStock(itemsToUpdate, updateType);
}

function updateOrderItemsWithStockFromServer(updateType) {
  const itemsToUpdate = AppState.orderItems.filter(item => {
    if (updateType === 'confirmed' && item.status !== '확정') return false;
    if (updateType === 'unconfirmed' && item.status === '확정') return false;
    return true;
  });
  
  if (itemsToUpdate.length === 0) {
    showInfo('업데이트할 항목이 없습니다.');
    return;
  }
  
  showProgress(`재고 정보 업데이트 중... (0/${itemsToUpdate.length})`);
  let processed = 0;
  
  const BATCH_SIZE = 10;
  const batches = [];
  
  for (let i = 0; i < itemsToUpdate.length; i += BATCH_SIZE) {
    batches.push(itemsToUpdate.slice(i, i + BATCH_SIZE));
  }
  
  function processBatch(batchIndex) {
    if (batchIndex >= batches.length) {
      hideProgress();
      updateOrderList();
      scheduleAutoSave();
      return;
    }
    
    const batch = batches[batchIndex];
    const promises = batch.map(item => {
      return new Promise((resolve) => {
        google.script.run
          .withSuccessHandler(function(result) {
            item.stockAvailable = result.message;
            item.stockStatus = result.status;
            processed++;
            updateProgress(`재고 정보 업데이트 중... (${processed}/${itemsToUpdate.length})`);
            resolve();
          })
          .withFailureHandler(function() {
            item.stockAvailable = '확인 실패';
            item.stockStatus = 'error';
            processed++;
            updateProgress(`재고 정보 업데이트 중... (${processed}/${itemsToUpdate.length})`);
            resolve();
          })
          .calculateStockAvailability(item.barcode, item.quantity);
      });
    });
    
    Promise.all(promises).then(() => {
      processBatch(batchIndex + 1);
    });
  }
  
  processBatch(0);
}

function showProgress(message) {
  let progress = document.getElementById('progress-indicator');
  if (!progress) {
    progress = document.createElement('div');
    progress.id = 'progress-indicator';
    progress.className = 'progress-indicator';
    document.body.appendChild(progress);
  }
  progress.textContent = message;
  progress.style.display = 'block';
}

function updateProgress(message) {
  const progress = document.getElementById('progress-indicator');
  if (progress) {
    progress.textContent = message;
  }
}

function hideProgress() {
  const progress = document.getElementById('progress-indicator');
  if (progress) {
    progress.style.display = 'none';
  }
}

function showInfo(message) {
  const existingToast = document.querySelector('.toast-message');
  if (existingToast) existingToast.remove();
  
  const toast = document.createElement('div');
  toast.className = 'toast-message info show';
  toast.textContent = message;
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 2000);
}

// ===== 30. CSV 내보내기 =====
function showExportModal() {
  if (!AppState.currentOrderInfo) {
    showError('발주서가 없습니다.');
    return;
  }
  
  if (AppState.orderItems.length === 0) {
    showError('내보낼 항목이 없습니다.');
    return;
  }
  
  document.getElementById('export-csv-modal').style.display = 'block';
  
  const checkedCount = document.querySelectorAll('.order-checkbox:checked').length;
  
  if (checkedCount > 0) {
    document.querySelector('input[name="exportType"][value="selected"]').checked = true;
  } else {
    document.querySelector('input[name="exportType"][value="all"]').checked = true;
  }
  
  document.getElementById('exclude-exported').checked = true;
  
  updateExportPreview();
  loadExportHistory();
}

function updateExportPreview() {
  const exportType = document.querySelector('input[name="exportType"]:checked').value;
  validateExportItems(exportType);
}

function validateExportItems(exportType) {
  const validationContainer = document.getElementById('export-validation');
  const previewContainer = document.getElementById('export-preview-content');
  
  previewContainer.innerHTML = `
    <div class="export-loading">
      <div class="loading-spinner-small"></div>
      <p>검증 중...</p>
    </div>
  `;
  
  let itemsToValidate = [];
  
  if (exportType === 'all') {
    itemsToValidate = AppState.orderItems;
  } else {
    const checkedBoxes = document.querySelectorAll('.order-checkbox:checked');
    
    checkedBoxes.forEach(checkbox => {
      const orderItem = checkbox.closest('.order-item');
      if (orderItem && orderItem.dataset.id) {
        const itemId = orderItem.dataset.id;
        const item = AppState.orderItems.find(i => String(i.id) === String(itemId));
        if (item) {
          itemsToValidate.push(item);
        }
      }
    });
  }
  
  if (itemsToValidate.length === 0) {
    validationContainer.innerHTML = `
      <div class="validation-error">
        <div class="validation-item">
          <span class="validation-icon">❌</span>
          <span>${exportType === 'selected' ? '선택된 항목이 없습니다.' : '내보낼 항목이 없습니다.'}</span>
        </div>
      </div>
    `;
    previewContainer.innerHTML = '<p style="text-align: center; color: #6c757d;">내보낼 항목이 없습니다.</p>';
    document.getElementById('proceed-export-btn').disabled = true;
    return;
  }
  
  const validation = performValidation(itemsToValidate);
  
  displayValidationResult(validation, validationContainer);
  displayExportPreview(validation, previewContainer);
  
  document.getElementById('proceed-export-btn').disabled = validation.exportableItems.length === 0;
}

function performValidation(items) {
  const excludeExported = document.getElementById('exclude-exported').checked;
  
  const result = {
    totalItems: items.length,
    confirmedItems: 0,
    unconfirmedItems: 0,
    withStockStatus: 0,
    withoutStockStatus: 0,
    exportableItems: [],
    excludedItems: [],
    alreadyExported: [],
    warnings: []
  };
  
  items.forEach(item => {
    // 이미 내보낸 항목 체크를 먼저 수행
    if (item.exportedAt) {
      result.alreadyExported.push(item);
      
      if (excludeExported) {
        result.excludedItems.push({
          item: item,
          reason: '이미 내보내기됨'
        });
        return; // 이 항목은 제외하고 다음으로
      }
    }
    
    // 확정 상태 체크
    if (item.status !== '확정') {
      result.unconfirmedItems++;
      result.excludedItems.push({
        item: item,
        reason: '미확정'
      });
      return;
    }
    
    result.confirmedItems++;
    
    // 재고 상태 체크
    if (!item.stockAvailable || item.stockAvailable === '미확인') {
      result.withoutStockStatus++;
      result.excludedItems.push({
        item: item,
        reason: '재고 미확인'
      });
      return;
    }
    
    result.withStockStatus++;
    
    const stockStatus = String(item.stockAvailable).toLowerCase();
    
    if (stockStatus === '품절' || stockStatus === '오더중') {
      result.excludedItems.push({
        item: item,
        reason: stockStatus
      });
      return;
    }
    
    // 재내보내기 경고 (이미 제외되지 않은 경우에만)
    if (!excludeExported && item.exportedAt) {
      result.warnings.push({
        item: item,
        warning: '재내보내기'
      });
    }
    
    // 내보낼 수량 계산
    let exportQuantity = item.quantity;
    if (stockStatus !== '가능') {
      const match = stockStatus.match(/(\d+)개/);
      if (match) {
        exportQuantity = Math.min(parseInt(match[1]), item.quantity);
      }
    }
    
    result.exportableItems.push({
      ...item,
      exportQuantity: exportQuantity
    });
  });
  
  return result;
}

function displayValidationResult(validation, container) {
 let html = '';
 let validationClass = 'validation-success';
 
 const messages = [];
 
 if (validation.unconfirmedItems > 0) {
   messages.push({
     icon: '⚠️',
     text: `${validation.unconfirmedItems}개 항목이 미확정 상태입니다.`,
     type: 'warning'
   });
   validationClass = 'validation-warning';
 }
 
 if (validation.withoutStockStatus > 0) {
   messages.push({
     icon: '⚠️',
     text: `${validation.withoutStockStatus}개 항목의 재고가 확인되지 않았습니다.`,
     type: 'warning'
   });
   validationClass = 'validation-warning';
 }
 
 if (validation.alreadyExported.length > 0) {
   messages.push({
     icon: '⚠️',
     text: `${validation.alreadyExported.length}개 항목이 이미 내보내기되었습니다.`,
     type: 'warning'
   });
 }
 
 if (validation.exportableItems.length === 0) {
   messages.push({
     icon: '❌',
     text: '내보낼 수 있는 항목이 없습니다.',
     type: 'error'
   });
   validationClass = 'validation-error';
 } else {
   messages.push({
     icon: '✅',
     text: `${validation.exportableItems.length}개 항목을 내보낼 수 있습니다.`,
     type: 'success'
   });
 }
 
 html = `
   <div class="${validationClass}">
     ${messages.map(msg => `
       <div class="validation-item">
         <span class="validation-icon">${msg.icon}</span>
         <span>${msg.text}</span>
       </div>
     `).join('')}
   </div>
 `;
 
 container.innerHTML = html;
}

function displayExportPreview(validation, container) {
  if (validation.exportableItems.length === 0) {
    // 제외된 항목들의 이유를 집계
    let excludedReasons = {};
    validation.excludedItems.forEach(item => {
      if (!excludedReasons[item.reason]) {
        excludedReasons[item.reason] = 0;
      }
      excludedReasons[item.reason]++;
    });
    
    // 제외 이유별 표시
    let reasonsHtml = Object.entries(excludedReasons).map(([reason, count]) => {
      let icon = '❌';
      switch(reason) {
        case '미확정': icon = '⏸️'; break;
        case '재고 미확인': icon = '❓'; break;
        case '품절': icon = '🚫'; break;
        case '오더중': icon = '⏳'; break;
        case '이미 내보내기됨': icon = '✅'; break;
      }
      return `<li>${icon} ${reason}: ${count}개</li>`;
    }).join('');
    
    container.innerHTML = `
      <div style="text-align: center; color: #6c757d;">
        <p style="font-size: 16px; font-weight: 500; color: #dc3545;">내보낼 항목이 없습니다.</p>
        ${reasonsHtml ? `
          <div style="margin-top: 15px;">
            <p style="font-size: 14px; font-weight: 500; color: #495057;">제외된 이유:</p>
            <ul style="text-align: left; display: inline-block; font-size: 13px; list-style: none; padding: 0;">
              ${reasonsHtml}
            </ul>
          </div>
        ` : ''}
        <p style="font-size: 12px; margin-top: 15px; color: #868e96;">
          ${validation.alreadyExported.length > 0 ? 
            '이미 내보낸 항목을 포함하려면 "이미 내보낸 항목 제외" 체크를 해제하세요.' : 
            '확정되고 재고가 확인된 항목만 내보낼 수 있습니다.'
          }
        </p>
      </div>
    `;
    return;
  }
  
  // 내보낼 항목이 있는 경우
  let html = `
    <div style="margin-bottom: 10px; font-size: 14px;">
      <strong>내보내기 항목: ${validation.exportableItems.length}개</strong>
      ${validation.warnings.length > 0 ? 
        `<span style="color: #ffc107; margin-left: 10px;">⚠️ 재내보내기 ${validation.warnings.length}개</span>` : 
        ''
      }
    </div>
    <table class="preview-table">
      <thead>
        <tr>
          <th>바코드</th>
          <th>상품명</th>
          <th>옵션</th>
          <th>요청</th>
          <th>출고</th>
          <th>상태</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  validation.exportableItems.forEach(item => {
    const isModified = item.exportQuantity !== item.quantity;
    const isReExport = item.exportedAt ? true : false;
    
    html += `
      <tr class="${isModified ? 'preview-modified' : ''} ${isReExport ? 'preview-reexport' : ''}">
        <td>${item.barcode}</td>
        <td>${item.name}</td>
        <td>${item.option || '-'}</td>
        <td>${item.quantity}</td>
        <td class="${isModified ? 'text-danger' : ''}">${item.exportQuantity}</td>
        <td>
          ${item.stockAvailable}
          ${isReExport ? '<span class="export-status-badge status-exported">재내보내기</span>' : ''}
        </td>
      </tr>
    `;
  });
  
  html += `
      </tbody>
    </table>
  `;
  
  // 제외된 항목이 있는 경우 요약 표시
  if (validation.excludedItems.length > 0) {
    html += `
      <div style="margin-top: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; font-size: 12px;">
        <strong>제외된 항목: ${validation.excludedItems.length}개</strong>
        <span style="color: #6c757d; margin-left: 10px;">
          (미확정 ${validation.unconfirmedItems}개, 재고미확인 ${validation.withoutStockStatus}개${
            validation.alreadyExported.length > 0 ? `, 이미 내보냄 ${validation.alreadyExported.length}개` : ''
          })
        </span>
      </div>
    `;
  }
  
  container.innerHTML = html;
}

function loadExportHistory() {
 const container = document.getElementById('export-history-content');
 
 container.innerHTML = '<div class="loading-spinner-small"></div>';
 
 google.script.run
   .withSuccessHandler(function(history) {
     displayExportHistory(history, container);
   })
   .withFailureHandler(function(error) {
     container.innerHTML = '<p style="color: #dc3545;">이력을 불러올 수 없습니다.</p>';
   })
   .getExportHistory(AppState.currentOrderInfo.orderId);
}

function displayExportHistory(history, container) {
 if (!history || history.length === 0) {
   container.innerHTML = '<p style="text-align: center; color: #6c757d;">내보내기 이력이 없습니다.</p>';
   return;
 }
 
 let html = '';
 
 history.forEach(record => {
   html += `
     <div class="history-item">
       <div>
         <div class="history-date">${formatDateTime(record.exportedAt)}</div>
         <div class="history-info">${record.exportedBy}</div>
       </div>
       <div>
         <span class="history-count">${record.itemCount}개</span>
       </div>
     </div>
   `;
 });
 
 container.innerHTML = html;
}

function formatDateTime(dateString) {
 const date = new Date(dateString);
 return date.toLocaleString('ko-KR', {
   year: 'numeric',
   month: '2-digit',
   day: '2-digit',
   hour: '2-digit',
   minute: '2-digit'
 });
}

function proceedExport() {
  const exportType = document.querySelector('input[name="exportType"]:checked').value;
  
  let itemsToExport = [];
  
  if (exportType === 'all') {
    itemsToExport = AppState.orderItems;
  } else {
    const checkedBoxes = document.querySelectorAll('.order-checkbox:checked');
    checkedBoxes.forEach(checkbox => {
      const orderItem = checkbox.closest('.order-item');
      if (orderItem && orderItem.dataset.id) {
        const itemId = orderItem.dataset.id;
        const item = AppState.orderItems.find(i => String(i.id) === String(itemId));
        if (item) itemsToExport.push(item);
      }
    });
  }
  
  if (itemsToExport.length === 0) {
    showError('내보낼 항목이 없습니다.');
    return;
  }
  
  const validation = performValidation(itemsToExport);
  
  if (validation.exportableItems.length === 0) {
    showError('내보낼 수 있는 항목이 없습니다.');
    return;
  }
  
  // 재내보내기 확인
  const excludeExported = document.getElementById('exclude-exported').checked;
  if (!excludeExported && validation.alreadyExported.length > 0) {
    if (!confirm(`${validation.alreadyExported.length}개 항목이 이미 내보내기되었습니다.\n계속 하시겠습니까?`)) {
      return;
    }
  }
  
  showSaveIndicator('loading');
  document.getElementById('proceed-export-btn').disabled = true;
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        // CSV 다운로드
        downloadCSV(result.csvContent, result.filename);
        
        // 출고 탭 강제 리프레시 플래그 설정
        sessionStorage.setItem('forceRefreshShipping', 'true');
        
        // 내보낸 항목들의 바코드와 시간 저장
        const exportedInfo = {};
        
        if (result.exportedItems && result.exportedItems.length > 0) {
          result.exportedItems.forEach(exported => {
            exportedInfo[exported.barcode] = exported.exportedAt;
            
            const item = AppState.orderItems.find(i => 
              i.barcode === exported.barcode || i.id === exported.id
            );
            if (item) {
              item.exportedAt = exported.exportedAt;
              item.exportStatus = `내보내기 완료 (${new Date(exported.exportedAt).toLocaleString('ko-KR')})`;
            }
          });
          
          // UI 즉시 업데이트
          updateOrderList();
          updateExportButtonStatus();
          
          // 세션에 내보내기 정보 저장
          sessionStorage.setItem('lastExportInfo', JSON.stringify(exportedInfo));
        }
        
        // 결과 표시
        showExportResult(result);
        
        // 모달 닫기
        closeModal('export-csv-modal');
        
        // localStorage 클리어
        try {
          localStorage.removeItem('shippingSession');
        } catch (e) {
          console.warn('localStorage 클리어 실패:', e);
        }
        
        // 출고 탭이 활성화되어 있으면 즉시 새로고침
        const activeTab = document.querySelector('.nav-btn.active');
        if (activeTab && activeTab.dataset.tab === 'shipping') {
          setTimeout(() => {
            loadExportedItems(); // 강제로 서버에서 다시 로드
          }, 1000);
        }
        
        // 서버에서 발주서 다시 로드
        setTimeout(() => {
          // 기존 재고 상태 백업
          const stockStatusBackup = {};
          AppState.orderItems.forEach(item => {
            stockStatusBackup[item.barcode] = item.stockAvailable;
          });
          
          loadOrderItemsFromSheetAsync().then(() => {
            const savedExportInfo = sessionStorage.getItem('lastExportInfo');
            if (savedExportInfo) {
              const exportInfo = JSON.parse(savedExportInfo);
              AppState.orderItems.forEach(item => {
                if (exportInfo[item.barcode]) {
                  item.exportedAt = exportInfo[item.barcode];
                }
                // 재고 상태 복원 (서버에서 제대로 못 읽어온 경우)
                if (stockStatusBackup[item.barcode] && item.stockAvailable === '미확인') {
                  item.stockAvailable = stockStatusBackup[item.barcode];
                }
              });
              updateOrderList();
              sessionStorage.removeItem('lastExportInfo');
            }
          });
        }, 2000);
      } else {
        showError('내보내기 실패: ' + (result.message || '알 수 없는 오류'));
        document.getElementById('proceed-export-btn').disabled = false;
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('내보내기 실패: ' + error.toString());
      document.getElementById('proceed-export-btn').disabled = false;
    })
    .exportToCSV(AppState.currentOrderInfo.orderId, validation.exportableItems);
}

function downloadCSV(csvContent, filename) {
 const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
 const link = document.createElement('a');
 
 if (navigator.msSaveBlob) {
   navigator.msSaveBlob(blob, filename);
 } else {
   link.href = URL.createObjectURL(blob);
   link.download = filename;
   link.style.display = 'none';
   document.body.appendChild(link);
   link.click();
   document.body.removeChild(link);
 }
}

function updateExportedStatus(exportedItems, exportedAt) {
  const now = exportedAt || new Date().toISOString();
  
  exportedItems.forEach(expItem => {
    const item = AppState.orderItems.find(i => i.id === expItem.id);
    if (item) {
      item.exportedAt = now;
      item.exportedQuantity = expItem.exportQuantity || expItem.quantity;
      item.exportStatus = `내보내기 완료 (${new Date(now).toLocaleString('ko-KR')})`;
    }
  });
  
  // UI 즉시 업데이트
  updateOrderList();
  updateExportButtonStatus();
  
  // 세션 저장
  saveSession();
  
  // 서버에도 저장 (자동 저장)
  scheduleAutoSave();
}

function showExportResult(result) {
 const content = document.getElementById('export-result-content');
 
 content.innerHTML = `
   <div class="export-result">
     <div class="export-result-icon success">✅</div>
     <div class="export-result-title">내보내기 완료</div>
     <div class="export-result-info">
       CSV 파일이 다운로드되었습니다.
     </div>
     <div class="export-result-details">
       <p><strong>파일명:</strong> ${result.filename}</p>
       <p><strong>내보낸 항목:</strong> ${result.exportedCount}개</p>
       <p><strong>내보내기 시간:</strong> ${formatDateTime(result.exportedAt)}</p>
     </div>
   </div>
 `;
 
 document.getElementById('export-result-modal').style.display = 'block';
}

// 7. 개별 아이템의 Smaregi 정보만 업데이트
function updateOrderItemSmaregiInfo(itemId) {
  const itemElement = document.querySelector(`[data-id="${itemId}"]`);
  if (!itemElement) return;
  
  const item = AppState.orderItems.find(i => i.id == itemId);
  if (!item) return;
  
  const storeStock = AppState.smaregiData[item.barcode] || 0;
  const hasData = item.barcode in AppState.smaregiData;
  
  // 매장 재고 배지만 업데이트
  const stockBadge = itemElement.querySelector('.store-stock-badge');
  if (stockBadge) {
    if (hasData) {
      let stockClass = 'store-stock-normal';
      if (storeStock === 0) stockClass = 'store-stock-empty';
      else if (storeStock < 10) stockClass = 'store-stock-low';
      
      stockBadge.className = `store-stock-badge ${stockClass}`;
      stockBadge.innerHTML = `
        <span class="store-icon">🏪</span>
        <span class="store-count">${storeStock}개</span>
      `;
    } else {
      stockBadge.className = 'store-stock-badge store-stock-no-data';
      stockBadge.innerHTML = `
        <span class="store-icon">🏪</span>
        <span class="store-count">-</span>
      `;
    }
  }
}

// ===== 31. Smaregi 업로드 기능 =====
function showSmaregiUploadModal() {
 document.getElementById('smaregi-upload-modal').style.display = 'block';
 document.getElementById('last-smaregi-upload').textContent = '확인중...';
 loadLastSmaregiUploadInfo();
 setupSmaregiDropZone();
}

function setupSmaregiDropZone() {
 const dropZone = document.getElementById('smaregi-drop-zone');
 const fileInput = document.getElementById('smaregi-file-input');
 
 if (!dropZone || !fileInput) return;
 if (dropZone.dataset.initialized === 'true') return;
 
 dropZone.dataset.initialized = 'true';
 
 dropZone.addEventListener('click', () => {
   fileInput.click();
 });
 
 dropZone.addEventListener('dragover', (e) => {
   e.preventDefault();
   dropZone.classList.add('drag-over');
 });
 
 dropZone.addEventListener('dragleave', () => {
   dropZone.classList.remove('drag-over');
 });
 
 dropZone.addEventListener('drop', (e) => {
   e.preventDefault();
   dropZone.classList.remove('drag-over');
   
   const file = e.dataTransfer.files[0];
   if (file && file.type === 'text/csv') {
     handleSmaregiFile(file);
   } else {
     showError('CSV 파일만 업로드 가능합니다.');
   }
 });
 
 fileInput.addEventListener('change', (e) => {
   const file = e.target.files[0];
   if (file) {
     handleSmaregiFile(file);
   }
 });
}

function handleSmaregiFile(file) {
  const reader = new FileReader();
  
  reader.onload = (e) => {
    AppState.uploadedSmaregiContent = e.target.result;
    
    // 파일 선택 상태를 명확하게 표시
    const dropZone = document.getElementById('smaregi-drop-zone');
    dropZone.innerHTML = `
      <div class="file-selected">
        <div class="file-icon">📄</div>
        <div class="file-info">
          <div class="file-name">${file.name}</div>
          <div class="file-size">${(file.size / 1024).toFixed(2)} KB</div>
          <div class="file-status">✅ 파일 선택됨</div>
        </div>
        <button class="btn-remove-file" onclick="removeSmaregiFile()">
          <span>✕</span> 다시 선택
        </button>
      </div>
    `;
    
    // 미리보기 표시
    previewSmaregiCSV(AppState.uploadedSmaregiContent);
    document.getElementById('process-smaregi-btn').disabled = false;
  };
  
  reader.onerror = (e) => {
    showError('파일 읽기에 실패했습니다.');
  };
  
  reader.readAsText(file, 'UTF-8');
}

// 파일 제거 함수 추가
function removeSmaregiFile() {
  AppState.uploadedSmaregiContent = null;
  
  const dropZone = document.getElementById('smaregi-drop-zone');
  dropZone.innerHTML = `
    <p>📁 CSV 파일을 드래그하거나 클릭하여 선택</p>
  `;
  
  document.getElementById('smaregi-preview').style.display = 'none';
  document.getElementById('process-smaregi-btn').disabled = true;
  
  // 파일 input 초기화
  const fileInput = document.getElementById('smaregi-file-input');
  if (fileInput) fileInput.value = '';
}

function previewSmaregiCSV(csvContent) {
  const lines = csvContent.split('\n');
  const preview = document.getElementById('smaregi-preview');
  const previewContent = document.getElementById('smaregi-preview-content');
  
  // 간단한 CSV 파싱 함수 (인라인)
  const parseCSV = (line) => {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    
    result.push(current);
    return result;
  };
  
  let html = `
    <table class="preview-table">
      <thead>
        <tr>
          <th>바코드</th>
          <th>매장 재고</th>
        </tr>
      </thead>
      <tbody>
  `;
  
  let validRows = 0;
  
  for (let i = 1; i < lines.length && validRows < 5; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    
    const columns = parseCSV(line); // parseCSVLine 대신 parseCSV 사용
    
    if (columns.length > 8) {
      const barcode = columns[2] ? columns[2].trim() : '';
      const stock = columns[8] ? columns[8].trim() : '0';
      
      if (barcode) {
        html += `<tr><td>${barcode}</td><td>${stock}개</td></tr>`;
        validRows++;
      }
    }
  }
  
  const totalValidRows = lines.filter((line, index) => {
    if (index === 0 || !line.trim()) return false;
    const cols = parseCSV(line);
    return cols.length > 8 && cols[2];
  }).length;
  
  if (totalValidRows > 5) {
    html += `<tr><td colspan="2" style="text-align: center;">... 총 ${totalValidRows}개 항목</td></tr>`;
  }
  
  html += '</tbody></table>';
  
  previewContent.innerHTML = html;
  preview.style.display = 'block';
}

function processSmaregiUpload() {
  console.log('processSmaregiUpload 시작');
  console.log('CSV 내용 길이:', AppState.uploadedSmaregiContent?.length);

  if (!AppState.uploadedSmaregiContent) {
    showError('CSV 파일을 먼저 선택해주세요.');
    return;
  }
  
  // 버튼 비활성화 및 로딩 표시
  const processBtn = document.getElementById('process-smaregi-btn');
  const originalText = processBtn.textContent;
  processBtn.disabled = true;
  processBtn.textContent = '처리 중...';
  
  // 더 나은 로딩 표시
  showLoadingOverlay('매장 재고 데이터를 처리하는 중입니다...');
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoadingOverlay();
      processBtn.disabled = false;
      processBtn.textContent = originalText;
      
      if (result && result.success) {
        // 메모리의 Smaregi 데이터 즉시 업데이트
        AppState.smaregiData = result.data || {};
        AppState.smaregiUploadTime = new Date().toLocaleString('ko-KR');
        AppState.smaregiDataLoaded = true;
        
        showQuickSuccess(`${result.count}개 매장 재고 정보가 업데이트되었습니다.`);
        closeModal('smaregi-upload-modal');
        
        // 화면에 표시된 내용 즉시 업데이트
        updateSmaregiDisplay();
        
        if (result.lowStockItems && result.lowStockItems.length > 0) {
          showLowStockAlert(result.lowStockItems);
        }
      } else {
        showError(result ? result.message : '알 수 없는 오류가 발생했습니다.');
      }
    })
    .withFailureHandler(function(error) {
      hideLoadingOverlay();
      processBtn.disabled = false;
      processBtn.textContent = originalText;
      
      console.error('Smaregi 업로드 실패:', error);
      showError('업로드 실패: ' + (error.message || error.toString()));
    })
    .uploadSmaregiCSV(AppState.uploadedSmaregiContent);
}

function showLoadingOverlay(message = '처리 중...') {
  let overlay = document.getElementById('loading-overlay');
  
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'loading-overlay';
    overlay.className = 'loading-overlay';
    document.body.appendChild(overlay);
  }
  
  overlay.innerHTML = `
    <div class="loading-overlay-content">
      <div class="loading-spinner"></div>
      <div class="loading-message">${message}</div>
      <div class="loading-submessage">잠시만 기다려주세요...</div>
    </div>
  `;
  
  overlay.style.display = 'flex';
}

function hideLoadingOverlay() {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    overlay.style.display = 'none';
  }
}

function updateSmaregiDisplay() {
  // 검색 결과가 표시되어 있으면 다시 렌더링
  const searchResults = document.getElementById('search-results');
  if (searchResults && searchResults.children.length > 1) {
    const query = document.getElementById('search-input').value;
    if (query) {
      performSearch(); // 로컬 데이터로 재검색
    }
  }
  
  // 발주 목록 업데이트
  if (AppState.orderItems.length > 0) {
    updateOrderList();
  }
  
  // Smaregi 상태 표시 업데이트
  updateSmaregiStatusDisplay();
}

// Smaregi 상태 표시 업데이트
function updateSmaregiStatus() {
  // order-management-section의 상태만 업데이트
  const statusElement = document.querySelector('.order-management-section #smaregi-status');
  if (!statusElement) return;
  
  const statusIcon = statusElement.querySelector('#smaregi-status-icon');
  const statusText = statusElement.querySelector('#smaregi-status-text');
  
  google.script.run
    .withSuccessHandler(function(result) {
      if (result.connected) {
        statusElement.classList.add('connected');
        statusElement.classList.remove('error');
        statusIcon.textContent = '✅';
        statusText.textContent = 'API 연결됨';
        
        // AppState 업데이트
        AppState.smaregiConnected = true;
        
        // 재고 데이터 로드
        if (result.hasData) {
          statusText.textContent = `API 연결됨 (${result.itemCount || 0}개 상품)`;
        }
      } else {
        statusElement.classList.add('error');
        statusElement.classList.remove('connected');
        statusIcon.textContent = '❌';
        statusText.textContent = 'API 연결 안됨';
        AppState.smaregiConnected = false;
      }
    })
    .withFailureHandler(function(error) {
      statusElement.classList.add('error');
      statusElement.classList.remove('connected');
      statusIcon.textContent = '⚠️';
      statusText.textContent = 'API 확인 실패';
      AppState.smaregiConnected = false;
    })
    .checkSmaregiConnection();
}

// scripts.html의 Smaregi 관련 최적화된 코드

// 전역 변수
window.currentLowStockItems = null;

// 메인 함수
function showLowStockAlert(lowStockItems) {
  if (!lowStockItems || lowStockItems.length === 0) {
    showInfo('재고 부족 상품이 없습니다.');
    return;
  }
  
  window.currentLowStockItems = lowStockItems;
  
  const orderedBarcodes = new Set(AppState.orderItems.map(item => item.barcode));
  const threshold = AppState.settings.suggestStock10 || 10;
  
  const modalContent = `
    <div class="low-stock-alert">
      <div class="low-stock-alert-header">
        <h3>⚠️ 재고 부족 상품</h3>
        <div class="low-stock-summary">매장 재고 ${threshold}개 미만</div>
      </div>
      
      <div class="low-stock-controls">
        <label class="filter-checkbox">
          <input type="checkbox" id="select-all-items" onchange="toggleSelectAll()">
          <span>전체 선택</span>
        </label>
        <label class="filter-checkbox" style="margin-left: 20px;">
          <input type="checkbox" id="hide-ordered" onchange="filterLowStockItems()">
          <span>발주목록에 있는 상품 숨기기</span>
        </label>
      </div>
      
      <div class="low-stock-list">
        ${lowStockItems.map((item, index) => {
  const isOrdered = orderedBarcodes.has(item.barcode);
  return `
    <div class="low-stock-item ${isOrdered ? 'already-in-order' : ''} ${item.isFrequent ? 'frequent-item' : ''}" 
         id="low-stock-${index}"
         data-is-ordered="${isOrdered}">
      
      <input type="checkbox" 
             class="item-checkbox" 
             data-index="${index}"
             ${isOrdered ? 'disabled' : ''}
             onchange="updateAddButton()">
      
      <div class="item-main">
        <div class="item-name">
          ${item.name}
          ${item.isFrequent ? '<span class="frequent-badge">자주발주</span>' : ''}
        </div>
        <div class="item-meta">
          ${item.option ? `<span class="item-option">${item.option}</span>` : ''}
          ${item.orderCount > 0 ? `<span class="order-count">최근 ${item.orderCount}회 발주</span>` : ''}
        </div>
      </div>
      
      <div class="stock-badge ${item.stock === 0 ? 'out-of-stock' : 'low-stock'}">
        재고: ${item.stock}개
      </div>
      
      <div class="quantity-control">
        <button class="qty-btn" onclick="adjustQty(${index}, -1)">−</button>
        <input type="number" 
               id="qty-${index}" 
               class="qty-input" 
               value="${item.suggestedOrder || 10}"
               min="1">
        <button class="qty-btn" onclick="adjustQty(${index}, 1)">+</button>
      </div>
      
      <button class="add-to-order-btn btn-primary" 
              onclick="addToOrderFromLowStock(${index})"
              id="btn-${index}"
              ${isOrdered ? 'disabled' : ''}>
        ${isOrdered ? '발주목록에 있음' : '발주 추가'}
      </button>
    </div>
  `;
}).join('')}
      </div>
      
      <div class="low-stock-footer">
        <button class="btn btn-primary" onclick="addSelectedLowStock()" id="add-selected-btn">
          선택 항목 추가
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">닫기</button>
      </div>
    </div>
  `;
  
  showModal(modalContent);
  updateAddButton();
}

function toggleSelectAll() {
  const selectAll = document.getElementById('select-all-items').checked;
  const checkboxes = document.querySelectorAll('.item-checkbox:not(:disabled)');
  
  checkboxes.forEach(cb => {
    cb.checked = selectAll;
  });
  
  updateAddButton();
}

// 헬퍼 함수들 (간소화)
function filterLowStockItems() {
  const hide = document.getElementById('hide-ordered').checked;
  document.querySelectorAll('.already-in-order').forEach(el => {
    el.style.display = hide ? 'none' : '';
  });
}

function adjustQty(index, delta) {
  const input = document.getElementById(`qty-${index}`);
  if (input) input.value = Math.max(1, parseInt(input.value) + delta);
}

function updateAddButton() {
  const count = document.querySelectorAll('.item-checkbox:checked:not(:disabled)').length;
  const btn = document.getElementById('add-selected-btn');
  if (btn) {
    btn.textContent = count > 0 ? `선택 항목 추가 (${count}개)` : '선택 항목 추가';
    btn.disabled = count === 0;
  }
}

// 개별 추가
function addToOrderFromLowStock(index) {
  const item = window.currentLowStockItems[index];
  const quantity = parseInt(document.getElementById(`qty-${index}`).value);
  const btn = document.getElementById(`btn-${index}`);
  const itemEl = document.getElementById(`low-stock-${index}`);
  
  // 버튼 상태 변경
  btn.disabled = true;
  btn.textContent = '추가 중...';
  
  google.script.run
    .withSuccessHandler(productDetails => {
      if (productDetails) {
        AppState.orderItems.push({
          ...productDetails,
          quantity: quantity,
          priority: 1,
          comment: '', // 코멘트 제거
          status: '대기',
          id: Date.now() + index,
          stockAvailable: '미확인'
        });
        
        updateOrderList();
        scheduleAutoSave();
        
        // UI 업데이트
        btn.textContent = '✓ 추가됨';
        btn.classList.add('btn-success');
        itemEl.classList.add('added');
        itemEl.style.opacity = '0.6';
        
        // 체크박스 비활성화
        const checkbox = itemEl.querySelector('.item-checkbox');
        if (checkbox) {
          checkbox.disabled = true;
          checkbox.checked = false;
        }
        
        showQuickSuccess(`${item.name} ${quantity}개 추가됨`);
        updateAddButton();
      }
    })
    .withFailureHandler(error => {
      btn.disabled = false;
      btn.textContent = '발주 추가';
      showError('추가 실패');
    })
    .getProductDetails(item.barcode);
}

// 선택 항목 추가
function addSelectedLowStock() {
  const selected = [];
  const btn = document.getElementById('add-selected-btn');
  
  // 버튼 상태 변경
  btn.disabled = true;
  btn.textContent = '추가 중...';
  
  document.querySelectorAll('.item-checkbox:checked:not(:disabled)').forEach(cb => {
    const index = parseInt(cb.dataset.index);
    const quantity = parseInt(document.getElementById(`qty-${index}`).value);
    selected.push({ ...window.currentLowStockItems[index], quantity, index });
  });
  
  if (selected.length === 0) {
    btn.disabled = false;
    btn.textContent = '선택 항목 추가';
    return;
  }
  
  let completed = 0;
  const total = selected.length;
  
  selected.forEach(item => {
    google.script.run
      .withSuccessHandler(productDetails => {
        if (productDetails) {
          AppState.orderItems.push({
            ...productDetails,
            quantity: item.quantity,
            priority: 1,
            comment: '', // 코멘트 제거
            status: '대기',
            id: Date.now() + item.index,
            stockAvailable: '미확인'
          });
          
          // UI 업데이트
          const itemEl = document.getElementById(`low-stock-${item.index}`);
          const itemBtn = document.getElementById(`btn-${item.index}`);
          
          if (itemEl) {
            itemEl.classList.add('added');
            itemEl.style.opacity = '0.6';
          }
          
          if (itemBtn) {
            itemBtn.textContent = '✓ 추가됨';
            itemBtn.disabled = true;
            itemBtn.classList.add('btn-success');
          }
        }
        
        completed++;
        btn.textContent = `추가 중... (${completed}/${total})`;
        
        if (completed === total) {
          updateOrderList();
          scheduleAutoSave();
          showQuickSuccess(`${selected.length}개 항목 추가 완료`);
          setTimeout(() => closeModal(), 1500); // 1.5초 후 자동 닫기
        }
      })
      .withFailureHandler(error => {
        completed++;
        if (completed === total) {
          btn.disabled = false;
          btn.textContent = '선택 항목 추가';
          showError('일부 항목 추가 실패');
        }
      })
      .getProductDetails(item.barcode);
  });
}

function showNotification(content, type = 'info', duration = 5000) {
 const notification = document.createElement('div');
 notification.className = `notification notification-${type}`;
 notification.innerHTML = content;
 
 document.body.appendChild(notification);
 
 setTimeout(() => {
   notification.classList.add('show');
 }, 10);
 
 setTimeout(() => {
   notification.classList.remove('show');
   setTimeout(() => {
     notification.remove();
   }, 300);
 }, duration);
}

function loadLastSmaregiUploadInfo() {
 const timeoutId = setTimeout(() => {
   document.getElementById('last-smaregi-upload').textContent = '정보 없음';
 }, 5000);
 
 google.script.run
   .withSuccessHandler(function(info) {
     clearTimeout(timeoutId);
     
     if (info) {
       document.getElementById('last-smaregi-upload').textContent = info.date;
       
       if (!info.isToday) {
         document.getElementById('last-smaregi-upload').innerHTML += 
           ' <span class="warning-text">(업데이트 필요)</span>';
       }
     } else {
       document.getElementById('last-smaregi-upload').textContent = '없음';
     }
   })
   .withFailureHandler(function(error) {
     clearTimeout(timeoutId);
     document.getElementById('last-smaregi-upload').textContent = '로드 실패';
   })
   .getLastSmaregiUploadInfo();
}

// ===== 32. 일괄 재고 편집 =====
function showBulkStockEditModal() {
 const checkedBoxes = document.querySelectorAll('.order-checkbox:checked');
 const selectedIds = Array.from(checkedBoxes).map(cb => 
   cb.closest('.order-item').dataset.id
 );
 
 if (selectedIds.length === 0) {
   showError('선택된 항목이 없습니다.');
   return;
 }
 
 document.getElementById('selected-count').textContent = selectedIds.length;
 document.getElementById('bulk-stock-edit-modal').style.display = 'block';
 
 window.bulkEditSelectedIds = selectedIds;
}

function applyBulkStock(status) {
 if (!window.bulkEditSelectedIds || window.bulkEditSelectedIds.length === 0) return;
 
 if (status === 'quantity') {
   showBulkQuantityModal();
   return;
 }
 
 showSaveIndicator('saving');
 
 const updates = [];
 
 window.bulkEditSelectedIds.forEach(id => {
   const item = AppState.orderItems.find(i => i.id == id);
   if (item) {
     item.stockAvailable = status;
     updates.push({
       itemId: item.id,
       barcode: item.barcode,
       stockStatus: status
     });
   }
 });
 
 updateOrderList();
 
 if (updates.length > 0) {
   smartRetry.execute('updateBulkStockStatus', [AppState.currentOrderInfo.orderId, updates])
     .then(result => {
       showSaveIndicator('hide');
       
       if (result.success) {
         closeModal('bulk-stock-edit-modal');
         showQuickSuccess(result.message);
         
         document.querySelectorAll('.order-checkbox').forEach(cb => cb.checked = false);
         updateBulkEditButton();
       } else {
         showError('일부 항목 업데이트 실패: ' + result.message);
         loadOrderItemsFromSheetAsync();
       }
     })
     .catch(error => {
       showSaveIndicator('hide');
       showError('업데이트 실패: ' + error);
       loadOrderItemsFromSheetAsync();
     });
 }
}

function showBulkQuantityModal() {
 const selectedIds = window.bulkEditSelectedIds;
 
 if (!selectedIds || selectedIds.length === 0) {
   const checkedBoxes = document.querySelectorAll('.order-checkbox:checked');
   selectedIds = Array.from(checkedBoxes).map(cb => 
     cb.closest('.order-item').dataset.id
   );
   
   if (selectedIds.length === 0) {
     showError('선택된 항목이 없습니다.');
     return;
   }
   
   window.bulkEditSelectedIds = selectedIds;
 }
 
 const listContainer = document.getElementById('bulk-quantity-list');
 
 if (selectedIds.length === 1) {
   const item = AppState.orderItems.find(i => i.id == selectedIds[0]);
   if (!item) return;
   
   listContainer.innerHTML = `
     <div class="single-quantity-input">
       <div class="item-info-large">
         <strong>${item.name}</strong>
         <span class="text-muted">${item.option || ''}</span>
         <span class="text-muted">요청 수량: ${item.quantity}개</span>
       </div>
       <div class="quantity-input-large">
         <input type="number" 
                id="bulk-qty-${item.id}" 
                class="quantity-input large" 
                placeholder="가능 수량 입력"
                min="0"
                max="${item.quantity}"
                autofocus>
         <span class="unit">개만 가능</span>
       </div>
     </div>
   `;
 } else {
   listContainer.innerHTML = `
     <div class="bulk-info-message">
       <p>${selectedIds.length}개 상품의 가능 수량을 입력하세요.</p>
     </div>
     ${selectedIds.map(id => {
       const item = AppState.orderItems.find(i => i.id == id);
       if (!item) return '';
       
       return `
         <div class="bulk-quantity-item">
           <div class="item-info">
             <strong>${item.name}</strong>
             <span class="text-muted">${item.option || ''} | 요청: ${item.quantity}개</span>
           </div>
           <div class="quantity-input-wrapper">
             <input type="number" 
                    id="bulk-qty-${id}" 
                    class="quantity-input" 
                    placeholder="가능수량"
                    min="0"
                    max="${item.quantity}">
             <span class="unit">개만 가능</span>
           </div>
         </div>
       `;
     }).join('')}
   `;
 }
 
 document.getElementById('bulk-quantity-modal').style.display = 'block';
 
 if (selectedIds.length === 1) {
   setTimeout(() => {
     const input = document.getElementById(`bulk-qty-${selectedIds[0]}`);
     if (input) input.focus();
   }, 100);
 }
}

function saveBulkQuantities() {
 const selectedIds = window.bulkEditSelectedIds;
 
 if (!selectedIds || selectedIds.length === 0) {
   showError('선택된 항목이 없습니다.');
   return;
 }
 
 let updatedCount = 0;
 
 selectedIds.forEach(id => {
   const input = document.getElementById(`bulk-qty-${id}`);
   if (input && input.value) {
     const item = AppState.orderItems.find(i => i.id == id);
     if (item) {
       item.stockAvailable = `${input.value}개만 가능`;
       updatedCount++;
     }
   }
 });
 
 updateOrderList();
 
 closeModal('bulk-quantity-modal');
 closeModal('bulk-stock-edit-modal');
 
 if (updatedCount > 0) {
   showQuickSuccess(`${updatedCount}개 항목의 재고 수량이 업데이트되었습니다.`);
   scheduleAutoSave();
 } else {
   showError('입력된 수량이 없습니다.');
 }
 
 document.querySelectorAll('.order-checkbox').forEach(cb => cb.checked = false);
 updateBulkEditButton();
 window.bulkEditSelectedIds = null;
}

function closeBulkQuantityModal() {
 closeModal('bulk-quantity-modal');
 closeModal('bulk-stock-edit-modal');
 
 document.querySelectorAll('.order-checkbox').forEach(cb => cb.checked = false);
 updateBulkEditButton();
 window.bulkEditSelectedIds = null;
}

// ===== 33. Quick Actions (대시보드) =====
function quickAction(action) {
 switch(action) {
   case 'lastWeekOrder':
     copyLastWeekOrder();
     break;
   case 'bestProducts':
     quickOrderBestProducts();
     break;
   case 'monthlyReport':
     generateMonthlyReport();
     break;
   case 'budgetAlert':
     setBudgetAlert();
     break;
 }
}

// 기존 copyLastWeekOrder 함수 제거하고 새로운 closeCurrentOrder 함수로 교체
function closeCurrentOrder() {
  if (!AppState.currentOrderInfo) {
    showError('열려있는 발주서가 없습니다.');
    return;
  }
  
  if (!confirm('발주서를 마감하시겠습니까?\n마감 후에는 수정이 불가능합니다.')) {
    return;
  }
  
  showLoading('발주서 마감 처리 중...');
  
  google.script.run
    .withSuccessHandler(result => {
      hideLoading();
      if (result.success) {
        showQuickSuccess(result.message);
        
        // 발주서 상태 업데이트
        if (AppState.currentOrderInfo) {
          AppState.currentOrderInfo.isClosed = true;
        }
        
        // UI 업데이트
        updateOrderList();
        updateOrderStatus();
        
        // 마감 버튼 비활성화
        const closeBtn = document.getElementById('closeOrderBtn');
        if (closeBtn) {
          closeBtn.disabled = true;
          closeBtn.innerHTML = '<span class="action-icon">✅</span><span>마감됨</span>';
        }
      } else {
        showError('마감 처리 실패: ' + result.error);
      }
    })
    .withFailureHandler(error => {
      hideLoading();
      showError('마감 처리 실패: ' + error.toString());
    })
    .closeOrder(AppState.currentOrderInfo.orderId);
}

function quickOrderBestProducts() {
 showSaveIndicator('loading');
 
 google.script.run
   .withSuccessHandler(function(bestProducts) {
     showSaveIndicator('hide');
     
     if (!bestProducts || bestProducts.length === 0) {
       showError('베스트 상품 데이터가 없습니다.');
       return;
     }
     
     const modalContent = `
       <h3>베스트 상품 빠른 발주</h3>
       <div class="best-products-list">
         ${bestProducts.map(product => `
           <div class="best-product-item">
             <div class="product-info">
               <div class="product-name">${product.name}</div>
               <div class="product-details">${product.option} | ${product.supplierName}</div>
             </div>
             <div class="product-controls">
               <input type="number" 
                      id="qty-${product.barcode}" 
                      class="quantity-input" 
                      value="${product.avgQuantity}" 
                      min="0">
               <button class="btn btn-primary" 
                       onclick="addBestProduct('${product.barcode}')">
                 추가
               </button>
             </div>
           </div>
         `).join('')}
       </div>
       <div style="text-align: right; margin-top: 20px;">
         <button class="btn btn-primary" onclick="addAllBestProducts()">전체 추가</button>
         <button class="btn btn-secondary" onclick="closeModal()">닫기</button>
       </div>
     `;
     
     window.bestProductsData = bestProducts;
     showModal(modalContent);
   })
   .withFailureHandler(function(error) {
     showSaveIndicator('hide');
     showError('베스트 상품 로드 실패: ' + error);
   })
   .getBestProductsForQuickOrder();
}

function addBestProduct(barcode) {
 const product = window.bestProductsData.find(p => p.barcode === barcode);
 const quantity = parseInt(document.getElementById(`qty-${barcode}`).value) || 0;
 
 if (quantity <= 0) return;
 
 google.script.run
   .withSuccessHandler(function(details) {
     if (details) {
       const existing = AppState.orderItems.find(item => item.barcode === barcode);
       
       if (existing) {
         existing.quantity += quantity;
       } else {
         AppState.orderItems.push({
           ...details,
           quantity: quantity,
           priority: 3,
           comment: '베스트 상품',
           status: '대기',
           id: Date.now(),
           stockAvailable: '미확인'
         });
       }
       
       updateOrderList();
       showQuickSuccess('상품이 추가되었습니다.');
       document.getElementById(`qty-${barcode}`).disabled = true;
     }
   })
   .withFailureHandler(function(error) {
     showError('상품 추가 실패');
   })
   .getProductDetails(barcode);
}

function addAllBestProducts() {
 const productsToAdd = [];
 
 window.bestProductsData.forEach(product => {
   const qtyInput = document.getElementById(`qty-${product.barcode}`);
   if (!qtyInput.disabled) {
     const quantity = parseInt(qtyInput.value) || 0;
     if (quantity > 0) {
       productsToAdd.push({ barcode: product.barcode, quantity: quantity });
     }
   }
 });
 
 if (productsToAdd.length === 0) {
   showError('추가할 상품이 없습니다.');
   return;
 }
 
 let addedCount = 0;
 productsToAdd.forEach(item => {
   addBestProduct(item.barcode);
   addedCount++;
 });
 
 setTimeout(() => {
   closeModal();
   switchTab('order');
   showQuickSuccess(`${addedCount}개 베스트 상품이 추가되었습니다.`);
   window.bestProductsData = null;
 }, 1000);
}

// ===== 34. 기타 헬퍼 함수들 =====
function showFrequentNotOrdered() {
 showSaveIndicator('loading');
 
 google.script.run
   .withSuccessHandler(function(products) {
     showSaveIndicator('hide');
     
     const modalContent = `
       <h3>재고 확인 필요 상품</h3>
       <p>최근 7일간 발주하지 않은 자주 발주 상품입니다.</p>
       <div class="best-products-list">
         ${products.map(product => `
           <div class="best-product-item">
             <div class="product-info">
               <div class="product-name">${product.name}</div>
               <div class="product-details">
                 마지막 발주: ${product.lastOrderDate || '정보없음'} | 
                 평균 발주량: ${product.avgQuantity}개
               </div>
             </div>
             <button class="btn btn-primary" 
                     onclick="addToOrder('${product.barcode}')">
               발주 추가
             </button>
           </div>
         `).join('')}
       </div>
     `;
     
     showModal(modalContent);
   })
   .withFailureHandler(function(error) {
     showSaveIndicator('hide');
     showError('데이터 로드 실패');
   })
   .getFrequentNotOrderedProducts();
}

function showBudgetDetails() {
 const budgetEl = document.getElementById('budget-rate').textContent;
 const usedAmount = document.getElementById('budget-text').textContent;
 
 const modalContent = `
   <h3>월 예산 상세</h3>
   <div style="padding: 20px;">
     <p><strong>현재 사용률:</strong> ${budgetEl}</p>
     <p><strong>사용 금액:</strong> ${usedAmount}</p>
     <div style="margin-top: 20px;">
       <label>월 예산 수정:</label>
       <input type="number" id="new-budget" class="form-input" 
              placeholder="새 예산 금액" style="margin: 10px 0;">
       <button class="btn btn-primary" onclick="updateMonthlyBudget()">
         예산 변경
       </button>
     </div>
   </div>
 `;
 
 showModal(modalContent);
}

function updateMonthlyBudget() {
 const newBudget = document.getElementById('new-budget').value;
 if (!newBudget || newBudget <= 0) {
   showError('올바른 예산 금액을 입력해주세요.');
   return;
 }
 
 google.script.run
   .withSuccessHandler(function(result) {
     if (result.success) {
       closeModal();
       showQuickSuccess('예산이 변경되었습니다.');
       loadDashboard();
     } else {
       showError('예산 변경 실패');
     }
   })
   .withFailureHandler(function(error) {
     showError('예산 변경 실패: ' + error);
   })
   .updateSettings({ monthlyBudget: newBudget });
}

function generateMonthlyReport() {
 showSaveIndicator('loading');
 
 google.script.run
   .withSuccessHandler(function(report) {
     showSaveIndicator('hide');
     
     if (report.success) {
       showQuickSuccess('월간 리포트가 생성되었습니다.');
       window.open(report.url, '_blank');
     }
   })
   .withFailureHandler(function(error) {
     showSaveIndicator('hide');
     showError('리포트 생성 실패');
   })
   .createMonthlyReport();
}

function setBudgetAlert() {
 const modalContent = `
   <h3>예산 알림 설정</h3>
   <div style="padding: 20px;">
     <label>
       <input type="checkbox" id="alert-80" checked> 
       예산 80% 도달 시 알림
     </label><br><br>
     <label>
       <input type="checkbox" id="alert-90" checked> 
       예산 90% 도달 시 알림
     </label><br><br>
     <label>
       <input type="checkbox" id="alert-over"> 
       예산 초과 시 알림
     </label><br><br>
     <button class="btn btn-primary" onclick="saveBudgetAlertSettings()">
       저장
     </button>
   </div>
 `;
 
 showModal(modalContent);
}

function saveBudgetAlertSettings() {
 const settings = {
   alert80: document.getElementById('alert-80').checked,
   alert90: document.getElementById('alert-90').checked,
   alertOver: document.getElementById('alert-over').checked
 };
 
 google.script.run
   .withSuccessHandler(function(result) {
     if (result.success) {
       closeModal();
       showQuickSuccess('알림 설정이 저장되었습니다.');
     }
   })
   .withFailureHandler(function(error) {
     showError('설정 저장 실패');
   })
   .saveBudgetAlertSettings(settings);
}

// scripts.html - 압축 해제
function decompressProductData(compressed) {
  return compressed.map(p => ({
    barcode: p.b,
    name: p.n,
    option: p.o,
    purchasePrice: p.p,
    supplierName: p.s,
    weight: p.w,
    isFrequent: p.f,
    isRecent: p.r,
    searchText: `${p.b} ${p.n} ${p.o}`.toLowerCase()
  }));
}

// ===== 31. 출고 기능 =====
// 출고 상태 관리
const ShippingState = {
  exportedItems: [],
  currentBox: {
    barcode: null,
    name: null,
    items: {},
    startTime: null,
    number: null
  },
  currentBoxNumber: 1,
  scanState: 'READY',
  autoSaveTimer: null,
  lastSaveTime: null,
  lastServerSaveTime: null, // 서버 저장 시간 추가
  isSaving: false,
};

function onOrderChanged() {
  // 이전 발주서와 다른 경우
  const previousOrderId = sessionStorage.getItem('previousOrderId');
  const currentOrderId = AppState.currentOrderInfo?.orderId;
  
  if (previousOrderId && previousOrderId !== currentOrderId) {
    // 새로운 발주서이므로 박스번호는 서버에서 가져옴
    console.log('발주서가 변경되었습니다. 박스번호를 새로 로드합니다.');
  }
  
  // 현재 발주서 ID 저장
  if (currentOrderId) {
    sessionStorage.setItem('previousOrderId', currentOrderId);
  }
}

// 출고 탭 초기화
function loadShippingTab() {
  console.log('=== 출고 탭 로드 ===');
  
  if (!AppState.currentOrderInfo) {
    showShippingEmptyState();
    return;
  }
  
  // 발주서 변경 감지
  onOrderChanged();
  
  // 설정이 로드되었는지 확인
  if (!AppState.settings) {
    console.error('설정이 로드되지 않았습니다');
    showShippingSetupPrompt();
    return;
  }
  
  // 강제 리프레시 체크
  const forceRefresh = sessionStorage.getItem('forceRefreshShipping');
  if (forceRefresh === 'true') {
    sessionStorage.removeItem('forceRefreshShipping');
    localStorage.removeItem('shippingSession');
    
    // 상태 초기화
    ShippingState.currentBox = {
      barcode: null,
      name: null,
      items: {},
      startTime: null,
      number: null
    };
  }
  
  // 1. 먼저 세션 복원 시도
  const sessionRestored = restoreShippingSession();
  
  // 2. 그 다음 내보내기 항목 로드 (세션 유지하면서)
  if (sessionRestored) {
    console.log('세션이 복원되었으므로 세션 유지하며 로드');
  }
  
  loadExportedItems();
}

// 빈 상태 표시
function showShippingEmptyState() {
  const container = document.getElementById('shipping-tab');
  container.innerHTML = `
    <div class="empty-state">
      <div class="empty-icon">📦</div>
      <h3>발주서가 없습니다</h3>
      <p>먼저 발주서를 생성하거나 선택해주세요</p>
    </div>
  `;
}

// 설정 필요 표시
function showShippingSetupPrompt() {
  const container = document.getElementById('shipping-tab');
  container.innerHTML = `
    <div class="setup-prompt">
      <h3>박스번호 설정이 필요합니다</h3>
      <p>설정 탭에서 박스번호를 먼저 설정해주세요</p>
      <button class="btn btn-primary" onclick="switchTab('settings')">
        설정으로 이동
      </button>
    </div>
  `;
}

// 내보내기된 항목 로드
function loadExportedItems() {
  console.log('loadExportedItems 시작');
  
  if (!AppState.currentOrderInfo || !AppState.currentOrderInfo.orderId) {
    console.error('currentOrderInfo가 없습니다');
    displayNoExportedItems();
    return;
  }
  
  // 세션이 있는지 먼저 확인
  const hasSession = ShippingState.currentBox.barcode !== null;
  console.log('기존 세션 존재:', hasSession);
  
  // 서버에서 최신 데이터 로드
  showLoading('출고 가능 항목을 불러오는 중...');
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      console.log('서버 응답:', result);
      
      if (result.success && result.items.length > 0) {
        console.log('출고 가능 항목 수:', result.items.length);
        
        // 세션이 없을 때만 상태 초기화
        if (!hasSession) {
          ShippingState.currentBox = {
            barcode: null,
            name: null,
            items: {},
            startTime: null,
            number: null
          };
        }
        
        // exportedItems는 업데이트 (세션의 박스 정보는 유지)
        ShippingState.exportedItems = result.items;
        
        // 발주서별 박스번호 설정
        if (!ShippingState.currentBoxNumber || ShippingState.currentBoxNumber === 1) {
          ShippingState.currentBoxNumber = result.currentBoxNumber || 1;
        }
        
        displayShippingInterface();
      } else {
        console.log('출고 가능한 항목이 없습니다');
        displayNoExportedItems();
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      console.error('데이터 로드 실패:', error);
      showError('데이터 로드 실패: ' + error);
      displayNoExportedItems();
    })
    .getExportedItems(AppState.currentOrderInfo.orderId);
}


// 출고 인터페이스 표시
function displayShippingInterface() {
  const container = document.getElementById('shipping-tab');
  const settings = AppState.settings;
  
  if (!settings) {
    container.innerHTML = `
      <div class="setup-prompt">
        <h3>설정이 로드되지 않았습니다</h3>
        <p>페이지를 새로고침해주세요</p>
      </div>
    `;
    return;
  }
  
  if (!settings.boxBarcodes || settings.boxBarcodes.length === 0) {
    container.innerHTML = `
      <div class="setup-prompt">
        <h3>박스 바코드를 등록해주세요</h3>
        <p>설정 탭에서 박스 바코드를 먼저 등록해야 합니다</p>
        <button class="btn btn-primary" onclick="switchTab('settings')">
          설정으로 이동
        </button>
      </div>
    `;
    return;
  }
  
  container.innerHTML = `
    <div class="shipping-container">
      <!-- 간소화된 박스 정보 -->
      <div class="box-status-bar">
        <div class="current-status">
          <span id="status-text">박스 바코드를 스캔하세요</span>
          ${ShippingState.currentBox.number ? 
            `<span class="current-box-badge">${ShippingState.currentBox.number}번 박스</span>` : 
            ''
          }
        </div>
        <div class="box-quick-info" id="box-quick-info">
          <span>다음 박스: ${ShippingState.currentBoxNumber}번</span>
          <button class="btn btn-sm" onclick="showBoxOptionsMenu()" title="박스 옵션">
            ⋮
          </button>
          <div class="box-options-menu" id="box-options-menu" style="display:none;">
            <button onclick="resetOrderBoxNumberUI()">박스번호 초기화</button>
            <button onclick="setCustomBoxNumber()">박스번호 설정</button>
          </div>
        </div>
      </div>
      
      <!-- 스캔 입력 -->
      <div class="scan-input-section">
        <div class="scan-input-wrapper">
          <input type="text" 
                 id="barcode-scan-input" 
                 class="scan-input" 
                 placeholder="클릭하여 스캔 시작..." 
                 autocomplete="off">
          <div class="scan-indicator ${ShippingState.scanState}" id="scan-indicator">
            <span class="scan-icon">📷</span>
          </div>
        </div>
      </div>
      
      <!-- 현재 박스 진행상황 -->
      <div class="box-progress-section" id="box-progress-section" style="${ShippingState.currentBox.barcode ? '' : 'display:none;'}">
        <div class="box-header">
          <h4 id="box-progress-title">
            ${ShippingState.currentBox.number ? `${ShippingState.currentBox.number}번 박스 진행 중 (${ShippingState.currentBox.name})` : ''}
          </h4>
          <div class="scan-feedback" id="scan-feedback"></div>
          <div class="box-actions">
            <button class="btn btn-sm btn-info" onclick="manualSaveSession()" title="작업 내용 저장">
              💾 임시저장
            </button>
            <button class="btn btn-sm btn-secondary" onclick="forceCompleteBox()">
              강제 완료
            </button>
          </div>
        </div>
        <div class="box-items-summary" id="box-items-summary"></div>
      </div>
      
      <!-- 출고 대상 목록 -->
      <div class="shipping-list-section">
        <div class="section-header">
          <h3>출고 대상 목록</h3>
          <div class="list-summary" id="list-summary"></div>
        </div>
        <div id="shipping-list" class="shipping-list"></div>
      </div>
    </div>
  `;

  // 옵션 메뉴 함수들
window.showBoxOptionsMenu = function() {
  const menu = document.getElementById('box-options-menu');
  if (menu) {
    menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
  }
};

window.resetOrderBoxNumberUI = function() {
  // 초기화 모달 표시 (발주 목록 초기화와 동일한 UI)
  const modalContent = `
    <div class="clear-orders-modal">
      <h3>⚠️ 박스번호 초기화</h3>
      <p class="warning-text">모든 출고 기록과 박스번호를 초기화하시겠습니까?</p>
      <p class="sub-text">현재까지 스캔한 모든 항목이 초기화되고<br>박스번호가 1번부터 다시 시작됩니다.</p>
      
      <div class="modal-actions">
        <button id="reset-box-confirm-btn" class="btn btn-danger" disabled onclick="confirmResetBoxNumber()">
          예 (<span id="reset-timer">5</span>초)
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">아니오</button>
      </div>
    </div>
  `;
  
  showModal(modalContent);
  
  // 5초 카운트다운
  let timeLeft = 5;
  const confirmBtn = document.getElementById('reset-box-confirm-btn');
  const timerSpan = document.getElementById('reset-timer');
  
  const timerInterval = setInterval(() => {
    timeLeft--;
    
    if (timeLeft > 0) {
      timerSpan.textContent = timeLeft;
    } else {
      clearInterval(timerInterval);
      confirmBtn.disabled = false;
      confirmBtn.innerHTML = '예, 초기화합니다';
      confirmBtn.classList.add('active');
    }
  }, 1000);
};

// 박스번호 초기화 확인 함수
window.confirmResetBoxNumber = function() {
  showLoading('박스번호를 초기화하는 중...');
  
  // 로컬 상태 초기화
  ShippingState.currentBox = {
    barcode: null,
    name: null,
    items: {},
    startTime: null,
    number: null
  };
  ShippingState.currentBoxNumber = 1;
  ShippingState.scanState = 'READY';
  
  // 서버에 초기화 요청
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      
      if (result.success) {
        // 세션 클리어
        localStorage.removeItem('shippingSession');
        sessionStorage.removeItem('lastExportInfo');
        
        // 출고 목록 다시 로드
        loadExportedItems();
        
        closeModal();
        showQuickSuccess('박스번호가 초기화되었습니다.');
      } else {
        showError('초기화 실패: ' + result.message);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('초기화 실패: ' + error);
    })
    .resetAllBoxNumbers(AppState.currentOrderInfo.orderId);
};

window.setCustomBoxNumber = function() {
  const newNumber = prompt('시작할 박스번호를 입력하세요:', ShippingState.currentBoxNumber);
  if (newNumber && !isNaN(newNumber)) {
    const boxNumber = parseInt(newNumber);
    if (boxNumber > 0) {
      ShippingState.currentBoxNumber = boxNumber;
      google.script.run
        .setOrderBoxNumber(AppState.currentOrderInfo.orderId, boxNumber);
      
      const boxQuickInfo = document.getElementById('box-quick-info');
      if (boxQuickInfo) {
        boxQuickInfo.querySelector('span').textContent = `다음 박스: ${boxNumber}번`;
      }
      showQuickSuccess(`박스번호가 ${boxNumber}번으로 설정되었습니다.`);
    }
  }
};
  
  setupScanInput();
  displayShippingList();
  
  if (ShippingState.currentBox.barcode) {
    updateBoxProgress();
  }
  
  startShippingAutoSave();
}

function manualSaveSession() {
  saveShippingSession();
  
  // 서버에도 즉시 저장
  const sessionData = {
    currentBox: ShippingState.currentBox,
    currentBoxNumber: ShippingState.currentBoxNumber,
    scanState: ShippingState.scanState,
    exportedItems: ShippingState.exportedItems,
    lastActivity: new Date().toISOString(),
    orderId: AppState.currentOrderInfo?.orderId
  };
  
  google.script.run
    .withSuccessHandler(() => {
      showQuickSuccess('작업 내용이 저장되었습니다.');
    })
    .withFailureHandler((error) => {
      showError('저장 실패: ' + error);
    })
    .saveShippingSession(sessionData);
}

// 출고 대상이 없을 때
function displayNoExportedItems() {
  const container = document.getElementById('shipping-tab');
  container.innerHTML = `
    <div class="empty-state">
      <div class="empty-icon">📤</div>
      <h3>출고 가능한 항목이 없습니다</h3>
      <p>내보내기가 완료된 항목만 출고할 수 있습니다</p>
      <p class="text-muted">품절/오더중 항목은 제외됩니다</p>
    </div>
  `;
}

// 스캔 입력 설정
function setupScanInput() {
  const scanInput = document.getElementById('barcode-scan-input');
  if (!scanInput) return;
  
  scanInput.placeholder = '클릭하여 스캔 시작...';
  
  scanInput.addEventListener('click', function() {
    this.placeholder = '박스 또는 상품 바코드를 스캔하세요...';
  });
  
  scanInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      const barcode = e.target.value.trim();
      
      if (barcode) {
        handleBarcodeScan(barcode);
        // 입력창 초기화
        e.target.value = '';
        // 포커스 유지
        e.target.focus();
      }
    }
  });
  
  // blur 이벤트에서 자동 포커스 제거
  scanInput.addEventListener('blur', function() {
    const shippingTab = document.getElementById('shipping-tab');
    if (shippingTab && shippingTab.classList.contains('active')) {
      this.placeholder = '클릭하여 스캔 재개...';
    }
  });
}

// ===== 박스 바코드 관리 함수들 =====

// 박스 바코드 추가
function addBoxBarcode() {
  const barcodeInput = document.getElementById('new-box-barcode');
  const nameInput = document.getElementById('new-box-name');
  
  const barcode = barcodeInput.value.trim();
  const name = nameInput.value.trim();
  
  if (!barcode) {
    showError('박스 바코드를 입력해주세요.');
    return;
  }
  
  // 이름이 없으면 자동 생성
  const boxName = name || `박스 ${(AppState.settings.boxBarcodes?.length || 0) + 1}`;
  
  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        // 설정 업데이트
        AppState.settings.boxBarcodes = result.boxBarcodes;
        
        // UI 업데이트
        displayBoxBarcodes();
        
        // 입력 필드 초기화
        barcodeInput.value = '';
        nameInput.value = '';
        
        showQuickSuccess('박스 바코드가 추가되었습니다.');
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('추가 실패: ' + error);
    })
    .addBoxBarcode(barcode, boxName);
}

// 박스 바코드 삭제
function removeBoxBarcode(barcode) {
  if (!confirm('이 박스 바코드를 삭제하시겠습니까?')) {
    return;
  }
  
  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        // 설정 업데이트
        AppState.settings.boxBarcodes = result.boxBarcodes;
        
        // UI 업데이트
        displayBoxBarcodes();
        
        showQuickSuccess('박스 바코드가 삭제되었습니다.');
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('삭제 실패: ' + error);
    })
    .removeBoxBarcode(barcode);
}

// 박스 바코드 목록 표시
function displayBoxBarcodes() {
  const container = document.getElementById('registered-boxes-list');
  const boxBarcodes = AppState.settings.boxBarcodes || [];
  
  if (boxBarcodes.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <p>등록된 박스 바코드가 없습니다.</p>
      </div>
    `;
    return;
  }
  
  container.innerHTML = boxBarcodes.map(box => `
    <div class="box-barcode-item">
      <div class="box-barcode-info">
        <span class="box-barcode-name">${box.name}</span>
        <span class="box-barcode-code">${box.barcode}</span>
      </div>
      <div class="box-barcode-actions">
        <button class="btn-delete" onclick="removeBoxBarcode('${box.barcode}')">
          삭제
        </button>
      </div>
    </div>
  `).join('');
}

// 설정 탭 로드 시 박스 바코드도 표시
function loadSettingsTab() {
  if (AppState.settings && Object.keys(AppState.settings).length > 0) {
    displaySettings(AppState.settings);
  } else {
    google.script.run
      .withSuccessHandler((settings) => {
        AppState.settings = settings;
        displaySettings(settings);
      })
      .withFailureHandler(() => {
        displaySettings({});
      })
      .getSettings();
  }
  
  setTimeout(() => {
    initializeDisplaySettings();
    displayBoxBarcodes();        // 기존 기능
    displayVoiceSettings();      // 새 기능 추가
  }, 200);
}

// 박스 바코드 입력 필드에 Enter 키 이벤트 추가
document.addEventListener('DOMContentLoaded', function() {
  const barcodeInput = document.getElementById('new-box-barcode');
  const nameInput = document.getElementById('new-box-name');
  
  if (barcodeInput) {
    barcodeInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        
        // 이름 입력 필드로 포커스 이동 또는 추가
        if (!nameInput.value.trim()) {
          nameInput.focus();
        } else {
          addBoxBarcode();
        }
      }
    });
  }
  
  if (nameInput) {
    nameInput.addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        addBoxBarcode();
      }
    });
  }
});

// 출고 탭에서 박스 통계 표시
function displayShippingStats() {
  if (!AppState.currentOrderInfo) return;
  
  google.script.run
    .withSuccessHandler(function(stats) {
      const quickInfo = document.getElementById('box-quick-info');
      
      if (quickInfo && stats) {
        quickInfo.innerHTML = `
          <span>총 박스: ${stats.totalBoxes}개</span>
          <span>총 수량: ${stats.totalQuantity}개</span>
        `;
      }
    })
    .withFailureHandler(function(error) {
      console.warn('출고 통계 로드 실패:', error);
    })
    .getShippingStats(AppState.currentOrderInfo.orderId);
}

// 출고 탭 로드 시 통계도 표시
const originalLoadShippingTab = loadShippingTab;
loadShippingTab = function() {
  originalLoadShippingTab();
  
  // 통계 표시
  setTimeout(() => {
    displayShippingStats();
  }, 500);
};

// 박스 완료 후 통계 업데이트
const originalCompleteBox = completeBox;
completeBox = function(callback) {
  originalCompleteBox(() => {
    // 통계 업데이트
    displayShippingStats();
    
    // 원래 콜백 실행
    if (callback) callback();
  });
};


// 박스 정보 가져오기
function getBoxInfoFromSettings(barcode) {
  const boxBarcodes = AppState.settings.boxBarcodes || [];
  return boxBarcodes.find(box => box.barcode === barcode);
}

// 바코드 스캔 처리 수정
function handleBarcodeScan(barcode) {
  console.log('=== 바코드 스캔 처리 시작 ===');
  console.log('스캔된 바코드:', barcode);
  console.log('현재 박스 상태:', ShippingState.currentBox);
  console.log('설정된 박스들:', AppState.settings?.boxBarcodes);
  
  // 등록된 박스 바코드인지 확인
  const boxInfo = getBoxInfoFromSettings(barcode);
  console.log('박스 정보 확인 결과:', boxInfo);
  
  if (boxInfo) {
    // 박스 바코드인 경우
    console.log('박스 바코드로 인식됨');
    handleBoxScan(barcode, boxInfo);
    return;
  }
  
  // 박스 바코드가 아닌 경우 = 제품 바코드
  console.log('제품 바코드로 인식됨');
  
  // 현재 박스가 없으면 에러
  if (!ShippingState.currentBox.barcode) {
    console.log('현재 박스 없음 - 에러 처리');
    speak('오류. 박스 바코드를 먼저 스캔하세요');
    showError('박스 바코드를 먼저 스캔해주세요.');
    showScanFeedback('박스 바코드를 먼저 스캔하세요', 'error');
    return;
  }
  
  // 제품 스캔 처리
  handleProductScan(barcode);
}

// 박스 시작 함수 통합
function startBox(identifier) {
  const settings = AppState.settings;
  
  if (settings.boxMode === 'number') {
    startBoxWithNumber(identifier);
  } else {
    const boxInfo = getBoxInfoFromSettings(identifier);
    startBoxWithBarcode(identifier, boxInfo);
  }
}

// ===== scripts.html에 추가할 함수들 (출고 관련 함수들 위에 추가) =====

// 박스 식별자 확인 함수 - 클라이언트 사이드
function isBoxBarcode(identifier) {
  const settings = AppState.settings;
  
  if (!settings) {
    console.error('설정이 로드되지 않았습니다');
    return false;
  }
  
  if (settings.boxMode === 'barcode') {
    // 바코드 모드: 등록된 바코드인지 확인
    const boxBarcodes = settings.boxBarcodes || [];
    return boxBarcodes.some(box => box.barcode === identifier);
  } else {
    // 번호 모드: 숫자이고 설정된 자릿수인지 확인
    const digits = parseInt(settings.boxDigits) || 3;
    return identifier.length === digits && /^\d+$/.test(identifier);
  }
}

// 박스 정보 가져오기 - 클라이언트 사이드
function getBoxInfoFromSettings(identifier) {
  console.log('=== getBoxInfoFromSettings 시작 ===');
  
  const settings = AppState.settings;
  
  if (!settings) {
    console.error('설정이 로드되지 않았습니다');
    return null;
  }
  
  // 1. 먼저 등록된 박스 바코드에서 확인 (모드와 관계없이)
  const boxBarcodes = settings.boxBarcodes || [];
  console.log('등록된 박스 바코드 목록:', boxBarcodes);
  
  const registeredBox = boxBarcodes.find(box => box.barcode === identifier);
  if (registeredBox) {
    console.log('등록된 박스 바코드 찾음:', registeredBox);
    return registeredBox;
  }
  
  // 2. 번호 모드일 때 숫자 패턴 확인
  if (settings.boxMode === 'number') {
    const digits = parseInt(settings.boxDigits) || 3;
    const pattern = new RegExp(`^\\d{${digits}}$`);
    
    if (pattern.test(identifier)) {
      const boxInfo = {
        barcode: identifier,
        name: `박스 ${identifier}`,
        isAutoNumber: true
      };
      console.log('번호 모드 박스로 인식:', boxInfo);
      return boxInfo;
    }
  }
  
  console.log('박스가 아님 - 제품 바코드로 판단');
  return null;
}

// 박스 시작 함수 - 번호 방식
function startBoxWithNumber(boxNumber) {
  ShippingState.currentBox = {
    number: boxNumber,
    barcode: boxNumber,
    name: `박스 ${boxNumber}`,
    items: {},
    startTime: new Date().toISOString() // Date 객체 대신 ISO 문자열로
  };
  
  ShippingState.scanState = 'SCANNING';
  
  // UI 업데이트
  document.getElementById('status-text').textContent = `박스 ${boxNumber} 스캔 중`;
  
  // 박스 진행상황 섹션 추가
  const container = document.querySelector('.shipping-container');
  const progressSection = document.getElementById('box-progress-section');
  
  if (!progressSection) {
    const scanSection = document.querySelector('.scan-input-section');
    const newProgressSection = document.createElement('div');
    newProgressSection.className = 'box-progress-section';
    newProgressSection.id = 'box-progress-section';
    newProgressSection.innerHTML = `
      <div class="box-header">
        <h4>박스 ${boxNumber} 진행 중</h4>
        <button class="btn btn-sm btn-secondary" onclick="forceCompleteBox()">
          강제 완료
        </button>
      </div>
      <div class="box-items-summary" id="box-items-summary"></div>
    `;
    scanSection.insertAdjacentElement('afterend', newProgressSection);
  }
  
  updateBoxProgress();
  
  speak(`박스 ${boxNumber} 시작`);
  showScanFeedback(`박스 ${boxNumber} 스캔 시작`, 'success');
  
  // 세션 저장
  saveShippingSession();
}

// handleBoxScan 함수 수정
function handleBoxScan(boxBarcode, boxInfo) {
  if (ShippingState.isSaving) {
    speak('잠시만 기다려주세요');
    showError('이전 박스를 저장 중입니다.');
    return;
  }
  
  if (!ShippingState.currentBox.barcode) {
    // 새 박스 시작 - 음성 안내는 startBoxWithBarcode에서만
    startBoxWithBarcode(boxBarcode, boxInfo);
  } else if (boxBarcode === ShippingState.currentBox.barcode) {
    // 같은 박스 바코드 = 박스 완료
    if (Object.keys(ShippingState.currentBox.items).length === 0) {
      speak('오류. 스캔된 항목이 없습니다');
      showError('스캔된 항목이 없습니다');
      return;
    }
    completeBox();
  } else {
    // 다른 박스 바코드 = 박스 전환
    if (Object.keys(ShippingState.currentBox.items).length === 0) {
      resetBoxState();
      startBoxWithBarcode(boxBarcode, boxInfo);
    } else {
      completeBox(() => {
        startBoxWithBarcode(boxBarcode, boxInfo);
      });
    }
  }
}

// completeBox 함수도 수정 필요
function completeBox(callback) {
  if (!ShippingState.currentBox.barcode) {
    speak('오류. 진행 중인 박스가 없습니다');
    showError('진행 중인 박스가 없습니다');
    return;
  }
  
  if (Object.keys(ShippingState.currentBox.items).length === 0) {
    speak('오류. 스캔된 항목이 없습니다');
    showError('스캔된 항목이 없습니다');
    return;
  }
  
  if (ShippingState.isSaving) {
    speak('잠시만 기다려주세요');
    showError('이전 박스를 저장 중입니다. 잠시 후 다시 시도해주세요.');
    return;
  }
  
  const boxNumber = ShippingState.currentBox.number;
  const itemCount = Object.values(ShippingState.currentBox.items)
    .reduce((sum, item) => sum + item.scannedInThisBox, 0);
  
  // 로딩 모달 표시
  showLoading(`${boxNumber}번 박스를 저장하는 중입니다...`);
  
  // UI 즉시 업데이트
  updateUIForBoxCompletion();
  
  // 저장 상태 설정
  ShippingState.isSaving = true;
  
  google.script.run
    .withSuccessHandler(function(result) {
      ShippingState.isSaving = false;
      hideLoading(); // 로딩 모달 숨기기
      
      if (result.success) {
        updateLocalStateAfterBoxComplete();
        ShippingState.currentBoxNumber++;
        
        // 서버에 박스번호 업데이트
        google.script.run
          .setOrderBoxNumber(AppState.currentOrderInfo.orderId, ShippingState.currentBoxNumber);
        
        resetBoxState();
        
        speak(`${boxNumber}번 박스 완료`);
        showQuickSuccess(`${boxNumber}번 박스 완료 (${itemCount}개)`);
        
        // 완료 후 세션 저장
        saveShippingSession();
        
        if (callback) callback();
      } else {
        ShippingState.isSaving = false;
        speak('오류. 저장 실패');
        showError('저장 실패: ' + result.message);
        rollbackBoxCompletion();
      }
    })
    .withFailureHandler(function(error) {
      ShippingState.isSaving = false;
      hideLoading(); // 로딩 모달 숨기기
      speak('오류. 저장 실패');
      showError('저장 실패: ' + error);
      rollbackBoxCompletion();
    })
    .saveShippingData(AppState.currentOrderInfo.orderId, {
      boxBarcode: ShippingState.currentBox.barcode,
      boxName: `${boxNumber}번 박스`,
      items: Object.values(ShippingState.currentBox.items)
    });
}

function handleBarcodeScan(barcode) {
  console.log('스캔된 바코드:', barcode, '현재 박스:', ShippingState.currentBox);
  
  // 등록된 박스 바코드인지 확인
  const boxInfo = getBoxInfoFromSettings(barcode);
  
  if (boxInfo) {
    // 박스 바코드인 경우
    handleBoxScan(barcode, boxInfo);
    return;
  }
  
  // 박스 바코드가 아닌 경우 = 제품 바코드
  // 현재 박스가 없으면 에러
  if (!ShippingState.currentBox.barcode) {
    speak('오류. 박스 바코드를 먼저 스캔하세요');
    showError('박스 바코드를 먼저 스캔해주세요.');
    return;
  }
  
  // 제품 스캔 처리
  handleProductScan(barcode);
}

function getBoxInfoFromSettings(identifier) {
  console.log('=== getBoxInfoFromSettings 시작 ===');
  console.log('찾는 바코드:', identifier);
  
  const settings = AppState.settings;
  
  if (!settings) {
    console.error('설정이 로드되지 않았습니다');
    return null;
  }
  
  // 설정 상태 출력
  console.log('현재 설정:', {
    boxMode: settings.boxMode,
    boxBarcodes: settings.boxBarcodes,
    boxDigits: settings.boxDigits
  });
  
  // 등록된 박스 바코드 확인
  const boxBarcodes = settings.boxBarcodes || [];
  
  // 각 박스 바코드 상세 출력
  boxBarcodes.forEach((box, index) => {
    console.log(`박스 ${index + 1}:`, {
      barcode: box.barcode,
      name: box.name,
      일치여부: box.barcode === identifier
    });
  });
  
  const registeredBox = boxBarcodes.find(box => box.barcode === identifier);
  
  if (registeredBox) {
    console.log('✅ 등록된 박스 찾음:', registeredBox);
    return registeredBox;
  }
  
  console.log('❌ 등록된 박스에서 찾지 못함');
  
  // 번호 모드 체크는 등록된 박스가 없을 때만
  if (settings.boxMode === 'number' && boxBarcodes.length === 0) {
    const digits = parseInt(settings.boxDigits) || 3;
    const pattern = new RegExp(`^\\d{${digits}}$`);
    
    if (pattern.test(identifier)) {
      const boxInfo = {
        barcode: identifier,
        name: `박스 ${identifier}`,
        isAutoNumber: true
      };
      console.log('번호 모드 박스로 인식:', boxInfo);
      return boxInfo;
    }
  }
  
  console.log('박스가 아님 - 제품 바코드로 판단');
  return null;
}

function handleProductScan(barcode) {
  console.log('제품 스캔:', barcode);
  
  const item = ShippingState.exportedItems.find(i => i.barcode === barcode);
  
  if (!item) {
    speak('오류. 출고 목록에 없는 제품입니다');
    showScanFeedback('출고 목록에 없는 바코드입니다', 'error');
    return;
  }
  
  // 현재 박스에 추가
  if (!ShippingState.currentBox.items[barcode]) {
    ShippingState.currentBox.items[barcode] = {
      ...item,
      scannedInThisBox: 0,
      justScanned: false
    };
  }
  
  const boxItem = ShippingState.currentBox.items[barcode];
  
  // 수량 체크
  if (boxItem.scannedInThisBox < item.remainingQuantity) {
    boxItem.scannedInThisBox++;
    boxItem.justScanned = true; // 애니메이션 플래그
    
    updateShippingItemUI(barcode);
    updateBoxProgress();
    
    // 애니메이션 후 플래그 제거
    setTimeout(() => {
      if (ShippingState.currentBox.items[barcode]) {
        ShippingState.currentBox.items[barcode].justScanned = false;
        updateBoxProgress();
      }
    }, 300);
    
    speak('정상');
    showScanFeedback(`${item.name} - ${boxItem.scannedInThisBox}/${item.remainingQuantity}`, 'success');
  } else {
    // 초과 수량
    speak('오류. 수량 초과');
    showExcessQuantityModal(item, boxItem);
  }
}

// 박스 시작
function startBoxWithBarcode(boxBarcode, boxInfo) {
  ShippingState.currentBox = {
    barcode: boxBarcode,
    name: boxInfo.name,
    items: {},
    startTime: new Date().toISOString(),
    number: ShippingState.currentBoxNumber
  };
  
  ShippingState.scanState = 'SCANNING';
  
  document.getElementById('status-text').textContent = `${ShippingState.currentBoxNumber}번 박스 스캔 중`;
  
  // 박스 진행상황 섹션 보이기
  const progressSection = document.getElementById('box-progress-section');
  if (progressSection) {
    progressSection.style.display = '';
    
    // 제목 업데이트
    const titleEl = document.getElementById('box-progress-title');
    if (titleEl) {
      titleEl.textContent = `${ShippingState.currentBoxNumber}번 박스 진행 중 (${boxInfo.name})`;
    }
  }
  
  updateBoxProgress();
  
  // 음성 안내
  speak(`${ShippingState.currentBoxNumber}번 박스 시작`);
  showScanFeedback(`${ShippingState.currentBoxNumber}번 박스 스캔 시작`, 'success');
  
  saveShippingSession();
}

AppState.voiceSettings = {
  volume: 0.8,
  rate: 1.2,
  pitch: 1.0,
  language: 'ko-KR'
};

// 개선된 speak 함수 (기존 함수 교체)
function speak(text) {
  if (!text || typeof text !== 'string') return;
  
  try {
    // 음성 합성 지원 확인
    if (!window.speechSynthesis) {
      console.warn('음성 합성을 지원하지 않는 브라우저입니다.');
      return;
    }
    
    // 이전 음성 중단
    speechSynthesis.cancel();
    
    const utterance = new SpeechSynthesisUtterance(text);
    const settings = AppState.voiceSettings;
    
    // 음성 설정 적용
    utterance.volume = settings.volume;
    utterance.rate = settings.rate;
    utterance.pitch = settings.pitch;
    utterance.lang = settings.language;
    
    // 오류 처리
    utterance.onerror = function(event) {
      console.warn('음성 합성 오류:', event.error);
    };
    
    speechSynthesis.speak(utterance);
  } catch (error) {
    console.error('speak 함수 오류:', error);
  }
}

// 음성 설정 로드 함수
async function loadVoiceSettings() {
  return new Promise((resolve) => {
    google.script.run
      .withSuccessHandler((settings) => {
        if (settings && settings.voiceSettings) {
          AppState.voiceSettings = settings.voiceSettings;
          console.log('음성 설정 로드됨:', AppState.voiceSettings);
        }
        resolve(AppState.voiceSettings);
      })
      .withFailureHandler((error) => {
        console.warn('음성 설정 로드 실패:', error);
        resolve(AppState.voiceSettings); // 기본값 사용
      })
      .getVoiceSettings();
  });
}

// 음성 설정 저장 함수
function saveVoiceSettings() {
  const volume = parseFloat(document.getElementById('voice-volume').value);
  const rate = parseFloat(document.getElementById('voice-rate').value);
  const pitch = parseFloat(document.getElementById('voice-pitch').value);
  const language = document.getElementById('voice-language').value;
  
  const voiceSettings = {
    volume: volume,
    rate: rate,
    pitch: pitch,
    language: language
  };
  
  // 로컬 설정 즉시 적용
  AppState.voiceSettings = voiceSettings;
  
  // 서버에 저장
  showSaveIndicator('saving');
  
  google.script.run
    .withSuccessHandler((result) => {
      showSaveIndicator('hide');
      if (result.success) {
        showQuickSuccess('음성 설정이 저장되었습니다.');
      } else {
        showError('음성 설정 저장 실패: ' + result.message);
      }
    })
    .withFailureHandler((error) => {
      showSaveIndicator('hide');
      showError('음성 설정 저장 실패: ' + error);
    })
    .saveVoiceSettings(voiceSettings);
}

// 음성 테스트 함수
function testVoiceSettings() {
  const testText = getVoiceTestText();
  speak(testText);
}

// 언어별 테스트 텍스트
function getVoiceTestText() {
  const language = AppState.voiceSettings.language;
  const testTexts = {
    'ko-KR': '음성 설정 테스트. 물류팀 화이팅!!!',
    'ja-JP': '音声設定のテスト。物流チーム頑張れ！！！',
    'en-US': 'Voice settings test. Logistics team, cheer up!!!'
  };
  
  return testTexts[language] || testTexts['ko-KR'];
}

// 설정 탭 로드 시 음성 설정 표시
function displayVoiceSettings() {
  const settings = AppState.voiceSettings;
  
  // 폼 요소에 현재 설정 값 적용
  const volumeInput = document.getElementById('voice-volume');
  const rateInput = document.getElementById('voice-rate');
  const pitchInput = document.getElementById('voice-pitch');
  const languageSelect = document.getElementById('voice-language');
  
  if (volumeInput) {
    volumeInput.value = settings.volume;
    document.getElementById('voice-volume-value').textContent = Math.round(settings.volume * 100) + '%';
  }
  
  if (rateInput) {
    rateInput.value = settings.rate;
    document.getElementById('voice-rate-value').textContent = settings.rate + 'x';
  }
  
  if (pitchInput) {
    pitchInput.value = settings.pitch;
    document.getElementById('voice-pitch-value').textContent = settings.pitch;
  }
  
  if (languageSelect) {
    languageSelect.value = settings.language;
  }
}

// 슬라이더 값 실시간 업데이트
function updateVoiceSliderValue(sliderId, valueId, unit = '') {
  const slider = document.getElementById(sliderId);
  const valueDisplay = document.getElementById(valueId);
  
  if (slider && valueDisplay) {
    let displayValue = parseFloat(slider.value);
    
    if (sliderId === 'voice-volume') {
      displayValue = Math.round(displayValue * 100) + '%';
    } else if (sliderId === 'voice-rate') {
      displayValue = displayValue + 'x';
    } else {
      displayValue = displayValue + unit;
    }
    
    valueDisplay.textContent = displayValue;
    
    // 실시간으로 로컬 설정 업데이트 (테스트용)
    if (sliderId === 'voice-volume') {
      AppState.voiceSettings.volume = parseFloat(slider.value);
    } else if (sliderId === 'voice-rate') {
      AppState.voiceSettings.rate = parseFloat(slider.value);
    } else if (sliderId === 'voice-pitch') {
      AppState.voiceSettings.pitch = parseFloat(slider.value);
    }
  }
}

// 언어 변경 시 실시간 업데이트
function updateVoiceLanguage() {
  const language = document.getElementById('voice-language').value;
  AppState.voiceSettings.language = language;
}

// UI 즉시 업데이트
function updateUIForBoxCompletion() {
  Object.entries(ShippingState.currentBox.items).forEach(([barcode, boxItem]) => {
    const item = ShippingState.exportedItems.find(i => i.barcode === barcode);
    if (item) {
      // 로컬 remainingQuantity 업데이트
      item.remainingQuantity -= boxItem.scannedInThisBox;
      item.scannedQuantity = (item.scannedQuantity || 0) + boxItem.scannedInThisBox;
      
      // 박스정보 추가
      const newBoxInfo = `${ShippingState.currentBox.name}(${boxItem.scannedInThisBox})`;
      item.boxNumbers = item.boxNumbers ? 
        `${item.boxNumbers}, ${newBoxInfo}` : 
        newBoxInfo;
    }
  });
  
  // 목록 다시 표시
  displayShippingList();
}

// 로컬 상태 업데이트
function updateLocalStateAfterBoxComplete() {
  // 완료된 항목 제거
  ShippingState.exportedItems = ShippingState.exportedItems
    .filter(item => item.remainingQuantity > 0);
}

// 박스 상태 초기화
function resetBoxState() {
  ShippingState.currentBox = {
    barcode: null,
    name: null,
    items: {},
    startTime: null
  };
  
  ShippingState.scanState = 'READY';
  
  // UI 업데이트
  document.getElementById('status-text').textContent = '박스 바코드를 스캔하세요';
  
  // 박스 진행상황 섹션 숨기기
  const progressSection = document.getElementById('box-progress-section');
  if (progressSection) {
    progressSection.style.display = 'none';
  }
  
  // 피드백 초기화
  const feedback = document.getElementById('scan-feedback');
  if (feedback) {
    feedback.textContent = '';
    feedback.className = 'scan-feedback';
  }
  
  // 세션 저장
  saveShippingSession();
}

// 강제 완료
function forceCompleteBox() {
  if (confirm('현재 박스를 완료하시겠습니까?')) {
    completeBox();
  }
}

// 스캔 피드백 표시
function showScanFeedback(message, type) {
  const feedback = document.getElementById('scan-feedback');
  if (feedback) {
    feedback.textContent = message;
    feedback.className = `scan-feedback ${type}`;
    
    clearTimeout(ShippingState.feedbackTimer);
    ShippingState.feedbackTimer = setTimeout(() => {
      feedback.className = 'scan-feedback';
      feedback.textContent = '';
    }, 3000);
  }
}

// 출고 목록 표시
function displayShippingList() {
  const container = document.getElementById('shipping-list');
  const summary = document.getElementById('list-summary');
  
  if (!ShippingState.exportedItems || ShippingState.exportedItems.length === 0) {
    container.innerHTML = '<div class="empty-message">출고 완료</div>';
    summary.textContent = '';
    return;
  }
  
  const totalItems = ShippingState.exportedItems.length;
  const totalQuantity = ShippingState.exportedItems
    .reduce((sum, item) => sum + item.remainingQuantity, 0);
  
  summary.textContent = `${totalItems}개 상품, 총 ${totalQuantity}개`;
  
  // 기존 컬러칩 관련 설정 가져오기
  const displaySettings = loadDisplaySettings();
  
  container.innerHTML = ShippingState.exportedItems.map(item => {
    const progress = item.scannedQuantity || 0;
    const total = item.quantity;
    const progressPercent = total > 0 ? (progress / total * 100) : 0;
    const isCompleted = item.remainingQuantity === 0;
    
    // 박스 정보 포맷 개선
    let boxInfo = '';
    if (item.boxNumbers) {
      boxInfo = item.boxNumbers.replace(/(\d+)\((\d+)\)/g, '$1번($2개)')
                              .replace(/\), /g, ') / ');
    }
    
    // 컬러/사이즈 정보 파싱
    const colorSizeInfo = parseColorSize(item.option);
    let optionHtml = '';
    
    if (item.option && colorSizeInfo.color) {
      optionHtml = `
        <div class="item-option-with-color">
          ${displaySettings.colorChipEnabled !== false && colorSizeInfo.colorHex ? 
            `<span class="color-chip-container">
              <span class="color-chip" style="background-color: ${colorSizeInfo.colorHex}"></span>
              <span class="color-name">${colorSizeInfo.color}</span>
            </span>` : 
            `<span class="color-text">${colorSizeInfo.color}</span>`
          }
          ${colorSizeInfo.size ? `<span class="size-text">${colorSizeInfo.size}</span>` : ''}
        </div>
      `;
    } else if (item.option) {
      optionHtml = `<span class="item-option">${item.option}</span>`;
    }
    
    return `
      <div class="shipping-item ${ShippingState.currentBox.items[item.barcode] ? 'scanning' : ''} ${isCompleted ? 'completed' : ''}" 
          data-barcode="${item.barcode}"
          style="background: linear-gradient(to right, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.1) ${progressPercent}%, transparent ${progressPercent}%, transparent 100%);">
        <div class="item-header">
          <div class="item-name">${item.name}</div>
          <div class="item-details">
            ${optionHtml}
          </div>
          <div class="item-barcode">${item.barcode}</div>
        </div>

        <div class="quantity-info">
          <div class="quantity-display">
            <span class="scanned-quantity">${progress}</span>
            <span class="separator">/</span>
            <span class="total-quantity">${total}</span>
          </div>
          <div class="remaining-badge">
            ${isCompleted ? 
              '<strong style="color: #28a745;">✓ 완료</strong>' :
              `남은수량: <strong>${item.remainingQuantity}</strong>`
            }
          </div>
        </div>
        
        ${boxInfo ? `
          <div class="box-info">
            <span class="box-icon">📦</span>
            <span class="box-numbers">${boxInfo}</span>
          </div>
        ` : ''}
      </div>
    `;
  }).join('');
}

// 재고 상태 클래스
function getStockClass(status) {
  if (status === '가능') return 'status-available';
  if (status.includes('개만 가능')) return 'status-partial';
  return 'status-default';
}

// 아이템 UI 업데이트
function updateShippingItemUI(barcode) {
  requestAnimationFrame(() => {
    const element = document.querySelector(`[data-barcode="${barcode}"]`);
    if (!element) return;
    
    const item = ShippingState.exportedItems.find(i => i.barcode === barcode);
    const boxItem = ShippingState.currentBox.items[barcode];
    
    if (!item || !boxItem) return;
    
    // 애니메이션
    element.classList.add('just-scanned');
    setTimeout(() => element.classList.remove('just-scanned'), 300);
    
    // 하이라이트 표시
    if (!element.classList.contains('scanning')) {
      element.classList.add('scanning');
    }
  });
}

// 박스 진행상황 업데이트
function updateBoxProgress() {
  const summary = document.getElementById('box-items-summary');
  const items = Object.values(ShippingState.currentBox.items);
  
  if (items.length === 0) {
    summary.innerHTML = '<div class="empty-box">아직 스캔된 항목이 없습니다</div>';
    return;
  }
  
  const totalScanned = items.reduce((sum, item) => sum + item.scannedInThisBox, 0);
  const displaySettings = loadDisplaySettings();
  
  summary.innerHTML = `
    <div class="box-summary">
      <div class="summary-stat">
        <span class="stat-label">상품 종류:</span>
        <span class="stat-value">${items.length}개</span>
      </div>
      <div class="summary-stat">
        <span class="stat-label">총 수량:</span>
        <span class="stat-value">${totalScanned}개</span>
      </div>
    </div>
    <div class="box-items">
      ${items.map(item => {
        const remaining = item.remainingQuantity - item.scannedInThisBox;
        const colorSizeInfo = parseColorSize(item.option);
        
        let optionHtml = '';
        if (item.option && colorSizeInfo.color) {
          optionHtml = `
            <div class="item-option-with-color">
              ${displaySettings.colorChipEnabled !== false && colorSizeInfo.colorHex ? 
                `<span class="color-chip-container">
                  <span class="color-chip" style="background-color: ${colorSizeInfo.colorHex}"></span>
                  <span class="color-name">${colorSizeInfo.color}</span>
                </span>` : 
                `<span class="color-text">${colorSizeInfo.color}</span>`
              }
              ${colorSizeInfo.size ? `<span class="size-text">${colorSizeInfo.size}</span>` : ''}
            </div>
          `;
        } else if (item.option) {
          optionHtml = `<span class="item-option">${item.option}</span>`;
        }
        
        return `
          <div class="box-item ${item.justScanned ? 'just-scanned' : ''}" data-barcode="${item.barcode}">
            <div class="box-item-info">
              <span class="item-name">${item.name}</span>
              ${optionHtml}
            </div>
            <div class="box-item-qty">
              <span class="item-qty">${item.scannedInThisBox}개</span>
              <span class="item-remaining">(남은수량: ${remaining}개)</span>
            </div>
            <div class="box-item-actions">
              <button class="btn-icon-sm" onclick="adjustBoxItemQuantity('${item.barcode}', -1)" 
                      title="수량 감소" ${item.scannedInThisBox <= 1 ? 'disabled' : ''}>
                <span>−</span>
              </button>
              <button class="btn-icon-sm" onclick="adjustBoxItemQuantity('${item.barcode}', 1)" 
                      title="수량 증가" ${remaining <= 0 ? 'disabled' : ''}>
                <span>+</span>
              </button>
              <button class="btn-icon-sm danger" onclick="removeBoxItem('${item.barcode}')" 
                      title="박스에서 제거">
                <span>×</span>
              </button>
            </div>
          </div>
        `;
      }).join('')}
    </div>
  `;
}

// 박스 아이템 수량 조정 함수 추가
function adjustBoxItemQuantity(barcode, delta) {
  const boxItem = ShippingState.currentBox.items[barcode];
  const exportedItem = ShippingState.exportedItems.find(i => i.barcode === barcode);
  
  if (!boxItem || !exportedItem) return;
  
  const newQuantity = boxItem.scannedInThisBox + delta;
  const maxQuantity = exportedItem.remainingQuantity + boxItem.scannedInThisBox;
  
  if (newQuantity >= 1 && newQuantity <= maxQuantity) {
    boxItem.scannedInThisBox = newQuantity;
    
    // 남은 수량 업데이트
    exportedItem.remainingQuantity = exportedItem.quantity - 
      (exportedItem.scannedQuantity - boxItem.scannedInThisBox + newQuantity);
    
    updateBoxProgress();
    updateShippingItemUI(barcode);
    saveShippingSession();
    
    speak(delta > 0 ? '추가' : '감소');
    showScanFeedback(`${exportedItem.name} - ${newQuantity}개`, 'success');
  }
}

function removeBoxItem(barcode) {
  const boxItem = ShippingState.currentBox.items[barcode];
  const exportedItem = ShippingState.exportedItems.find(i => i.barcode === barcode);
  
  if (!boxItem || !exportedItem) return;
  
  if (confirm(`${exportedItem.name}을(를) 박스에서 제거하시겠습니까?`)) {
    // 남은 수량 복원
    exportedItem.remainingQuantity += boxItem.scannedInThisBox;
    
    // 박스에서 제거
    delete ShippingState.currentBox.items[barcode];
    
    updateBoxProgress();
    updateShippingItemUI(barcode);
    saveShippingSession();
    
    speak('제거됨');
    showScanFeedback(`${exportedItem.name} 제거됨`, 'info');
  }
}

// 초과 수량 모달
function showExcessQuantityModal(item, boxItem) {
  const modalContent = `
    <div class="excess-modal">
      <h3>⚠️ 수량 초과</h3>
      <div class="item-info">
        <strong>${item.name}</strong>
        ${item.option ? `<span class="option">${item.option}</span>` : ''}
      </div>
      <div class="quantity-status">
        <p>요청 수량: <strong>${item.quantity}개</strong></p>
        <p>현재까지 스캔: <strong>${item.scannedQuantity || 0}개</strong></p>
        <p>이번 박스 스캔: <strong>${boxItem.scannedInThisBox}개</strong></p>
      </div>
      <p class="warning-message">할당된 수량을 초과했습니다. 추가로 발송하시겠습니까?</p>
      <div class="modal-actions">
        <button class="btn btn-primary" onclick="confirmExcessQuantity('${item.barcode}')">
          예, 추가 발송
        </button>
        <button class="btn btn-secondary" onclick="closeModal()">
          아니오
        </button>
      </div>
    </div>
  `;
  
  showModal(modalContent);
}

// 초과 수량 확인
function confirmExcessQuantity(barcode) {
  const item = ShippingState.exportedItems.find(i => i.barcode === barcode);
  const boxItem = ShippingState.currentBox.items[barcode];
  
  if (item && boxItem) {
    boxItem.scannedInThisBox++;
    item.remainingQuantity++; // 초과분 반영
    
    updateShippingItemUI(barcode);
    updateBoxProgress();
    
    speak(`${item.name} 추가 발송`);
    showScanFeedback(`${item.name} - 추가 발송 확인`, 'success');
  }
  
  closeModal();
}

// 자동 저장
function startShippingAutoSave() {
  // 기존 타이머 제거
  if (ShippingState.autoSaveTimer) {
    clearInterval(ShippingState.autoSaveTimer);
  }
  
  // 3초마다 세션 저장 (5초에서 3초로 단축)
  ShippingState.autoSaveTimer = setInterval(() => {
    // 현재 박스에 항목이 있을 때만 저장
    if (ShippingState.currentBox.barcode && 
        Object.keys(ShippingState.currentBox.items).length > 0) {
      saveShippingSession();
    }
  }, 3000); // 3초로 변경
}

// 세션 저장
// saveShippingSession 함수 수정
function saveShippingSession() {
  // exportedItems 제외한 컴팩트 세션
  const compactSession = {
    currentBox: ShippingState.currentBox,
    currentBoxNumber: ShippingState.currentBoxNumber,
    scanState: ShippingState.scanState,
    lastActivity: new Date().toISOString(),
    orderId: AppState.currentOrderInfo?.orderId
  };
  
  // 1. localStorage는 전체 데이터 저장 (제한 없음)
  try {
    const fullSession = {
      ...compactSession,
      exportedItems: ShippingState.exportedItems
    };
    localStorage.setItem('shippingSession', JSON.stringify(fullSession));
  } catch (e) {
    console.warn('로컬 저장 실패:', e);
  }
  
  // 2. 서버는 컴팩트 버전 저장
  const now = Date.now();
  const timeSinceLastSave = now - (ShippingState.lastServerSaveTime || 0);
  
  if (!ShippingState.lastServerSaveTime || 
      timeSinceLastSave > 5000 || 
      ShippingState.scanState === 'COMPLETING') {
    
    google.script.run
      .withSuccessHandler((result) => {
        ShippingState.lastServerSaveTime = now;
        console.log(`서버 세션 저장 완료 (${result.location}, ${result.size} bytes)`);
      })
      .withFailureHandler((error) => {
        console.warn('서버 세션 저장 실패:', error);
      })
      .saveShippingSession(compactSession);
  }
}

// 세션 복원 함수 수정
function restoreShippingSession() {
  // 강제 리프레시 플래그 확인
  const forceRefresh = sessionStorage.getItem('forceRefreshShipping');
  if (forceRefresh === 'true') {
    sessionStorage.removeItem('forceRefreshShipping');
    localStorage.removeItem('shippingSession');
    return false;
  }
  
  // 1. 먼저 localStorage 확인 (빠른 복원)
  try {
    const localSession = localStorage.getItem('shippingSession');
    if (localSession) {
      const sessionData = JSON.parse(localSession);
      
      // 세션 유효성 검사
      const sessionAge = Date.now() - new Date(sessionData.lastActivity).getTime();
      const isValidSession = sessionData.orderId === AppState.currentOrderInfo?.orderId && 
                            sessionAge < 30 * 24 * 60 * 60 * 1000; // 30일로 변경
      
      if (isValidSession && sessionData.currentBox?.barcode) {
        applyShippingSession(sessionData);
        
        // 세션 나이에 따른 메시지
        const ageMessage = getSessionAgeMessage(sessionAge);
        showInfo(`이전 작업이 복원되었습니다. (${ageMessage})`);
        
        console.log('로컬 세션 복원됨');
        
        // 백그라운드에서 서버 세션도 확인
        checkServerSession();
        return true;
      } else if (!isValidSession) {
        // 유효하지 않은 세션 삭제
        localStorage.removeItem('shippingSession');
      }
    }
  } catch (e) {
    console.warn('로컬 세션 복원 실패:', e);
    localStorage.removeItem('shippingSession');
  }
  
  // 2. localStorage가 없으면 서버에서 확인
  google.script.run
    .withSuccessHandler(function(sessionData) {
      if (sessionData && sessionData.orderId === AppState.currentOrderInfo?.orderId) {
        const sessionAge = Date.now() - new Date(sessionData.lastActivity).getTime();
        
        if (sessionAge < 7 * 24 * 60 * 60 * 1000 && sessionData.currentBox?.barcode) {
          applyShippingSession(sessionData);
          
          // 로컬에도 저장
          localStorage.setItem('shippingSession', JSON.stringify(sessionData));
          
          const ageMessage = getSessionAgeMessage(sessionAge);
          showInfo(`이전 작업이 복원되었습니다. (${ageMessage})`);
          displayShippingInterface();
        }
      }
    })
    .withFailureHandler((error) => {
      console.warn('서버 세션 복원 실패:', error);
    })
    .getShippingSession();
  
  return false;
}

// 세션 나이 메시지 헬퍼
function getSessionAgeMessage(ageMs) {
  const minutes = Math.floor(ageMs / (1000 * 60));
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  
  if (days > 0) {
    return `${days}일 전`;
  } else if (hours > 0) {
    return `${hours}시간 전`;
  } else if (minutes > 0) {
    return `${minutes}분 전`;
  } else {
    return '방금 전';
  }
}

// 서버 세션 확인 (백그라운드)
function checkServerSession() {
  google.script.run
    .withSuccessHandler(function(serverSession) {
      if (serverSession && serverSession.lastActivity) {
        const localSession = JSON.parse(localStorage.getItem('shippingSession') || '{}');
        
        // 서버가 더 최신이면 업데이트
        if (new Date(serverSession.lastActivity) > new Date(localSession.lastActivity || 0)) {
          applyShippingSession(serverSession);
          localStorage.setItem('shippingSession', JSON.stringify(serverSession));
          console.log('서버 세션으로 업데이트됨');
        }
      }
    })
    .getShippingSession();
}

// 시간 표시 헬퍼
function formatTimeAgo(dateString) {
  const date = new Date(dateString);
  const now = new Date();
  const diff = now - date;
  
  const hours = Math.floor(diff / (1000 * 60 * 60));
  const days = Math.floor(hours / 24);
  
  if (days > 0) {
    return `${days}일 전`;
  } else if (hours > 0) {
    return `${hours}시간 전`;
  } else {
    const minutes = Math.floor(diff / (1000 * 60));
    return `${minutes}분 전`;
  }
}

// 세션 적용
function applyShippingSession(sessionData) {
  console.log('세션 적용 시작:', sessionData);
  
  // 현재 박스 정보 복원
  if (sessionData.currentBox && sessionData.currentBox.barcode) {
    ShippingState.currentBox = sessionData.currentBox;
    ShippingState.scanState = sessionData.scanState || 'SCANNING';
    
    console.log('박스 정보 복원됨:', ShippingState.currentBox);
  }
  
  // 내보내기 항목 복원
  if (sessionData.exportedItems) {
    ShippingState.exportedItems = sessionData.exportedItems;
  }
  
  // 박스 번호 복원
  if (sessionData.currentBoxNumber) {
    ShippingState.currentBoxNumber = sessionData.currentBoxNumber;
  }
}

// ===== 패킹리스트 관련 함수들 =====

// 패킹리스트 내보내기
function exportPackingList() {
  // 현재 진행 중인 박스가 있는지 확인
  if (ShippingState.currentBox.barcode && Object.keys(ShippingState.currentBox.items).length > 0) {
    showError('박스 패킹이 완료되지 않았습니다. 작업 완료 후 내보내기를 진행해주세요.');
    return;
  }
  
  if (!AppState.currentOrderInfo || !AppState.currentOrderInfo.orderId) {
    showError('발주서가 없습니다.');
    return;
  }
  
  showLoading('패킹리스트를 생성하는 중...');
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      
      if (result.success) {
        showQuickSuccess(result.message);
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('내보내기 실패: ' + error);
    })
    .exportPackingList(AppState.currentOrderInfo.orderId);
}

// 패킹리스트 보기
function viewPackingList() {
  if (!AppState.currentOrderInfo || !AppState.currentOrderInfo.orderId) {
    showError('발주서가 없습니다.');
    return;
  }
  
  google.script.run
    .withSuccessHandler(function(result) {
      if (result.success && result.sheetUrl) {
        window.open(result.sheetUrl, '_blank');
      } else {
        showError(result.message || '패킹리스트를 찾을 수 없습니다.');
      }
    })
    .withFailureHandler(function(error) {
      showError('시트 열기 실패: ' + error);
    })
    .getPackingListUrl(AppState.currentOrderInfo.orderId);
}

// 패킹리스트 다운로드
function downloadPackingList() {
  if (!AppState.currentOrderInfo || !AppState.currentOrderInfo.orderId) {
    showError('발주서가 없습니다.');
    return;
  }
  
  showLoading('CSV 파일 생성 중...');
  
  google.script.run
    .withSuccessHandler(function(result) {
      hideLoading();
      
      if (result.success) {
        // CSV 다운로드
        const blob = new Blob([result.csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = result.filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        showQuickSuccess('다운로드가 완료되었습니다.');
      } else {
        showError(result.message);
      }
    })
    .withFailureHandler(function(error) {
      hideLoading();
      showError('다운로드 실패: ' + error);
    })
    .downloadPackingListCSV(AppState.currentOrderInfo.orderId);
}

// 출고 인터페이스 표시 함수 수정
const originalDisplayShippingInterface = displayShippingInterface;
displayShippingInterface = function() {
  originalDisplayShippingInterface();
  
  // 패킹리스트 버튼 추가
  const boxStatusBar = document.querySelector('.box-status-bar');
  if (boxStatusBar && !document.getElementById('packing-list-buttons')) {
    const packingListButtons = document.createElement('div');
    packingListButtons.id = 'packing-list-buttons';
    packingListButtons.className = 'packing-list-buttons';
    packingListButtons.innerHTML = `
      <button class="btn btn-primary" onclick="exportPackingList()" title="패킹리스트 내보내기">
        📤 내보내기
      </button>
      <button class="btn btn-secondary" onclick="viewPackingList()" title="패킹리스트 보기">
        📋 패킹리스트
      </button>
      <button class="btn btn-secondary" onclick="downloadPackingList()" title="CSV 다운로드">
        💾 다운로드
      </button>
    `;
    
    boxStatusBar.appendChild(packingListButtons);
  }
};

// getPackingListUrl 함수를 위한 서버 함수 추가 (Code.gs에 추가)
function getPackingListUrl(orderId) {
  try {
    const ss = SpreadsheetApp.openById(orderId);
    const packingSheet = ss.getSheetByName('패킹리스트');
    
    if (packingSheet) {
      return {
        sheetUrl: ss.getUrl() + '#gid=' + packingSheet.getSheetId()
      };
    }
    
    return { sheetUrl: null };
  } catch (error) {
    console.error('패킹리스트 URL 가져오기 실패:', error);
    return { sheetUrl: null };
  }
}

// 탭 전환 시 정리
function cleanupShippingTab() {
  if (ShippingState.autoSaveTimer) {
    clearInterval(ShippingState.autoSaveTimer);
    ShippingState.autoSaveTimer = null;
  }
  
  // 진행 중인 작업이 있으면 세션 저장
  if (ShippingState.scanState !== 'IDLE') {
    saveShippingSession();
  }
}

// 롤백 함수
function rollbackBoxCompletion() {
  // UI 상태를 이전으로 되돌림
  Object.entries(ShippingState.currentBox.items).forEach(([barcode, boxItem]) => {
    const item = ShippingState.exportedItems.find(i => i.barcode === barcode);
    if (item) {
      item.remainingQuantity += boxItem.scannedInThisBox;
      item.scannedQuantity = (item.scannedQuantity || 0) - boxItem.scannedInThisBox;
    }
  });
  
  displayShippingList();
}









// Smaregi 연결 상태 확인
// Smaregi 연결 상태 확인 (초기화 시 호출)
function checkSmaregiConnection() {
  console.log('=== Smaregi 연결 상태 확인 시작 ===');
  
  google.script.run
    .withSuccessHandler(function(result) {
      console.log('Smaregi 연결 상태:', result);
      
      // AppState 업데이트
      AppState.smaregiConnected = result.connected;
      
      if (result.connected && result.hasData) {
        // 재고 데이터가 있으면 AppState에 저장
        console.log(`Smaregi 연결 성공: ${result.itemCount}개 상품`);
        showQuickSuccess(`Smaregi API 연결됨 (${result.itemCount}개 상품)`);
      } else if (result.connected) {
        console.log('Smaregi 연결됨 (데이터 없음)');
        AppState.smaregiConnected = true;
      } else {
        console.log('Smaregi 연결 안됨');
        AppState.smaregiConnected = false;
      }
      
      // UI 업데이트
      updateSmaregiStatus();
    })
    .withFailureHandler(function(error) {
      console.error('Smaregi 연결 확인 실패:', error);
      AppState.smaregiConnected = false;
      updateSmaregiStatus();
    })
    .checkSmaregiConnection();
}

// Smaregi 연결 새로고침
function refreshSmaregiConnection() {
  showSaveIndicator('loading');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        showQuickSuccess('재고 데이터가 새로고침되었습니다.');
        checkSmaregiConnection();
        
        // 현재 발주서가 있으면 재고 정보 업데이트
        if (AppState.currentOrderInfo) {
          updateOrderStockInfo();
        }
      } else {
        showError('새로고침 실패: ' + result.message);
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('연결 실패: ' + error);
    })
    .syncSmaregiData();
}

// 자동 발주 제안 표시
function showAutoSuggestions() {
  const modal = document.getElementById('auto-suggest-modal');
  if (modal) {
    modal.style.display = 'block';
    // AI 발주 제안 데이터 로드
    loadAutoSuggestions();
  } else {
    showError('AI 발주 제안 기능을 준비중입니다.');
  }
}

// 자동 제안 목록 표시
function displayAutoSuggestions(suggestions) {
  const modal = document.getElementById('auto-suggest-modal');
  const list = document.getElementById('suggest-list');
  
  // 통계 업데이트
  const stats = {
    outOfStock: suggestions.filter(s => s.currentStock === 0).length,
    lowStock: suggestions.filter(s => s.currentStock > 0 && s.currentStock < 10).length,
    urgent: suggestions.filter(s => s.priority === 1).length
  };
  
  document.getElementById('out-of-stock-count').textContent = stats.outOfStock;
  document.getElementById('low-stock-count').textContent = stats.lowStock;
  document.getElementById('urgent-count').textContent = stats.urgent;
  
  // 제안 목록 생성
  list.innerHTML = suggestions.map((item, index) => {
    const priorityClass = item.priority === 1 ? 'urgent' : item.priority === 2 ? 'warning' : '';
    const stockClass = item.currentStock === 0 ? 'critical' : '';
    
    return `
      <div class="suggest-item ${priorityClass}" data-index="${index}">
        <input type="checkbox" class="suggest-checkbox" checked>
        <div class="suggest-item-info">
          <div class="suggest-product-name">
            ${item.name}
            ${item.isTrending ? '<span class="suggest-reason">인기</span>' : ''}
            ${item.isFrequent ? '<span class="suggest-reason">자주발주</span>' : ''}
          </div>
          <div class="suggest-details">
            ${item.barcode} | ${item.option || '옵션없음'} | ${item.supplierName || ''}
          </div>
        </div>
        <div class="suggest-quantity">
          <div class="suggest-stock ${stockClass}">
            재고: ${item.currentStock}개
          </div>
          <input type="number" class="suggest-qty-input" value="${item.suggestedQuantity}" min="1">
        </div>
      </div>
    `;
  }).join('');
  
  // 제안 데이터 저장
  window.currentSuggestions = suggestions;
  
  modal.style.display = 'block';
}

// 선택한 제안 추가
function addSelectedSuggestions() {
  const checkboxes = document.querySelectorAll('.suggest-checkbox:checked');
  const itemsToAdd = [];
  
  checkboxes.forEach(checkbox => {
    const item = checkbox.closest('.suggest-item');
    const index = parseInt(item.dataset.index);
    const quantity = parseInt(item.querySelector('.suggest-qty-input').value);
    const suggestion = window.currentSuggestions[index];
    
    itemsToAdd.push({
      barcode: suggestion.barcode,
      name: suggestion.name,
      option: suggestion.option,
      quantity: quantity,
      memo: suggestion.reason || '',
      priority: suggestion.priority,
      supplierName: suggestion.supplierName
    });
  });
  
  if (itemsToAdd.length === 0) {
    showError('선택한 상품이 없습니다.');
    return;
  }
  
  // 발주서에 추가
  itemsToAdd.forEach(item => {
    addToOrderList(item);
  });
  
  closeModal('auto-suggest-modal');
  showQuickSuccess(`${itemsToAdd.length}개 상품이 발주서에 추가되었습니다.`);
}

// 전체 제안 추가
function addAllSuggestions() {
  const items = document.querySelectorAll('.suggest-item');
  const itemsToAdd = [];
  
  items.forEach((item, index) => {
    const quantity = parseInt(item.querySelector('.suggest-qty-input').value);
    const suggestion = window.currentSuggestions[index];
    
    itemsToAdd.push({
      barcode: suggestion.barcode,
      name: suggestion.name,
      option: suggestion.option,
      quantity: quantity,
      memo: suggestion.reason || '',
      priority: suggestion.priority,
      supplierName: suggestion.supplierName
    });
  });
  
  // 발주서에 추가
  itemsToAdd.forEach(item => {
    addToOrderList(item);
  });
  
  closeModal('auto-suggest-modal');
  showQuickSuccess(`${itemsToAdd.length}개 상품이 발주서에 추가되었습니다.`);
}

// 발주서 재고 정보 업데이트
function updateOrderStockInfo() {
  if (!AppState.currentOrderInfo || !AppState.currentOrderInfo.orderId) {
    return;
  }
  
  showSaveIndicator('loading');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        showQuickSuccess(result.message);
        
        // UI 업데이트
        result.updates.forEach(update => {
          updateOrderItemStock(update);
        });
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('재고 업데이트 실패');
    })
    .updateOrderWithSmaregiData(AppState.currentOrderInfo.orderId);
}

// 개별 아이템 재고 표시 업데이트
function updateOrderItemStock(update) {
  const items = document.querySelectorAll('.order-item');
  
  items.forEach(item => {
    const barcode = item.querySelector('.item-barcode').textContent;
    if (barcode === update.barcode) {
      const stockBtn = item.querySelector('.stock-status-btn');
      if (stockBtn) {
        const statusClass = update.status === '가능' ? 'available' : 'unavailable';
        const statusIcon = update.status === '가능' ? '✅' : '❌';
        
        stockBtn.className = `stock-status-btn ${statusClass}`;
        stockBtn.innerHTML = `
          <span>${statusIcon}</span>
          <span>${update.status}</span>
          <span class="stock-count">(${update.stock}개)</span>
        `;
      }
    }
  });
}

// 대시보드 재고 현황 업데이트
function updateStockSummary(data) {
  if (document.getElementById('total-products')) {
    document.getElementById('total-products').textContent = data.totalItems || '-';
    document.getElementById('out-of-stock').textContent = data.outOfStock || '0';
    document.getElementById('low-stock').textContent = data.lowStock || '0';
    document.getElementById('normal-stock').textContent = data.normalStock || '0';
    document.getElementById('last-sync-time').textContent = 
      data.lastSync ? new Date(data.lastSync).toLocaleString('ko-KR') : '없음';
  }
}

// API 연결 테스트 (설정 페이지)
function testSmaregiConnection() {
  showSaveIndicator('loading');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      const indicator = document.getElementById('api-status-indicator');
      const message = document.getElementById('api-status-message');
      
      if (result.success) {
        indicator.classList.add('connected');
        indicator.classList.remove('error');
        message.textContent = `연결 성공! ${result.stores}개 매장 확인됨`;
        showQuickSuccess('Smaregi API 연결 테스트 성공');
      } else {
        indicator.classList.add('error');
        indicator.classList.remove('connected');
        message.textContent = '연결 실패: ' + result.message;
        showError('연결 테스트 실패');
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('테스트 실패: ' + error);
    })
    .testSmaregiConnection();
}

// 자동 동기화 설정
function setupAutoSync() {
  const interval = document.getElementById('sync-interval').value;
  
  if (interval === '0') {
    if (!confirm('자동 동기화를 비활성화하시겠습니까?')) {
      return;
    }
  }
  
  showSaveIndicator('loading');
  
  google.script.run
    .withSuccessHandler(function(result) {
      showSaveIndicator('hide');
      
      if (result.success) {
        showQuickSuccess(result.message);
      } else {
        showError('설정 실패');
      }
    })
    .withFailureHandler(function(error) {
      showSaveIndicator('hide');
      showError('설정 오류: ' + error);
    })
    .setupSmaregiTriggers();
}

// 기존 CSV 업로드 함수들 제거/비활성화
function showSmaregiUploadModal() {
  showError('CSV 업로드는 더 이상 사용되지 않습니다. API 연동이 활성화되어 있습니다.');
}

// 재고 상태 스타일 추가
const stockStatusStyles = `
  .stock-count {
    font-size: 11px;
    margin-left: 4px;
    opacity: 0.8;
  }
  
  .stock-status-btn.available .stock-count {
    color: #4caf50;
  }
  
  .stock-status-btn.unavailable .stock-count {
    color: #f44336;
  }
`;

// 스타일 추가
const styleSheet = document.createElement('style');
styleSheet.textContent = stockStatusStyles;
document.head.appendChild(styleSheet);











// ===== 기존 switchTab 함수 수정 =====
const originalSwitchTab = window.switchTab;
window.switchTab = function(tabName) {
  // 이전 탭 정리
  const activeTab = document.querySelector('.nav-btn.active');
  if (activeTab && activeTab.dataset.tab === 'shipping') {
    cleanupShippingTab();
  }
  
  // 기존 함수 호출
  originalSwitchTab(tabName);
  
  // 출고 탭 활성화
  if (tabName === 'shipping') {
    // 강제 리프레시 플래그 확인
    const forceRefresh = sessionStorage.getItem('forceRefreshShipping');
    if (forceRefresh === 'true') {
      sessionStorage.removeItem('forceRefreshShipping');
      localStorage.removeItem('shippingSession');
    }
    
    loadShippingTab();
  }
};

// ===== 기존 updateOrderList 함수 수정 (출고 완료 표시) =====
const originalUpdateOrderList = window.updateOrderList;
window.updateOrderList = function() {
  // 기존 함수 호출
  originalUpdateOrderList.apply(this, arguments);
  
  // 출고 완료된 항목에 박스번호 표시
  AppState.orderItems.forEach(item => {
    if (item.boxNumbers) {
      const orderItemEl = document.querySelector(`[data-id="${item.id}"]`);
      if (orderItemEl && !orderItemEl.querySelector('.box-info')) {
        // 박스 정보 포맷 개선 - 슬래시로 구분
        const formattedBoxInfo = item.boxNumbers.replace(/(\d+)\((\d+)\)/g, '$1번($2개)')
                                               .replace(/\), /g, ') / ');
        
        const boxInfo = document.createElement('div');
        boxInfo.className = 'box-info';
        boxInfo.innerHTML = `
          <span class="box-icon">📦</span>
          <span class="box-numbers">${formattedBoxInfo}</span>
        `;
        
        const actionsEl = orderItemEl.querySelector('.order-actions');
        if (actionsEl) {
          orderItemEl.insertBefore(boxInfo, actionsEl);
        }
        
        // 출고 완료 항목은 삭제 버튼 비활성화
        const deleteBtn = orderItemEl.querySelector('.order-action-btn.delete');
        if (deleteBtn) {
          deleteBtn.disabled = true;
          deleteBtn.title = '출고된 항목은 삭제할 수 없습니다';
        }
      }
    }
  });
};

// ===== 전역 이벤트 리스너에 출고 탭 정리 추가 =====
window.addEventListener('beforeunload', function(e) {
  // 출고 작업 중이면 무조건 세션 저장
  if (ShippingState.currentBox.barcode || ShippingState.exportedItems.length > 0) {
    saveShippingSession();
  }
  
  if (AppState.hasUnsavedChanges || ShippingState.scanState === 'SCANNING') {
    e.preventDefault();
    e.returnValue = '진행 중인 작업이 있습니다.';
  }
});

window.loadShippingTab = loadShippingTab;
window.cleanupShippingTab = cleanupShippingTab;
window.forceCompleteBox = forceCompleteBox;
window.confirmExcessQuantity = confirmExcessQuantity;
window.completeBox = completeBox;

window.showCommentInput = showCommentInput;
window.saveComment = saveComment;
window.removeItem = removeItem;
window.showModal = showModal;
window.closeModal = closeModal;
window.updateQuantity = updateQuantity;
window.showQuickStockMenu = showQuickStockMenu;
window.setQuickStock = setQuickStock;
window.showStockStatusModal = showStockStatusModal;
window.saveStockStatus = saveStockStatus;
window.refreshFrequentItems = refreshFrequentItems;


// ===== scripts.html 끝 =====



</script>
